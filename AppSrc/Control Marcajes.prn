Compiling Program: C:\DataFlex Projects\Control Marcajes\AppSrc\Control Marcajes.src
Memory Available: 2147483646
1>//**************************************************************
1>// WindowsProject.tpl for Spanish translated by Moose Software (www.moose-software.com) 
1>// 28/10/2008 revised for VDF 14.1 by Moose Software  
1>// 13/07/2010 Revised for VDF 16.0 by Moose Software
1>// 05/02/2012 Revised for VDF 17.0 by Moose Software
1>// 13/06/2013 Revised for VDF 17.1 by Moose Software
1>// 02/05/2014 Revised for VDF 18.0 by Moose Software
1>//*************************************************************************************
1>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.pkd    (C:\Program Files (x86)\DataFlex 18.2\Pkg\dfallent.pkd)
75339>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cCJStandardCommandBarSystem.pkg)
75339>>>// these are all the packages used in a standard MDI menubar/toolbar system
75339>>>
75339>>>Use cCJCommandBarSystem.pkg
75339>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cCJStandardMenuItemClasses.pkg)
75339>>>>>Use Dfpanel.pkg
75339>>>>>Use cCJCommandBarSystem.pkg
75339>>>>>Use LanguageText.pkg
75339>>>>>
75339>>>>>
75339>>>>>Class cCJUndoMenuItem is a cCJMenuItem
75340>>>>>    
75340>>>>>    Procedure Construct_Object
75342>>>>>        Forward Send Construct_Object
75344>>>>>        Set psCaption   to C_$CaptionUndo
75345>>>>>        Set psToolTip to C_$ToolTipUndo
75346>>>>>        Set psDescription to C_$DescUndo
75347>>>>>        Set psImage to "ActionUndo.ico"
75348>>>>>        Set pbActiveUpdate to True
75349>>>>>        Set psCategory to C_$CategoryEdit
75350>>>>>        Set psShortcut to C_$Key_Ctrl_Z
75351>>>>>    End_Procedure
75352>>>>>
75352>>>>>    Procedure OnExecute Variant vCommandBarControl
75354>>>>>        Send Undo of (focus(Self))
75355>>>>>    End_Procedure
75356>>>>>    
75356>>>>>    Function IsEnabled Returns Boolean
75358>>>>>        Boolean bEnabled
75358>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
75359>>>>>        Function_Return bEnabled
75360>>>>>    End_Function
75361>>>>>         
75361>>>>>End_Class
75362>>>>>
75362>>>>>
75362>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
75363>>>>>    
75363>>>>>    Procedure Construct_Object
75365>>>>>        Forward Send Construct_Object
75367>>>>>        Set psCaption   to C_$CaptionDelete
75368>>>>>        Set psToolTip to C_$ToolTipDelete
75369>>>>>        Set psDescription to C_$DescDelete
75370>>>>>        Set psImage to "actionDelete.ico"
75371>>>>>        Set psShortcut to C_$Key_Delete
75372>>>>>        Set pbActiveUpdate to True
75373>>>>>        Set psCategory to C_$CategoryEdit
75374>>>>>    End_Procedure
75375>>>>>
75375>>>>>
75375>>>>>    Procedure OnExecute Variant vCommandBarControl
75377>>>>>        Send Delete of (focus(Self))
75378>>>>>    End_Procedure
75379>>>>>    
75379>>>>>    Function IsEnabled Returns Boolean
75381>>>>>        Boolean bEnabled
75381>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
75382>>>>>        Function_Return bEnabled
75383>>>>>    End_Function
75384>>>>>         
75384>>>>>End_Class
75385>>>>>
75385>>>>>
75385>>>>>Class cCJCutMenuItem is a cCJMenuItem
75386>>>>>    
75386>>>>>    Procedure Construct_Object
75388>>>>>        Forward Send Construct_Object
75390>>>>>        Set psCaption   to C_$CaptionCut
75391>>>>>        Set psToolTip to C_$TooltipCut
75392>>>>>        Set psDescription to C_$DescCut
75393>>>>>        Set psImage to "actionCut.ico"
75394>>>>>        Set psShortcut to C_$Key_Ctrl_X
75395>>>>>        Set pbActiveUpdate to True
75396>>>>>        Set psCategory to C_$CategoryEdit
75397>>>>>    End_Procedure
75398>>>>>
75398>>>>>
75398>>>>>    Procedure OnExecute Variant vCommandBarControl
75400>>>>>        Send Cut of (focus(Self))
75401>>>>>    End_Procedure
75402>>>>>    
75402>>>>>    Function IsEnabled Returns Boolean
75404>>>>>        Boolean bEnabled
75404>>>>>        Get CanCut of (Focus(Self)) to bEnabled
75405>>>>>        Function_Return bEnabled
75406>>>>>    End_Function
75407>>>>>         
75407>>>>>End_Class
75408>>>>>
75408>>>>>
75408>>>>>Class cCJCopyMenuItem is a cCJMenuItem
75409>>>>>    
75409>>>>>    Procedure Construct_Object
75411>>>>>        Forward Send Construct_Object
75413>>>>>        Set psCaption   to C_$CaptionCopy
75414>>>>>        Set psToolTip to C_$ToolTipCopy
75415>>>>>        Set psDescription to C_$DescCopy
75416>>>>>        Set psImage to "actionCopy.ico"
75417>>>>>        Set psShortcut to C_$Key_Ctrl_C
75418>>>>>        Set pbActiveUpdate to True
75419>>>>>        Set psCategory to C_$CategoryEdit
75420>>>>>    End_Procedure
75421>>>>>
75421>>>>>
75421>>>>>    Procedure OnExecute Variant vCommandBarControl
75423>>>>>        Send Copy of (focus(Self))
75424>>>>>    End_Procedure
75425>>>>>    
75425>>>>>    Function IsEnabled Returns Boolean
75427>>>>>        Boolean bEnabled
75427>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
75428>>>>>        Function_Return bEnabled
75429>>>>>    End_Function
75430>>>>>         
75430>>>>>End_Class
75431>>>>>
75431>>>>>
75431>>>>>Class cCJPasteMenuItem is a cCJMenuItem
75432>>>>>    
75432>>>>>    Procedure Construct_Object
75434>>>>>        Forward Send Construct_Object
75436>>>>>        Set psCaption   to C_$CaptionPaste
75437>>>>>        Set psToolTip to C_$ToolTipPaste
75438>>>>>        Set psDescription to C_$DescPaste
75439>>>>>        Set psImage to "actionPaste.ico"
75440>>>>>        Set pbActiveUpdate to True
75441>>>>>        Set psShortcut to C_$Key_Ctrl_V
75442>>>>>        Set psCategory to C_$CategoryEdit
75443>>>>>    End_Procedure
75444>>>>>
75444>>>>>
75444>>>>>    Procedure OnExecute Variant vCommandBarControl
75446>>>>>        Send Paste of (focus(Self))
75447>>>>>    End_Procedure
75448>>>>>    
75448>>>>>    Function IsEnabled Returns Boolean
75450>>>>>        Boolean bEnabled
75450>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
75451>>>>>        Function_Return bEnabled
75452>>>>>    End_Function
75453>>>>>         
75453>>>>>End_Class
75454>>>>>
75454>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
75455>>>>>    
75455>>>>>    Procedure Construct_Object
75457>>>>>        Forward Send Construct_Object
75459>>>>>        Set psCaption   to C_$CaptionSelectAll
75460>>>>>        Set psToolTip to C_$ToolTipSelectAll
75461>>>>>        Set psDescription to C_$DescSelectAll
75462>>>>>        Set pbActiveUpdate to True
75463>>>>>        Set psShortcut to C_$Key_Ctrl_A
75464>>>>>        Set psCategory to C_$CategoryEdit
75465>>>>>    End_Procedure
75466>>>>>
75466>>>>>
75466>>>>>    Procedure OnExecute Variant vCommandBarControl
75468>>>>>        Send Select_All of (focus(Self))
75469>>>>>    End_Procedure
75470>>>>>    
75470>>>>>    Function IsEnabled Returns Boolean
75472>>>>>        Boolean bEnabled
75472>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
75473>>>>>        Function_Return bEnabled
75474>>>>>    End_Function
75475>>>>>         
75475>>>>>End_Class
75476>>>>>
75476>>>>> 
75476>>>>>Class cCJExitMenuItem is a cCJMenuItem
75477>>>>>
75477>>>>>    Procedure Construct_Object
75479>>>>>        Forward Send Construct_Object
75481>>>>>        Set psCaption to C_$CaptionExit
75482>>>>>        Set psToolTip to C_$ToolTipExit
75483>>>>>        Set psDescription to C_$ToolTipExit
75484>>>>>        Set psShortcut to C_$Key_Alt_F4
75485>>>>>        Set psCategory to C_$CategoryFile
75486>>>>>    End_Procedure
75487>>>>>
75487>>>>>    Procedure OnExecute Variant vCommandBarControl
75489>>>>>        Send Exit_Application of Desktop
75490>>>>>    End_Procedure
75491>>>>>
75491>>>>>End_Class           
75492>>>>>
75492>>>>>Class cCJHelpMenuItem is a cCJMenuItem    
75493>>>>>
75493>>>>>    Procedure Construct_Object
75495>>>>>        Forward Send Construct_Object
75497>>>>>        Set psCaption to C_$CaptionHelp
75498>>>>>        Set psDescription to C_$ToolTipHelp
75499>>>>>        Set psToolTip to C_$DescHelp
75500>>>>>        Set psImage to "ActionHelp.ico"
75501>>>>>        Set psShortcut to "F1"
75502>>>>>        Set psCategory to C_$CategoryHelp
75503>>>>>    End_Procedure
75504>>>>>    
75504>>>>>    Procedure OnExecute Variant vCommandBarControl
75506>>>>>        Send Help of (Focus(Self))
75507>>>>>    End_Procedure
75508>>>>>
75508>>>>>End_Class
75509>>>>>
75509>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
75510>>>>>
75510>>>>>    Procedure Construct_Object
75512>>>>>        Forward Send Construct_Object
75514>>>>>        Set psCaption to C_$CaptionAddStatusbar
75515>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
75516>>>>>        Set psDescription to  C_$DescAddStatusbar
75517>>>>>        Set psCategory to C_$CategoryWindow
75518>>>>>    End_Procedure
75519>>>>>
75519>>>>>    Procedure OnExecute Variant vCommandBarControl
75521>>>>>        Handle hoCommandBars hoClientArea
75521>>>>>        Get CommandBarSystemObject to hoCommandBars
75522>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
75523>>>>>        If hoClientArea Begin
75525>>>>>            // the clientarea's parent panel has message
75525>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
75526>>>>>        End
75526>>>>>>
75526>>>>>    End_Procedure
75527>>>>>
75527>>>>>     Function IsChecked Returns Boolean
75529>>>>>        Boolean bOn
75529>>>>>        Handle hoCommandBars hoClientArea
75529>>>>>        Get CommandBarSystemObject to hoCommandBars
75530>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
75531>>>>>        If hoClientArea Begin
75533>>>>>            // the clientarea's parent panel has message
75533>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
75534>>>>>        End
75534>>>>>>
75534>>>>>        Function_Return bOn
75535>>>>>     End_Function
75536>>>>>End_Class
75537>>>>>
75537>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
75538>>>>>
75538>>>>>    Procedure Construct_Object
75540>>>>>        Forward Send Construct_Object
75542>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
75543>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
75544>>>>>        Set psDescription to C_$DescAutoArrangeIcons
75545>>>>>        Set psCategory to C_$CategoryWindow
75546>>>>>    End_Procedure
75547>>>>>
75547>>>>>    Procedure OnExecute Variant vCommandBarControl
75549>>>>>        Handle hoCommandBars hoClientArea
75549>>>>>        Get CommandBarSystemObject to hoCommandBars
75550>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
75551>>>>>        If hoClientArea Begin
75553>>>>>            // the clientarea's parent panel has message
75553>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
75554>>>>>        End
75554>>>>>>
75554>>>>>    End_Procedure
75555>>>>>    
75555>>>>>     Function IsChecked Returns Boolean
75557>>>>>        Boolean bOn
75557>>>>>        Handle hoCommandBars hoClientArea
75557>>>>>        Get CommandBarSystemObject to hoCommandBars
75558>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
75559>>>>>        If hoClientArea Begin
75561>>>>>            // the clientarea's parent panel has message
75561>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
75562>>>>>        End
75562>>>>>>
75562>>>>>        Function_Return bOn
75563>>>>>     End_Function
75564>>>>>End_Class
75565>>>>>
75565>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
75566>>>>>
75566>>>>>    Procedure Construct_Object
75568>>>>>        Forward Send Construct_Object
75570>>>>>        Set psCaption to C_$CaptionRestoreMenus
75571>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
75572>>>>>        Set psDescription to C_$DescRestoreMenus
75573>>>>>        Set psCategory to C_$CategoryWindow
75574>>>>>    End_Procedure
75575>>>>>
75575>>>>>    Procedure OnExecute Variant vCommandBarControl
75577>>>>>        Handle hoCommandBars
75577>>>>>        Get CommandBarSystemObject to hoCommandBars
75578>>>>>        Send RestoreLayout of hoCommandBars
75579>>>>>    End_Procedure
75580>>>>>    
75580>>>>>End_Class
75581>>>>>
75581>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
75582>>>>>
75582>>>>>    Procedure Construct_Object
75584>>>>>        Forward Send Construct_Object
75586>>>>>        Set psCaption to C_$CaptionCascade
75587>>>>>        Set psToolTip to C_$ToolTipCascade
75588>>>>>        Set psDescription to  C_$DescCascade
75589>>>>>        Set psImage to "ActionCascade.ico"
75590>>>>>        Set psCategory to C_$CategoryWindow
75591>>>>>    End_Procedure
75592>>>>>    
75592>>>>>    Procedure OnExecute Variant vCommandBarControl
75594>>>>>        Handle hoCommandBars hoClientArea
75594>>>>>        Get CommandBarSystemObject to hoCommandBars
75595>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
75596>>>>>        If hoClientArea Begin
75598>>>>>            Send Cascade_Windows of hoClientArea
75599>>>>>        End
75599>>>>>>
75599>>>>>    End_Procedure
75600>>>>>End_Class
75601>>>>>
75601>>>>>Class cCJTileHorizontally is a cCJMenuItem
75602>>>>>
75602>>>>>    Procedure Construct_Object
75604>>>>>        Forward Send Construct_Object
75606>>>>>        Set psCaption to C_$CaptionTileHorizontally 
75607>>>>>        Set psToolTip to C_$ToolTipTileHorizontally  
75608>>>>>        Set psDescription to  C_$DescTileHorizontally
75609>>>>>        Set psImage to "ActionTileHorizontally.ico"
75610>>>>>        Set psCategory to C_$CategoryWindow
75611>>>>>    End_Procedure
75612>>>>>
75612>>>>>    Procedure OnExecute Variant vCommandBarControl
75614>>>>>        Handle hoCommandBars hoClientArea
75614>>>>>        Get CommandBarSystemObject to hoCommandBars
75615>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
75616>>>>>        If hoClientArea Begin
75618>>>>>            Send Tile_Windows_Horizontal of hoClientArea
75619>>>>>        End
75619>>>>>>
75619>>>>>    End_Procedure
75620>>>>>End_Class
75621>>>>>
75621>>>>>Class cCJTileVertically is a cCJMenuItem
75622>>>>>
75622>>>>>    Procedure Construct_Object
75624>>>>>        Forward Send Construct_Object
75626>>>>>        Set psCaption to C_$CaptionTileVertically  
75627>>>>>        Set psToolTip to C_$ToolTipTileVertically
75628>>>>>        Set psDescription to  C_$DescTileVertically
75629>>>>>        Set psImage to "ActionTileVertically.ico"
75630>>>>>        Set psCategory to C_$CategoryWindow
75631>>>>>    End_Procedure
75632>>>>>
75632>>>>>    Procedure OnExecute Variant vCommandBarControl
75634>>>>>        Handle hoCommandBars hoClientArea
75634>>>>>        Get CommandBarSystemObject to hoCommandBars
75635>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
75636>>>>>        If hoClientArea Begin
75638>>>>>            Send Tile_Windows_Vertical of hoClientArea
75639>>>>>        End
75639>>>>>>
75639>>>>>    End_Procedure
75640>>>>>End_Class
75641>>>>>
75641>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
75642>>>>>
75642>>>>>    Procedure Construct_Object
75644>>>>>        Forward Send Construct_Object
75646>>>>>        Set psCaption to C_$CaptionMinimizeWindows 
75647>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
75648>>>>>        Set psDescription to  C_$DescMinimizeWindows
75649>>>>>        Set psCategory to C_$CategoryWindow
75650>>>>>    End_Procedure
75651>>>>>
75651>>>>>    Procedure OnExecute Variant vCommandBarControl
75653>>>>>        Handle hoCommandBars hoClientArea
75653>>>>>        Get CommandBarSystemObject to hoCommandBars
75654>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
75655>>>>>        If hoClientArea Begin
75657>>>>>            // the clientarea's parent panel has message
75657>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
75658>>>>>        End
75658>>>>>>
75658>>>>>    End_Procedure
75659>>>>>End_Class
75660>>>>>
75660>>>>>
75660>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
75661>>>>>
75661>>>>>    Procedure Construct_Object
75663>>>>>        Forward Send Construct_Object
75665>>>>>        Set psCaption to C_$CaptionRestoreWindows
75666>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
75667>>>>>        Set psDescription to  C_$DescRestoreWindows
75668>>>>>        Set psCategory to C_$CategoryWindow
75669>>>>>    End_Procedure
75670>>>>>
75670>>>>>    Procedure OnExecute Variant vCommandBarControl
75672>>>>>        Handle hoCommandBars hoClientArea
75672>>>>>        Get CommandBarSystemObject to hoCommandBars
75673>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
75674>>>>>        If hoClientArea Begin
75676>>>>>            // the clientarea's parent panel has message
75676>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
75677>>>>>        End
75677>>>>>>
75677>>>>>    End_Procedure
75678>>>>>End_Class
75679>>>>>
75679>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
75680>>>>>
75680>>>>>    Procedure Construct_Object
75682>>>>>        Forward Send Construct_Object
75684>>>>>        Set psCaption to C_$CaptionArrangeIcons  
75685>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
75686>>>>>        Set psDescription to  C_$DescArrangeIcons
75687>>>>>        Set psCategory to C_$CategoryWindow
75688>>>>>    End_Procedure
75689>>>>>
75689>>>>>    Procedure OnExecute Variant vCommandBarControl
75691>>>>>        Handle hoCommandBars hoClientArea
75691>>>>>        Get CommandBarSystemObject to hoCommandBars
75692>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
75693>>>>>        If hoClientArea Begin
75695>>>>>            Send Arrange_Icons of hoClientArea
75696>>>>>        End
75696>>>>>>
75696>>>>>    End_Procedure
75697>>>>>
75697>>>>>End_Class
75698>>>>>    
75698>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cCJAboutMenuItem.pkg)
75698>>>>>Use cCJCommandBarSystem.pkg
75698>>>>>Use LanguageText.pkg
75698>>>>>
75698>>>>>// It is expected that if you use this class that you provide an about object that is
75698>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
75698>>>>>// because you may wish to create your own custom about package.
75698>>>>>
75698>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
75699>>>>>
75699>>>>>    Procedure Construct_Object
75701>>>>>        Forward Send Construct_Object
75703>>>>>        Set psCaption to C_$CaptionAbout
75704>>>>>        Set psDescription to C_$ToolTipAbout
75705>>>>>        Set psToolTip to C_$DescAbout
75706>>>>>        Set psImage to "ActionAbout.ico"
75707>>>>>        Set psCategory to C_$CategoryHelp
75708>>>>>    End_Procedure
75709>>>>>    
75709>>>>>    Procedure OnExecute Variant vCommandBarControl
75711>>>>>        Handle hoCommandBars hoClientArea
75711>>>>>        Get CommandBarSystemObject to hoCommandBars
75712>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
75713>>>>>        If hoClientArea Begin
75715>>>>>            Send Activate_About of hoClientArea
75716>>>>>        End
75716>>>>>>
75716>>>>>    End_Procedure
75717>>>>>
75717>>>>>End_Class
75718>>>>>
75718>>>>>
75718>>>Use cCJDeoMenuItemClasses.pkg
75718>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cCJMDIWindowsMenuItem.pkg)
75718>>>>>Use cCJCommandBarSystem.pkg
75718>>>>>
75718>>>>>Register_Function Client_ID Returns Integer
75718>>>>>
75718>>>>>// only used by cCJMDIWIndowsMenuItem
75718>>>>>Class cCJMDIWindowItem is a cCJMenuItem
75719>>>>>
75719>>>>>    Procedure Construct_Object
75721>>>>>        Forward Send Construct_Object
75723>>>>>        Property Handle phWindow 0 // object id of view
75724>>>>>        Set pbControlFlagNoMovable to True
75725>>>>>        Set pbActiveUpdate to True
75726>>>>>    End_Procedure
75727>>>>>    
75727>>>>>    Procedure OnExecute Variant vCommandBarControl
75729>>>>>        Handle hWindow
75729>>>>>        Get phWindow to hWindow
75730>>>>>        Send Activate_View of hWindow
75731>>>>>    End_Procedure
75732>>>>>    
75732>>>>>End_Class                
75733>>>>>
75733>>>>>
75733>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
75734>>>>>    
75734>>>>>    Procedure Construct_Object
75736>>>>>        Forward Send Construct_Object
75738>>>>>        Property Handle[] phArrayOfWindows
75739>>>>>        Set peControlType to xtpControlPopup
75740>>>>>        Set psCategory to C_$CategoryWindow
75741>>>>>    End_Procedure
75742>>>>>    
75742>>>>>     // This adds MDI windows to the existing menu items.
75742>>>>>     // This removes any existing windows menus and always adds a new set to the end
75742>>>>>
75742>>>>>     Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
75744>>>>>        Handle  hClientArea hView
75744>>>>>        String  sLabel
75744>>>>>        Integer i iWindows
75744>>>>>        Handle[] hArrayOfWindows
75745>>>>>        Variant vItem
75745>>>>>        
75745>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
75745>>>>>        // also assume that destroying an action removes all menu instances of that action
75745>>>>>        Get phArrayOfWindows to hArrayOfWindows
75746>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
75747>>>>>        For i from 0 to (iWindows-1)
75753>>>>>>
75753>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
75754>>>>>        Loop
75755>>>>>>
75755>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
75756>>>>>
75756>>>>>        // Add all views to this menu. Create the action and add the item
75756>>>>>        Move 0 to i
75757>>>>>        Get Client_Id to hClientArea // object id of client area
75758>>>>>        If (hClientArea > 0) Begin
75760>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
75761>>>>>            While (hView <> 0)
75765>>>>>                If (Active_State(hView)) Begin
75767>>>>>                    // create the action
75767>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
75768>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
75769>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
75770>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
75771>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
75773>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
75774>>>>>                    End
75774>>>>>>
75774>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
75775>>>>>                    If (i=0) Begin
75777>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
75778>>>>>                    End
75778>>>>>>
75778>>>>>                    // Create a menu item for this action
75778>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
75779>>>>>                    Increment i
75780>>>>>                End
75780>>>>>>
75780>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
75781>>>>>            Loop
75782>>>>>>
75782>>>>>        End
75782>>>>>>
75782>>>>>
75782>>>>>        Set phArrayOfWindows to hArrayOfWindows
75783>>>>>
75783>>>>>     End_Procedure
75784>>>>>     
75784>>>>>End_Class
75785>>>>>
75785>Use MonthCalendarPrompt.dg
Including file: MonthCalendarPrompt.dg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\MonthCalendarPrompt.dg)
75785>>>// Month Calendar Prompt dialog
75785>>>
75785>>>
75785>>>Use cMonthCalendarPrompt.pkg
Including file: cMonthCalendarPrompt.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cMonthCalendarPrompt.pkg)
75785>>>>>Use cMonthCalendar.pkg
Including file: cMonthCalendar.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cMonthCalendar.pkg)
75785>>>>>>>Use Windows.pkg
75785>>>>>>>Use Commctrl.pkg
75785>>>>>>>Use tWinStructs.pkg
75785>>>>>>>Use cWinControlEx.pkg
Including file: cWinControlEx.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cWinControlEx.pkg)
75785>>>>>>>>>Use cWinControl.pkg
75785>>>>>>>>>// This adds proper navigation and default button support for
75785>>>>>>>>>// external classes
75785>>>>>>>>>
75785>>>>>>>>>Class cWinControlEx is a cWinControl
75786>>>>>>>>>    Import_Class_Protocol Standard_Form_Mixin
75787>>>>>>>>>    Procedure Construct_Object
75789>>>>>>>>>        Forward Send Construct_Object
75791>>>>>>>>>        Send define_standard_Form_Mixin
75792>>>>>>>>>    End_Procedure
75793>>>>>>>>>    
75793>>>>>>>>>    Function item_count Integer iItem Returns Integer
75795>>>>>>>>>        Function_Return 1
75796>>>>>>>>>    End_Function
75797>>>>>>>>>    
75797>>>>>>>>>    Procedure External_SetFocus
75799>>>>>>>>>        Send notify_focus_change 1
75800>>>>>>>>>    End_Procedure
75801>>>>>>>>>
75801>>>>>>>>>    Procedure External_KillFocus
75803>>>>>>>>>        Send notify_focus_change 0
75804>>>>>>>>>    End_Procedure
75805>>>>>>>>>
75805>>>>>>>>>    Procedure End_Construct_Object
75807>>>>>>>>>        Forward Send End_Construct_Object
75809>>>>>>>>>        Set External_Message WM_SETFOCUS  to External_SetFocus
75810>>>>>>>>>        Set External_Message WM_KILLFOCUS to External_KillFocus
75811>>>>>>>>>    End_Procedure
75812>>>>>>>>>        
75812>>>>>>>>>End_Class
75813>>>>>>>>>
75813>>>>>>>
75813>>>>>>>Class cMonthCalendar is a cWinControlEx
75814>>>>>>>    Procedure Construct_Object
75816>>>>>>>        Integer iResult
75816>>>>>>>        tWinInitCommonControlsEX InitCC
75816>>>>>>>        tWinInitCommonControlsEX InitCC
75816>>>>>>>
75816>>>>>>>        Forward Send Construct_Object
75818>>>>>>>
75818>>>>>>>        Move (SizeOfType (tWinInitCommonControlsEX)) to InitCC.dwSize
75819>>>>>>>        Move ICC_DATE_CLASSES to InitCC.dwICC
75820>>>>>>>        Move (InitCommonControlsEx(AddressOf(InitCC))) to iResult
75821>>>>>>>        
75821>>>>>>>        Set External_Class_Name 'cMonthCalendar' to 'SysMonthCal32'
75822>>>>>>>        Set External_Message WM_LBUTTONDBLCLK to msg_OnLButtonDblClick
75823>>>>>>>        
75823>>>>>>>        Set Border_Style to Border_Normal
75824>>>>>>>        
75824>>>>>>>        Property Boolean pbNoToday False
75825>>>>>>>        Property Boolean pbNoTodayCircle False
75826>>>>>>>        Property Boolean pbMultiSelect False
75827>>>>>>>        Property Boolean pbWeekNumbers False
75828>>>>>>>        Property Integer piMaxSelectedCount 90
75829>>>>>>>        
75829>>>>>>>        // this is minimum Dialog units required for a single picker rectangle
75829>>>>>>>        Property Integer piMinWidth 0
75830>>>>>>>        Property Integer piMinHeight 0
75831>>>>>>>
75831>>>>>>>        // stores initial date before control is activated
75831>>>>>>>        Property Date pdPrivateDate 
75832>>>>>>>        // if multi-select, this is the end range
75832>>>>>>>        Property Date pdPrivateDate2 
75833>>>>>>>        
75833>>>>>>>    End_Procedure
75834>>>>>>>    
75834>>>>>>>    // returns control's value when single select
75834>>>>>>>    Function SelectedDate Returns Date
75836>>>>>>>        tWinSystemTime CurrentSystemTime
75836>>>>>>>        tWinSystemTime CurrentSystemTime
75836>>>>>>>        Integer iRetval
75836>>>>>>>        DateTime dtSel
75836>>>>>>>        Handle hWnd
75836>>>>>>>        Get Window_Handle to hWnd
75837>>>>>>>        If (hWnd) Begin
75839>>>>>>>            Move (Windows_Message (MCM_GETCURSEL, 0, AddressOf (CurrentSystemTime))) to iRetval
75840>>>>>>>            Move (DateSetDay(dtSel,CurrentSystemTime.wDay)) to dtSel
75841>>>>>>>            Move (DateSetMonth(dtSel,CurrentSystemTime.wMonth)) to dtSel
75842>>>>>>>            Move (DateSetYear(dtSel,CurrentSystemTime.wYear)) to dtSel
75843>>>>>>>        End
75843>>>>>>>>
75843>>>>>>>        Else Begin
75844>>>>>>>            Get pdPrivateDate to dtSel
75845>>>>>>>        End
75845>>>>>>>>
75845>>>>>>>        Function_Return (Date(dtSel))
75846>>>>>>>    End_Function
75847>>>>>>>
75847>>>>>>>    // returns control's values when multi select
75847>>>>>>>    Function SelectedDateRange Returns Date[]
75849>>>>>>>        tWinSystemTime[2] CurrentSystemTime
75849>>>>>>>        tWinSystemTime[2] CurrentSystemTime
75850>>>>>>>        Integer iRetval
75850>>>>>>>        DateTime dtSel1 dtsel2
75850>>>>>>>        Date[] dtSel
75851>>>>>>>        Handle hWnd
75851>>>>>>>        Get Window_Handle to hWnd
75852>>>>>>>        If (hWnd) Begin
75854>>>>>>>            Move (Windows_Message (MCM_GETSELRANGE, 0, AddressOf (CurrentSystemTime))) to iRetval
75855>>>>>>>            
75855>>>>>>>            Move (DateSetDay(dtSel1,CurrentSystemTime[0].wDay)) to dtSel1
75856>>>>>>>            Move (DateSetMonth(dtSel1,CurrentSystemTime[0].wMonth)) to dtSel1
75857>>>>>>>            Move (DateSetYear(dtSel1,CurrentSystemTime[0].wYear)) to dtSel1
75858>>>>>>>            
75858>>>>>>>            Move (DateSetDay(dtSel2,CurrentSystemTime[1].wDay)) to dtSel2
75859>>>>>>>            Move (DateSetMonth(dtSel2,CurrentSystemTime[1].wMonth)) to dtSel2
75860>>>>>>>            Move (DateSetYear(dtSel2,CurrentSystemTime[1].wYear)) to dtSel2
75861>>>>>>>            
75861>>>>>>>            Move dtSel1 to dtSel[0]
75862>>>>>>>            Move dtsel2 to dtSel[1]
75863>>>>>>>        End
75863>>>>>>>>
75863>>>>>>>        Else Begin
75864>>>>>>>            Get pdPrivateDate to dtSel[0]
75865>>>>>>>            Get pdPrivateDate2 to dtSel[1]
75866>>>>>>>        End
75866>>>>>>>>
75866>>>>>>>        Function_Return dtSel
75867>>>>>>>    End_Function
75868>>>>>>>
75868>>>>>>>    // Set control's value when single select
75868>>>>>>>    Procedure SetSelectedDate Date dDate
75870>>>>>>>        tWinSystemTime CurrentSystemTime
75870>>>>>>>        tWinSystemTime CurrentSystemTime
75870>>>>>>>        Integer iRetval
75870>>>>>>>        Handle hWnd
75870>>>>>>>        
75870>>>>>>>        Get Window_Handle to hWnd
75871>>>>>>>        Set pdPrivateDate to dDate
75872>>>>>>>        If (hWnd) Begin
75874>>>>>>>            Move (DateGetDay(dDate)) to CurrentSystemTime.wDay
75875>>>>>>>            Move (DateGetMonth(dDate)) to CurrentSystemTime.wMonth
75876>>>>>>>            Move (DateGetYear(dDate)) to CurrentSystemTime.wYear
75877>>>>>>>    
75877>>>>>>>           Move (Windows_Message (MCM_SETCURSEL, 0, AddressOf (CurrentSystemTime))) to iRetval        
75878>>>>>>>        End
75878>>>>>>>>
75878>>>>>>>    End_Procedure
75879>>>>>>>
75879>>>>>>>    // Set control's values when multi select
75879>>>>>>>    Procedure SetSelectedDateRange Date dDate Date dDate2
75881>>>>>>>        tWinSystemTime[] CurrentSystemTime
75881>>>>>>>        tWinSystemTime[] CurrentSystemTime
75882>>>>>>>        Integer iRetval
75882>>>>>>>        Handle hWnd
75882>>>>>>>
75882>>>>>>>        Get Window_Handle to hWnd
75883>>>>>>>        Set pdPrivateDate to dDate
75884>>>>>>>        Set pdPrivateDate2 to dDate2
75885>>>>>>>        If (hWnd) Begin
75887>>>>>>>            Move (DateGetDay(dDate)) to CurrentSystemTime[0].wDay
75888>>>>>>>            Move (DateGetMonth(dDate)) to CurrentSystemTime[0].wMonth
75889>>>>>>>            Move (DateGetYear(dDate)) to CurrentSystemTime[0].wYear
75890>>>>>>>
75890>>>>>>>            Move (DateGetDay(dDate2)) to CurrentSystemTime[1].wDay
75891>>>>>>>            Move (DateGetMonth(dDate2)) to CurrentSystemTime[1].wMonth
75892>>>>>>>            Move (DateGetYear(dDate2)) to CurrentSystemTime[1].wYear
75893>>>>>>>    
75893>>>>>>>            Move (Windows_Message (MCM_SETSELRANGE, 0, AddressOf (CurrentSystemTime))) to iRetval        
75894>>>>>>>        End
75894>>>>>>>>
75894>>>>>>>    End_Procedure
75895>>>>>>>    
75895>>>>>>>    // augment to set dates from control, so they can be accessed after the control is closed
75895>>>>>>>    Procedure Remove_Object
75897>>>>>>>        Date[] SelDate 
75898>>>>>>>        If (pbMultiSelect(Self)) Begin
75900>>>>>>>            Get SelectedDateRange to SelDate
75901>>>>>>>            Set pdPrivateDate2 to SelDate[1]
75902>>>>>>>        End
75902>>>>>>>>
75902>>>>>>>        Else Begin
75903>>>>>>>            Get SelectedDate to SelDate[0]
75904>>>>>>>        End
75904>>>>>>>>
75904>>>>>>>        Set pdPrivateDate to SelDate[0]
75905>>>>>>>        Forward Send Remove_Object
75907>>>>>>>    End_Procedure
75908>>>>>>>
75908>>>>>>>    Procedure Page Integer iState
75910>>>>>>>        Integer iRetval iSize iHeight iWidth
75910>>>>>>>        tWinRect WindowRect
75910>>>>>>>        tWinRect WindowRect
75910>>>>>>>        Date dDate dDate2
75910>>>>>>>        Handle hWnd
75910>>>>>>>        Integer  iMaxSelectedCount
75910>>>>>>>        Boolean bNoToday bWeekNumbers bMultiSelect bNoTodayCircle
75910>>>>>>>        
75910>>>>>>>        If (iState<>1) Begin
75912>>>>>>>            Forward Send Page iState
75914>>>>>>>            Procedure_Return
75915>>>>>>>        End
75915>>>>>>>>
75915>>>>>>>        
75915>>>>>>>        Set Icon to 'ActionCalendar.ico'
75916>>>>>>>
75916>>>>>>>        Get pbNoToday to bNoToday
75917>>>>>>>        Get pbNoTodayCircle to bNoTodayCircle
75918>>>>>>>        Get pbMultiSelect to bMultiSelect
75919>>>>>>>        Get pbWeekNumbers to bWeekNumbers
75920>>>>>>>        Get piMaxSelectedCount to iMaxSelectedCount
75921>>>>>>>
75921>>>>>>>        Set Window_Style MCS_MULTISELECT to bMultiSelect
75922>>>>>>>        Set Window_Style MCS_NOTODAY to bNoToday
75923>>>>>>>        Set Window_Style MCS_NOTODAYCIRCLE to bNoTodayCircle
75924>>>>>>>        Set Window_Style MCS_WEEKNUMBERS to bWeekNumbers
75925>>>>>>>        Forward Send Page iState
75927>>>>>>>
75927>>>>>>>        Get Window_Handle to hWnd
75928>>>>>>>        // support double click
75928>>>>>>>        Move (SetClassLong(hWnd,GCL_STYLE,CS_DBLCLKS ior CS_GLOBALCLASS)) to iRetval
75929>>>>>>>        // set range when multi select
75929>>>>>>>        Move (Windows_Message(MCM_SETMAXSELCOUNT,iMaxSelectedCount,0)) to iRetval
75930>>>>>>>        
75930>>>>>>>        // store minimum size for calendar control and set the size to this by default
75930>>>>>>>        Move (Windows_Message (MCM_GETMINREQRECT, 0, AddressOf(WindowRect))) to iRetval
75931>>>>>>>        Get GuiToDialog WindowRect.bottom WindowRect.right to iSize
75932>>>>>>>        Move (Hi(iSize)) to iHeight
75933>>>>>>>        Move (Low(iSize)) to iWidth
75934>>>>>>>        Set piMinWidth to iWidth
75935>>>>>>>        Set piMinHeight to iHeight
75936>>>>>>>        Set Size to iHeight iWidth
75937>>>>>>>        
75937>>>>>>>        // now that we are activated set starting date or date range
75937>>>>>>>        Get pdPrivateDate to dDate
75938>>>>>>>        If (pbMultiSelect(Self)) Begin
75940>>>>>>>            Get pdPrivateDate2 to dDate2
75941>>>>>>>            Send SetSelectedDateRange dDate dDate2
75942>>>>>>>        End
75942>>>>>>>>
75942>>>>>>>        Else Begin
75943>>>>>>>            Send SetSelectedDate dDate
75944>>>>>>>        End
75944>>>>>>>>
75944>>>>>>>    End_Procedure
75945>>>>>>>
75945>>>>>>>    Procedure Notify Integer wParam Integer lParam
75947>>>>>>>        Integer iRetval
75947>>>>>>>        DateTime dtSel dtSel2
75947>>>>>>>        tWintagNMSelChange CalenderInfo
75947>>>>>>>        tWintagNMSelChange CalenderInfo
75947>>>>>>>        Boolean bMulti
75947>>>>>>>        
75947>>>>>>>        Move (MemCopy (AddressOf (CalenderInfo), lParam, SizeOfType (tWintagNMSelChange))) to iRetval
75948>>>>>>>        If (CalenderInfo.nmHdr.code = MCN_SELCHANGE) Begin
75950>>>>>>>            Get pbMultiSelect to bMulti
75951>>>>>>>            Move (DateSetDay(dtSel,CalenderInfo.stSelStart.wDay)) to dtSel
75952>>>>>>>            Move (DateSetMonth(dtSel,CalenderInfo.stSelStart.wMonth)) to dtSel
75953>>>>>>>            Move (DateSetYear(dtSel,CalenderInfo.stSelStart.wYear)) to dtSel
75954>>>>>>>            If bMulti Begin
75956>>>>>>>                Move (DateSetDay(dtSel,CalenderInfo.stSelEnd.wDay)) to dtSel2
75957>>>>>>>                Move (DateSetMonth(dtSel,CalenderInfo.stSelEnd.wMonth)) to dtSel2
75958>>>>>>>                Move (DateSetYear(dtSel,CalenderInfo.stSelEnd.wYear)) to dtSel2
75959>>>>>>>            End
75959>>>>>>>>
75959>>>>>>>            Send OnChange (Date(dtSel)) (Date(dtSel2))
75960>>>>>>>        End
75960>>>>>>>>
75960>>>>>>>    End_Procedure
75961>>>>>>>
75961>>>>>>>    // sent whenever there is a selection change within the calendar
75961>>>>>>>    Procedure OnChangeDate Date dDate Date dDate2
75963>>>>>>>    End_Procedure
75964>>>>>>>
75964>>>>>>>    // sent when a click occurs in the calendar 
75964>>>>>>>    Procedure OnClick
75966>>>>>>>    End_Procedure
75967>>>>>>>    
75967>>>>>>>    // sent when a double click occurs in the calendar 
75967>>>>>>>    Procedure OnDoubleClick
75969>>>>>>>    End_Procedure
75970>>>>>>>    
75970>>>>>>>    // sends OnClick if the double click is on a calendar day
75970>>>>>>>    Procedure OnLButtonDblClick Integer wParam Integer lParam
75972>>>>>>>        Boolean bDayHit
75972>>>>>>>        Get MonthDayHit to bDayHit
75973>>>>>>>        If bDayHit Begin
75975>>>>>>>            Send OnDoubleClick
75976>>>>>>>        End
75976>>>>>>>>
75976>>>>>>>    End_Procedure
75977>>>>>>>
75977>>>>>>>    // sends OnClick if the click is on a calendar day
75977>>>>>>>    Procedure OnWmLButtonUp Integer wParam Integer lParam
75979>>>>>>>        Boolean bDayHit
75979>>>>>>>        Get MonthDayHit to bDayHit
75980>>>>>>>        If bDayHit Begin
75982>>>>>>>            Send OnClick
75983>>>>>>>        End
75983>>>>>>>>
75983>>>>>>>    End_Procedure
75984>>>>>>>    
75984>>>>>>>    // returns true if the month calander is up and the mouse is over a day
75984>>>>>>>    Function MonthDayHit Returns Boolean
75986>>>>>>>        Integer iRet
75986>>>>>>>        Get Windows_Message MCM_GETCURRENTVIEW 0 0 to iRet
75987>>>>>>>        If (iRet=MCMV_MONTH) Begin
75989>>>>>>>            Get HitTest to iRet
75990>>>>>>>            Function_Return (iRet=MCHT_CALENDARDATE)
75991>>>>>>>        End
75991>>>>>>>>
75991>>>>>>>        Function_Return False
75992>>>>>>>    End_Function
75993>>>>>>>    
75993>>>>>>>    // return what was hit in the control
75993>>>>>>>    Function HitTest Returns Integer
75995>>>>>>>        tWinMCHitTestInfo HitInfo
75995>>>>>>>        tWinMCHitTestInfo HitInfo
75995>>>>>>>        Handle hWnd iRet
75995>>>>>>>        Integer iVoid
75995>>>>>>>        Pointer lpPt
75995>>>>>>>        tWinPoint Pt
75995>>>>>>>        tWinPoint Pt
75995>>>>>>>        Get Window_Handle to hWnd
75996>>>>>>>        Move (AddressOf(Pt)) to lpPt
75997>>>>>>>        Move (GetCursorPos(lpPt)) to iVoid
75998>>>>>>>        Move (ScreenToClient(hWnd, lpPt)) to iVoid
75999>>>>>>>        Move Pt to HitInfo.Pt
76000>>>>>>>        Move (SizeOfType(tWinMCHitTestInfo)) to HitInfo.cbSize
76001>>>>>>>        Get WindowsMessage MCM_HITTEST 0 (AddressOf(HitInfo)) to iRet
76002>>>>>>>        Function_Return HitInfo.uHit
76003>>>>>>>    End_Function
76004>>>>>>>    
76004>>>>>>>End_Class
76005>>>>>
76005>>>>>// peMouseSelectOk choices
76005>>>>>Enum_List
76005>>>>>    Define msoClick
76005>>>>>    Define msoDblClick
76005>>>>>    Define msoNone
76005>>>>>End_Enum_List
76005>>>>>
76005>>>>>// It is expected that this class will only be used inside of ModalPanel and
76005>>>>>// will be used as a prompt object component in a framework style application.
76005>>>>>// If you wish to Use a month calendar in some other non prompt situation, 
76005>>>>>// use cMonthCalendar
76005>>>>>
76005>>>>>Class cMonthCalendarPrompt is a cMonthCalendar
76006>>>>>
76006>>>>>    Procedure Construct_Object
76008>>>>>
76008>>>>>        Forward Send Construct_Object
76010>>>>>
76010>>>>>        Property Integer peUpdateMode umPromptValue
76011>>>>>
76011>>>>>        Property Integer peMouseSelectOk msoClick
76012>>>>>        
76012>>>>>        Property Date pdSeedValue
76013>>>>>
76013>>>>>        // if multi-select, this is the end range
76013>>>>>        Property Date pdSeedValue2
76014>>>>>
76014>>>>>        Property Handle phmPromptUpdateCallback 0
76015>>>>>
76015>>>>>        Property Integer phoInvokingObject
76016>>>>>        
76016>>>>>        Property Integer peStoredUpdateMode
76017>>>>>        Property Handle  phmStoredPromptUpdateCallback
76018>>>>>        Property Boolean pbStoredWeekNumbers
76019>>>>>        Property Boolean pbStoredNoToday
76020>>>>>        Property Boolean pbStoredNoTodayCircle
76021>>>>>        Property Boolean pbStoredMultiSelect
76022>>>>>        Property Integer piStoredMaxSelectedCount
76023>>>>>        Property Integer peStoredpeMouseSelectOk
76024>>>>>
76024>>>>>        // internally set by list
76024>>>>>        // these must be set upon closing the list and can be used for manual list updates
76024>>>>>        Property Boolean pbCanceled
76025>>>>>
76025>>>>>    End_Procedure
76026>>>>>        
76026>>>>>    Procedure OnStoreDefaults
76028>>>>>        Integer iVal
76028>>>>>        Boolean bVal
76028>>>>>
76028>>>>>        Get peUpdateMode to iVal
76029>>>>>        Set peStoredUpdateMode to iVal
76030>>>>>        
76030>>>>>        Get phmPromptUpdateCallback to iVal       
76031>>>>>        Set phmStoredPromptUpdateCallback to iVal       
76032>>>>>
76032>>>>>        Get pbMultiSelect to bVal       
76033>>>>>        Set pbStoredMultiSelect to bVal       
76034>>>>>
76034>>>>>        Get pbNoToday to bVal       
76035>>>>>        Set pbStoredNoToday to bVal       
76036>>>>>
76036>>>>>        Get pbNoTodayCircle to bVal       
76037>>>>>        Set pbStoredNoTodayCircle to bVal       
76038>>>>>
76038>>>>>        Get pbWeekNumbers to bVal       
76039>>>>>        Set pbStoredWeekNumbers to bVal       
76040>>>>>
76040>>>>>        Get piMaxSelectedCount to iVal       
76041>>>>>        Set piStoredMaxSelectedCount to iVal  
76042>>>>>        
76042>>>>>        Get peMouseSelectOk to iVal       
76043>>>>>        Set peStoredpeMouseSelectOk to iVal       
76044>>>>>        
76044>>>>>    End_Procedure
76045>>>>>
76045>>>>>    Procedure OnRestoreDefaults
76047>>>>>        Integer iVal
76047>>>>>        Boolean bVal
76047>>>>>
76047>>>>>        Get peStoredUpdateMode to iVal
76048>>>>>        Set peUpdateMode to iVal
76049>>>>>        
76049>>>>>        Get phmStoredPromptUpdateCallback to iVal       
76050>>>>>        Set phmPromptUpdateCallback to iVal       
76051>>>>>
76051>>>>>        Get pbStoredMultiSelect to bVal       
76052>>>>>        Set pbMultiSelect to bVal       
76053>>>>>
76053>>>>>        Get pbStoredNoToday to bVal       
76054>>>>>        Set pbNoToday to bVal       
76055>>>>>
76055>>>>>        Get pbStoredNoTodayCircle to bVal       
76056>>>>>        Set pbNoTodayCircle to bVal       
76057>>>>>
76057>>>>>        Get pbStoredWeekNumbers to bVal       
76058>>>>>        Set pbWeekNumbers to bVal       
76059>>>>>
76059>>>>>        Get piStoredMaxSelectedCount to iVal       
76060>>>>>        Set piMaxSelectedCount to iVal       
76061>>>>>
76061>>>>>        Get peStoredpeMouseSelectOk to iVal       
76062>>>>>        Set peMouseSelectOk to iVal       
76063>>>>>
76063>>>>>    End_Procedure
76064>>>>>
76064>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
76066>>>>>        Integer eMode
76066>>>>>        Set pbCanceled to True // assume cancel unless changed
76067>>>>>        Get peUpdateMode to eMode
76068>>>>>        If (eMode<>umPromptNonInvoking) Begin
76070>>>>>            Send OnStoreDefaults
76071>>>>>        End
76071>>>>>>
76071>>>>>        Send InitializePrompt
76072>>>>>        Forward Send Add_Focus hoParent
76074>>>>>    End_Procedure
76075>>>>>        
76075>>>>>    // augment to send OnRestoreDefaults.
76075>>>>>    Procedure Release_Focus
76077>>>>>        Integer eUpdateMode
76077>>>>>        Get peUpdateMode to eUpdateMode
76078>>>>>        Forward Send Release_Focus
76080>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
76082>>>>>            Send OnRestoreDefaults
76083>>>>>        End
76083>>>>>>
76083>>>>>    End_Procedure
76084>>>>>
76084>>>>>    // This is only called in a successful close
76084>>>>>    Procedure ClosePrompt
76086>>>>>        Handle hoInvokingObject
76086>>>>>        Handle hmCallBack
76086>>>>>        Integer eUpdateMode
76086>>>>>        Date[] dDates
76087>>>>>        
76087>>>>>        Set pbCanceled to False
76088>>>>>        
76088>>>>>        Get peUpdateMode to eUpdateMode
76089>>>>>        // if non-invoking there is by definition, no move value out
76089>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
76091>>>>>            
76091>>>>>            If (eUpdateMode=umPromptValue) Begin
76093>>>>>                Send OnMoveValueOutByValue
76094>>>>>            End
76094>>>>>>
76094>>>>>            Else If (eUpdateMode=umPromptCustom) Begin
76097>>>>>                Send OnMoveValueOutByCustom
76098>>>>>            End
76098>>>>>>
76098>>>>>            Get phmPromptUpdateCallback to hmCallBack
76099>>>>>            If hmCallBack Begin
76101>>>>>                Get phoInvokingObject to hoInvokingObject
76102>>>>>                If (pbMultiSelect(Self)) Begin
76104>>>>>                    Get SelectedDateRange to dDates
76105>>>>>                    Send hmCallBack of hoInvokingObject Self dDates[0] dDates[1]
76106>>>>>                    
76106>>>>>                End
76106>>>>>>
76106>>>>>                Else Begin
76107>>>>>                    Get SelectedDate to dDates[0]
76108>>>>>                    Send hmCallBack of hoInvokingObject Self dDates[0]
76109>>>>>                End
76109>>>>>>
76109>>>>>            End
76109>>>>>>
76109>>>>>        End
76109>>>>>>
76109>>>>>
76109>>>>>        Send Close_Panel
76110>>>>>    End_Procedure
76111>>>>>
76111>>>>>    Procedure OnMoveValueOutByValue
76113>>>>>        Handle hoInvokingObject
76113>>>>>        Date dSelDate
76113>>>>>        Boolean bMulti
76113>>>>>        // we can only do an automatic move value out with
76113>>>>>        // single select. If multi-select you will probably want to
76113>>>>>        // use a callback method (hmCallBack) to update the values. 
76113>>>>>        Get pbMultiSelect to bMulti
76114>>>>>        If (not(bMulti)) Begin
76116>>>>>            Get SelectedDate to dSelDate
76117>>>>>            Get phoInvokingObject to hoInvokingObject
76118>>>>>            Set Value of hoInvokingObject to dSelDate
76119>>>>>            Set Item_Changed_State of hoInvokingObject to True
76120>>>>>        End
76120>>>>>>
76120>>>>>    End_Procedure
76121>>>>>
76121>>>>>    Procedure OnMoveValueOutByCustom
76123>>>>>    End_Procedure
76124>>>>>        
76124>>>>>    // called before the list is activated. 
76124>>>>>    Procedure InitializePrompt
76126>>>>>        Handle hoInvokingObject
76126>>>>>        Integer eUpdateMode
76126>>>>>        Boolean bMulti 
76126>>>>>        Date dValue
76126>>>>>
76126>>>>>        Get peUpdateMode to eUpdateMode
76127>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
76129>>>>>
76129>>>>>            Get Focus of Desktop to hoInvokingObject
76130>>>>>            If (hoInvokingObject<=Desktop) Begin
76132>>>>>                Error DFERR_PROGRAM "Calendar Prompt has no invoking object"
76133>>>>>>
76133>>>>>                Procedure_Return
76134>>>>>            End
76134>>>>>>
76134>>>>>
76134>>>>>            Set phoInvokingObject to hoInvokingObject
76135>>>>>            Send Prompt_Callback to hoInvokingObject Self
76136>>>>>            Get peUpdateMode to eUpdateMode
76137>>>>>        End
76137>>>>>>
76137>>>>>
76137>>>>>        Get pdSeedValue to dValue
76138>>>>>        Get pbMultiSelect to bMulti
76139>>>>>        If (not(bMulti) and eUpdateMode=umPromptValue and dValue=0) Begin
76141>>>>>            Get Value of hoInvokingObject to dValue
76142>>>>>            Set pdSeedValue to dValue
76143>>>>>        End
76143>>>>>>
76143>>>>>        Send OnSeedData
76144>>>>>        Set pdSeedValue to 0
76145>>>>>        Set pdSeedValue2 to 0
76146>>>>>    End_Procedure
76147>>>>>    
76147>>>>>    Procedure OnSeedData 
76149>>>>>        Boolean bMulti
76149>>>>>        Date dValue dValue2
76149>>>>>        Integer iMax iRange
76149>>>>>        DateTime dt1 dt2
76149>>>>>        Get pbMultiSelect to bMulti
76150>>>>>        Get pdSeedValue to dValue
76151>>>>>        If (not(bMulti)) Begin
76153>>>>>            // if no date, use current date
76153>>>>>            If (dValue=0) Begin
76155>>>>>                Move (CurrentDateTime()) to dValue
76156>>>>>            End
76156>>>>>>
76156>>>>>            Send SetSelectedDate dValue    
76157>>>>>        End
76157>>>>>>
76157>>>>>        Else Begin
76158>>>>>            Get pdSeedValue2 to dValue2 
76159>>>>>            // if no dates, use current date
76159>>>>>            If (dValue=0 and dValue2=0) Begin
76161>>>>>                Move (CurrentDateTime()) to dValue
76162>>>>>            End
76162>>>>>>
76162>>>>>            // if only one date, make that the range
76162>>>>>            If (dValue=0) Begin
76164>>>>>                Move dValue2 to dValue
76165>>>>>            End
76165>>>>>>
76165>>>>>            Else If (dValue2=0) Begin
76168>>>>>                Move dValue to dValue2
76169>>>>>            End
76169>>>>>>
76169>>>>>            
76169>>>>>            // test for valid range
76169>>>>>            Get piMaxSelectedCount to iMax
76170>>>>>            Move dValue to dt1
76171>>>>>            Move dValue2 to dt2
76172>>>>>            Move (SpanTotalDays(dt1 - dt2)) to iRange
76173>>>>>            If (iRange>iMax) Begin
76175>>>>>                Error DFERR_OPERATOR (SFormat(C_$DateRangeExceeded,iMax))
76176>>>>>>
76176>>>>>                Move dValue to dValue2
76177>>>>>            End
76177>>>>>>
76177>>>>>            
76177>>>>>            Send SetSelectedDateRange dValue dValue2
76178>>>>>        End
76178>>>>>>
76178>>>>>    End_Procedure
76179>>>>>
76179>>>>>    Procedure OnDoubleClick
76181>>>>>        Integer eSelectOn
76181>>>>>        Get peMouseSelectOk to eSelectOn
76182>>>>>        If (eSelectOn=msoDblClick) Begin
76184>>>>>            Send Ok
76185>>>>>        End
76185>>>>>>
76185>>>>>    End_Procedure
76186>>>>>    
76186>>>>>    Procedure OnClick
76188>>>>>        Integer eSelectOn
76188>>>>>        Get peMouseSelectOk to eSelectOn
76189>>>>>        If (eSelectOn=msoClick) Begin
76191>>>>>            Send Ok
76192>>>>>        End
76192>>>>>>
76192>>>>>    End_Procedure
76193>>>>>
76193>>>>>    Procedure Ok Returns Integer
76195>>>>>        Send ClosePrompt
76196>>>>>    End_Procedure
76197>>>>>
76197>>>>>    Procedure Cancel Returns Integer
76199>>>>>        Send Close_Panel
76200>>>>>    End_Procedure
76201>>>>>        
76201>>>>>End_Class
76202>>>>>
76202>>>>>
76202>>>Use Dfclient.pkg
76202>>>
76202>>>Cd_Popup_Object oMonthCalendarPrompt is a ModalPanel
76220>>>>
76220>>>    Set Location to 10 10
76221>>>    Set Size to 145 145
76222>>>    // resizable
76222>>>    Set Border_Style to Border_Thick
76223>>>
76223>>>    Set Label to C_$DateSelector
76224>>>
76224>>>    Set piMinSize to 0 0 // set this dynamically // 145 145
76225>>>    Set piMaxSize to 310 460
76226>>>
76226>>>    // tells us if this been activated and sized yet
76226>>>    Property Boolean pbSizeInited False
76228>>>        
76228>>>    Object oCalendar is a cMonthCalendarPrompt
76230>>>        Set Size to 120 135 // not real size, will be assigned
76231>>>        Set Location to 5 5
76232>>>        Set Border_Style to Border_None
76233>>>    End_Object
76234>>>
76234>>>    Object oOKButton is a Button
76236>>>        Set Label to C_$OK
76237>>>        Set Default_State to True
76238>>>        Set Location to 129 34
76239>>>        Set peAnchors to anBottomRight
76240>>>        
76240>>>        Procedure OnClick
76243>>>            Send Ok of oCalendar
76244>>>        End_Procedure
76245>>>    End_Object
76246>>>
76246>>>    Object oCancelButton is a Button
76248>>>        Set Label to C_$Cancel
76249>>>        Set Location to 129 89
76250>>>        Set peAnchors to anBottomRight
76251>>>        
76251>>>        Procedure OnClick
76254>>>            Send Cancel of oCalendar
76255>>>        End_Procedure
76256>>>    End_Object
76257>>>
76257>>>    Procedure OnResize 
76260>>>        Integer iSize iHeight iWidth iMinSize
76260>>>        Boolean bInited
76260>>>
76260>>>        Get piMinHeight of oCalendar to iHeight
76261>>>        // when 0, the control has not yet been created. Nothing to do.
76261>>>        If (iHeight=0) Begin
76263>>>            Procedure_Return
76264>>>        End
76264>>>>
76264>>>
76264>>>        Get pbSizeInited to bInited
76265>>>        
76265>>>        Get piMinWidth of oCalendar to iWidth
76266>>>        Get piMinSize to iMinSize
76267>>>        // Minumum size of panel - add 1 to each to each for wiggle room
76267>>>        Move (iHeight+25+1) to iHeight
76268>>>        Move (iWidth+10+1) to iWidth
76269>>>         
76269>>>        Set piMinSize to iHeight iWidth
76270>>>
76270>>>        If (not(bInited))  Begin
76272>>>            Set Size to iHeight iWidth
76273>>>            Set pbSizeInited to True
76274>>>        End
76274>>>>
76274>>>        Else Begin
76275>>>            Send Adjust_Logicals
76276>>>            Get Size to iSize
76277>>>            If (Hi(iSize)<iHeight or Low(iSize)<iWidth) Begin
76279>>>                Set Size to (iHeight max Hi(iSize)) (iWidth max Low(iSize))
76280>>>                Get Size to iSize
76281>>>            End
76281>>>>
76281>>>            Set Size of oCalendar to (Hi(iSize) - 25) (Low(iSize) - 10)
76282>>>        End
76282>>>>
76282>>>        
76282>>>    End_Procedure
76283>>>    
76283>>>    Procedure Add_Focus Handle hoParent Returns Integer
76286>>>        Forward Send Add_Focus hoParent
76288>>>        Send OnResize
76289>>>    End_Procedure
76290>>>
76290>>>    On_Key kCancel Send KeyAction to oCancelButton
76291>>>
76291>>>Cd_End_Object
76293>>>>
76293>
76293>Object oHtmlHelp is a cHtmlHelp
76295>End_Object
76296>
76296>Object oApplication is a cApplication
76298>    Set peHelpType to htHtmlHelp
76299>End_Object
76300>
76300>Object oToolTipController is a cToolTipController
76302>    Move Self to ghoToolTipController
76303>End_Object
76304>
76304>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\oEditContextMenu.pkg)
76304>>>Use cCJStandardMenuItemClasses.pkg
76304>>>
76304>>>Object oEditContextMenu is a cCJContextMenu
76306>>>    
76306>>>    Move Self to Default_Form_Floating_Menu_ID
76307>>>    
76307>>>    Object oUndoMenuItem is a cCJUndoMenuItem
76309>>>    End_Object
76310>>>    
76310>>>    Object oCutMenuItem is a cCJCutMenuItem
76312>>>        Set pbControlBeginGroup to True
76313>>>    End_Object
76314>>>    
76314>>>    Object oCopyMenuItem is a cCJCopyMenuItem
76316>>>    End_Object
76317>>>
76317>>>    Object oPasteMenuItem is a cCJPasteMenuItem
76319>>>    End_Object
76320>>>
76320>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
76322>>>    End_Object
76323>>>
76323>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
76325>>>        Set pbControlBeginGroup to True
76326>>>    End_Object
76327>>>
76327>>>End_Object
76328>>>
76328>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\oDEOEditContextMenu17.pkg)
76328>>>Use Windows.pkg
76328>>>Use cCJStandardMenuItemClasses.pkg
76328>>>Use cCJDeoMenuItemClasses.pkg
76328>>>
76328>>>
76328>>>Object oDEOEditContextMenu17 is a cCJContextMenu
76330>>>    
76330>>>    Move Self to Default_dbFloating_Menu_ID
76331>>>    
76331>>>    Object oUndoMenuItem is a cCJUndoMenuItem
76333>>>    End_Object
76334>>>    
76334>>>    Object oCutMenuItem is a cCJCutMenuItem
76336>>>        Set pbControlBeginGroup to True
76337>>>    End_Object
76338>>>    
76338>>>    Object oCopyMenuItem is a cCJCopyMenuItem
76340>>>    End_Object
76341>>>
76341>>>    Object oPasteMenuItem is a cCJPasteMenuItem
76343>>>    End_Object
76344>>>
76344>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
76346>>>    End_Object
76347>>>
76347>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
76349>>>        Set pbControlBeginGroup to True
76350>>>    End_Object
76351>>>
76351>>>    Object oPromptMenuItem is a cCJPromptMenuItem
76353>>>        Set pbControlBeginGroup to True
76354>>>    End_Object
76355>>>
76355>>>    Object oFindNextMenu is a cCJFindNextMenuItem
76357>>>        Set pbControlBeginGroup to True
76358>>>    End_Object
76359>>>
76359>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
76361>>>    End_Object
76362>>>
76362>>>    Object oClearMenuItem is a cCJClearMenuItem
76364>>>        Set pbControlBeginGroup to True
76365>>>    End_Object
76366>>>
76366>>>    Object oClearAllMenu is a cCJClearAllMenuItem
76368>>>    End_Object
76369>>>
76369>>>    Object oSaveMenu is a cCJSaveMenuItem
76371>>>    End_Object
76372>>>    
76372>>>    Object oDeleteMenu is a cCJDeleteMenuItem
76374>>>    End_Object
76375>>>
76375>>>    Object oRememberitem is a cCJRememberFieldMenuItem
76377>>>        Set pbControlBeginGroup to True
76378>>>    End_Object
76379>>>
76379>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
76381>>>    End_Object
76382>>>
76382>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
76384>>>    End_Object
76385>>>
76385>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
76387>>>    End_Object
76388>>>
76388>>>End_Object
76389>
76389>Object oMain is a Panel
76391>    Set Label to "Mi Proyecto"
76392>    Set Location to 4 3
76393>    Set Size to 300 539
76394>
76394>    Object oCommandBarSystem is a cCJCommandBarSystem
76396>        Set pbTimerUpdate to True
76397>
76397>        Procedure OnCreateCommandBars
76400>            Handle hoOptions
76400>            Get OptionsObject to hoOptions
76401>            Forward Send OnCreateCommandBars
76403>        End_Procedure
76404>
76404>        Object oMenuBar is a cCJMenuBar
76406>
76406>            Object oFileMenu is a cCJMenuItem
76408>                Set peControlType to xtpControlPopup          
76409>                Set psCaption   to "Archivo"    // &F   <--------------------------
76410>                Set psDescription to "Buscar, Grabar, Borrar, limpiar informacin o salir de esta aplicacin."
76411>                Set psCategory to "Mens"
76412>
76412>                Object oClearMenuItem is a cCJClearMenuItem
76414>                    Set pbAddToDesignerMenu to True
76415>                End_Object
76416>
76416>                Object oClearAllMenu is a cCJClearAllMenuItem
76418>                    Set pbAddToDesignerMenu to True
76419>                End_Object
76420>
76420>                Object oPromptMenuItem is a cCJPromptMenuItem
76422>                    Set pbAddToDesignerMenu to True
76423>                    Set pbControlBeginGroup to True
76424>                End_Object
76425>
76425>                Object oFindMenuItem is a cCJFindMenuItem
76427>                    Set pbAddToDesignerMenu to True
76428>                    Set pbControlBeginGroup to True
76429>                End_Object
76430>
76430>                Object oFindNextMenu is a cCJFindNextMenuItem
76432>                    Set pbAddToDesignerMenu to True
76433>                End_Object
76434>
76434>                Object oFindPreviousMenu is a cCJFindPreviousMenuItem
76436>                    Set pbAddToDesignerMenu to True
76437>                End_Object
76438>
76438>                Object oFindFirstMenu is a cCJFindFirstMenuItem
76440>                    Set pbAddToDesignerMenu to True
76441>                End_Object
76442>
76442>                Object oFindLastMenu is a cCJFindLastMenuItem
76444>                    Set pbAddToDesignerMenu to True
76445>                End_Object
76446>
76446>                Object oSaveMenuItem is a cCJSaveMenuItem
76448>                    Set pbAddToDesignerMenu to True
76449>                    Set pbControlBeginGroup to True
76450>                End_Object
76451>
76451>                Object oDeleteMenuItem is a cCJDeleteMenuItem
76453>                    Set pbAddToDesignerMenu to True
76454>                End_Object
76455>
76455>                Object oExitMenu is a cCJExitMenuItem
76457>                    Set pbControlBeginGroup to True
76458>                End_Object
76459>
76459>            End_Object
76460>
76460>            Object oViewMenu is a cCJMenuItem
76462>                Set peControlType to xtpControlPopup
76463>                Set psCaption to "&Vistas"
76464>                Set psToolTip to "Vistas"
76465>               Set psDescription to "Vistas disponibles"
76466>
76466>               Object oRegistrodeEmpleadoMenuItem is a cCJMenuItem
76468>                   Set psCaption to "Registro de Empleado"
76469>                   Set psTooltip to "Registro de Empleado"
76470>               
76470>                   Procedure OnExecute Variant vCommandBarControl
76473>                       Handle hoClient
76473>                       Get Client_Id to hoClient
76474>                       Send Activate_RegistroEmpleado of hoClient
76475>                   End_Procedure
76476>               End_Object
76477>
76477>               Object oRegistrodeMarcajesMenuItem is a cCJMenuItem
76479>                   Set psCaption to "Registro de Marcajes"
76480>                   Set psTooltip to "Registro de Marcajes"
76481>               
76481>                   Procedure OnExecute Variant vCommandBarControl
76484>                       Handle hoClient
76484>                       Get Client_Id to hoClient
76485>                       Send Activate_RegistroMarcajes of hoClient
76486>                   End_Procedure
76487>               End_Object
76488>            End_Object
76489>            
76489>            Object oReportMenu is a cCJMenuItem
76491>                Set peControlType to xtpControlPopup
76492>                Set psCaption to "&Informes"
76493>                Set psToolTip to "Informes"
76494>                Set psDescription to "Informes disponibles"
76495>
76495>                Object oMarcajesMenuItem is a cCJMenuItem
76497>                    Set psCaption to "Marcajes"
76498>                    Set psTooltip to "Marcajes"
76499>                
76499>                    Procedure OnExecute Variant vCommandBarControl
76502>                        Handle hoClient
76502>                        Get Client_Id to hoClient
76503>                        Send Activate_Marcajes of hoClient
76504>                    End_Procedure
76505>                End_Object
76506>            End_Object
76507>
76507>            Object oNavigateMenu is a cCJMenuItem
76509>                Set peControlType to xtpControlPopup      
76510>                Set psCaption to "&Navegar"    
76511>                Set psTooltip to "Navegar"    
76512>                Set psDescription to "Desplazarse a diferentes areas de la aplicacin"
76513>
76513>                Object oNextAreaMenu is a cCJNextAreaMenu
76515>                End_Object
76516>
76516>                Object oPriorAreaMenu is a cCJPriorAreaMenu
76518>                End_Object
76519>
76519>                Object oNextViewMenu is a cCJNextViewMenu
76521>                End_Object
76522>
76522>                Object oPriorViewMenu is a cCJPriorViewMenu
76524>                End_Object
76525>
76525>                Object oPromptMenu is a cCJPromptMenuItem
76527>                    Set pbControlBeginGroup to True
76528>                End_Object
76529>
76529>                Object oZoomMenu is a cCJZoomMenuItem
76531>                End_Object
76532>
76532>            End_Object
76533>
76533>            Object oWindowMenu is a cCJMDIWindowsMenuItem
76535>                Set peControlType to xtpControlPopup
76536>                Set psCaption to "Ventana"      // &W <---------------
76537>                Set psToolTip to "Ventana"
76538>                Set psDescription to "Muestre vistas actuales y fije otras opciones de visualizacin."
76539>
76539>                // These are the static windows items. More will be created in onInitPopup 
76539>                Object oDisplayOptionsMenu is a cCJMenuItem
76541>                    Set peControlType to xtpControlPopup          
76542>                    Set psCaption to "Opciones de visualizacin"  // &D <--------------
76543>                    Set psToolTip to "Opciones de visualizacin"
76544>                    Set psDescription to "Fije opciones de visualizacin"
76545>
76545>                    Object oStatusbarMenu is a cCJStatusbarMenuItem
76547>                    End_Object
76548>
76548>                    Object oAutoArrangeIconsMenu is a cCJAutoArrangeIconsMenuItem
76550>                    End_Object
76551>
76551>                    Object oRestoreMenusMenu is a cCJRestoreMenusMenuItem
76553>                        Set pbControlBeginGroup to True
76554>                    End_Object
76555>
76555>                End_Object
76556>
76556>                Object oCascadeMenu is a cCJCascadeMenuItem
76558>                    Set pbControlBeginGroup to True
76559>                End_Object
76560>
76560>                Object oHorizTile is a cCJTileHorizontally
76562>                End_Object
76563>
76563>                Object oVertTile is a cCJTileVertically
76565>                End_Object
76566>
76566>                Object oMinimizeMenuItem is a cCJMinimizeWindowsMenuItem
76568>                    Set pbControlBeginGroup to True
76569>                End_Object
76570>
76570>                Object oRestoreMenuItem is a cCJRestoreWindowsMenuItem
76572>                End_Object
76573>
76573>                Object oArrangeIconsMenuItem is a cCJAutoArrangeIconsMenuItem
76575>                    Set pbControlBeginGroup to True
76576>                End_Object
76577>
76577>            End_Object
76578>
76578>            Object oHelpMenu is a cCJMenuItem
76580>                Set peControlType to xtpControlPopup    
76581>                Set psCaption to "&Ayuda"   // &H    <----------------------
76582>                Set psDescription to "Informacin para aprender y para usar esta aplicacin VDF"
76583>                Set psToolTip to "Ayuda"
76584>
76584>                Object oHelpMenuItem is a cCJHelpMenuItem 
76586>                End_Object
76587>
76587>                Object oAboutMenuItem is a cCJAboutMenuItem
76589>                End_Object
76590>
76590>            End_Object
76591>
76591>        End_Object
76592>
76592>        Object oFindToolBar is a cCJToolbar
76594>            Set psTitle to "Barra de herramientas de bsqueda"
76595>
76595>            Object oFindFirstTool is a cCJFindFirstMenuItem
76597>            End_Object
76598>
76598>            Object oFindPreviousTool is a cCJFindPreviousMenuItem
76600>            End_Object
76601>
76601>            Object oFindMenuTool is a cCJFindMenuItem
76603>            End_Object
76604>
76604>            Object oFindNextTool is a cCJFindNextMenuItem
76606>            End_Object
76607>
76607>            Object oFindLastTool is a cCJFindLastMenuItem
76609>            End_Object
76610>
76610>            Object oPromptToolItem is a cCJPromptMenuItem
76612>                Set pbControlBeginGroup to True
76613>            End_Object
76614>
76614>        End_Object
76615>
76615>        Object oFileToolBar is a cCJToolbar
76617>            Set psTitle to "Barra de herramientas de introduccin de datos"
76618>
76618>            Object oClearToolItem is a cCJClearMenuItem
76620>                Set peControlStyle to xtpButtonIconAndCaption
76621>            End_Object
76622>
76622>            Object oClearAllToolItem2 is a cCJClearAllMenuItem
76624>                Set peControlStyle to xtpButtonIconAndCaption
76625>            End_Object
76626>
76626>            Object oSaveToolItem is a cCJSaveMenuItem
76628>                Set peControlStyle to xtpButtonIconAndCaption
76629>                Set pbControlBeginGroup to True
76630>            End_Object
76631>
76631>            Object oDeleteToolItem is a cCJDeleteMenuItem
76633>                Set peControlStyle to xtpButtonIconAndCaption
76634>            End_Object
76635>
76635>        End_Object
76636>
76636>        Object oEditToolBar is a cCJToolbar
76638>            Set psTitle to "Barra de herramientas de edicin"
76639>
76639>            Object oCutToolbarItem is a cCJCutMenuItem
76641>            End_Object
76642>
76642>            Object oCopyToolbarItem is a cCJCopyMenuItem
76644>            End_Object
76645>
76645>            Object oPasteToolbarItem is a cCJPasteMenuItem
76647>            End_Object
76648>
76648>            Object oDeleteEditToolbarItem is a cCJDeleteEditMenuItem
76650>                Set pbControlBeginGroup to True
76651>            End_Object
76652>
76652>        End_Object
76653>
76653>        Object oRememberToolbar is a cCJToolbar
76655>            Set psTitle to C_$Remember
76656>
76656>            Object oRememberItems is a cCJMenuItem
76658>
76658>                Set peControlType to xtpControlPopup
76659>                Set peControlStyle to xtpButtonCaption
76660>                Set psCaption to C_$Remember
76661>                
76661>                Object oMenuItem is a cCJRememberFieldMenuItem
76663>                    Set peControlStyle to xtpButtonIconAndCaption
76664>                End_Object
76665>                
76665>                Object oMenuItem is a cCJRememberLastFieldMenuItem
76667>                    Set peControlStyle to xtpButtonIconAndCaption
76668>                End_Object
76669>                
76669>                Object oMenuItem is a cCJUnRememberFieldMenuItem
76671>                    Set peControlStyle to xtpButtonIconAndCaption
76672>                End_Object
76673>                
76673>                Object oMenuItem is a cCJUnRememberFieldAllMenuItem
76675>                    Set peControlStyle to xtpButtonIconAndCaption
76676>                End_Object
76677>
76677>            End_Object
76678>            
76678>        End_Object
76679>        
76679>        Object oStatusBar is a cCJStatusBar
76681>
76681>            Object oStatusPane1 is a cCJStatusBarPane
76683>                Set piID to sbpIDIdlePane
76684>                Set pbStyleStretch to True
76685>            End_Object
76686>
76686>            Object oStatusPane2 is a cCJStatusBarPane
76688>                Set phoViewPane to Self
76689>                Set pbStyleStretch to True
76690>            End_Object
76691>
76691>        End_Object
76692>
76692>    End_Object
76693>
76693>    Object oClientArea is a ClientArea
76695>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\StdAbout.pkg)
76695>>>//************************************************************************
76695>>>// Confidential Trade Secret.
76695>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
76695>>>// as an unpublished work.  All rights reserved.
76695>>>// DataFlex is a registered trademark of Data Access Corporation.
76695>>>//
76695>>>//************************************************************************
76695>>>//************************************************************************
76695>>>//
76695>>>// $File name  : StdAbout.pkg
76695>>>// $File title : Standard about object package for VDF
76695>>>// Notice      :
76695>>>// $Author(s)  : John Tuohy
76695>>>//
76695>>>// $Rev History
76695>>>//
76695>>>// JT 06/27/97   File created
76695>>>//************************************************************************
76695>>>
76695>>>// This provides a quick and simple way to create an about package for a program.
76695>>>// You need to create a message inside you client area called Activate_About.
76695>>>// Within this message you should send the message DoAbout passing needed
76695>>>// string information.
76695>>>//
76695>>>//       Procedure Activate_About
76695>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
76695>>>//       End_Procedure
76695>>>//    where: sTitle =     Name of application. If none provided, uses caption
76695>>>//                        bar title
76695>>>//           sVersion   = Version Line. If none provided, will be blank
76695>>>//           sCopyRight = Copyright Line. If none provided, will be blank
76695>>>//           sAuthor    = Author name, blank if none provided
76695>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
76695>>>//                        is used.
76695>>>// It is expected that you will place this in your own object package. For
76695>>>// example an order about package may look like this:
76695>>>//
76695>>>//   // OrderAbout.pkg
76695>>>//   Use StdAbout.pkg
76695>>>//   Procedure Activate_About
76695>>>//      String sTitle sCopyright sVersion sAuthor
76695>>>//      Move "My Order Entry System" to sTitle
76695>>>//      Move "Version 2.1" to sVersion
76695>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
76695>>>//      Move "John Smith"  to sAuthor
76695>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
76695>>>//   end_procedure
76695>>>//   // end of file.
76695>>>
76695>>>Use DfAbout.pkg
Including file: Dfabout.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\Dfabout.pkg)
76695>>>>>//************************************************************************
76695>>>>>// Confidential Trade Secret.
76695>>>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
76695>>>>>// as an unpublished work.  All rights reserved.
76695>>>>>// DataFlex Is A registered trademark Of Data Access Corporation.
76695>>>>>//
76695>>>>>//************************************************************************
76695>>>>>//************************************************************************
76695>>>>>//
76695>>>>>// $File name  : DfAbout.pkg
76695>>>>>// $File title : About class support
76695>>>>>// Notice      :
76695>>>>>// $Author(s)  : Vincent Oorsprong, Ken Ross
76695>>>>>//
76695>>>>>// $Rev History
76695>>>>>//
76695>>>>>// VOO 02/22/2012 Replaced obsolete code, improved Network_User_Name by asking
76695>>>>>//                Windows for the size first. 
76695>>>>>// VOO 07/25/2003 Removed OnResize procedure for sysinfo dialog. Replaced logic
76695>>>>>//                with anchor technique. Removed unnessary property in the
76695>>>>>//                sysinfo dialog. Changed the size Of the about & sysinfo dialog
76695>>>>>//                object To better look in Windows XP. Repositioned the close
76695>>>>>//                button in the sysinfo dialog To line up with the display area
76695>>>>>//                Replaced obsolete code and techniques. Removed dead code.
76695>>>>>// JJT 10/23/2001 removed all ghoworkspace support. Uses app object or nothing
76695>>>>>// SWB 07/19/01   Added support Of the Application object in preference to
76695>>>>>//                the global Workspace object, if it is present
76695>>>>>// JJT 11/05/98   Added version information
76695>>>>>// VOO 29/10/98   Replaced the GetFreeSystemResources for the Win32 variant
76695>>>>>// JJT 7/31/97    Registered Enumerate Workspace so dfabout can exist without
76695>>>>>//                workspace package.
76695>>>>>// JJT 6/27/97    Turned the sysinfo objects into classes so the AboutDialog
76695>>>>>//                class can create this object.
76695>>>>>//                Cleaned up the interface (used correct classes and messages)
76695>>>>>//                Added workspace reporting support To sys-info.
76695>>>>>//                Turned off wrapping in the sys-info editor.
76695>>>>>// KR  ??/??/96   File created
76695>>>>>//************************************************************************
76695>>>>>Use LanguageText.pkg
76695>>>>>Use Windows.pkg
76695>>>>>Use DFbitmap.pkg
76695>>>>>Use GlobalFunctionsProcedures.pkg
76695>>>>>Use cTextEdit.pkg
76695>>>>>
76695>>>>>Use cli.pkg
Including file: cli.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cli.pkg)
76695>>>>>>>//*****************************************************************************
76695>>>>>>>//*** CLI.PKG                                                               ***
76695>>>>>>>//***                                                                       ***
76695>>>>>>>//*** Author: Ben Weijers                                                   ***
76695>>>>>>>//***         Data Access Nederland                                         ***
76695>>>>>>>//***         10 September 1998                                             ***
76695>>>>>>>//***                                                                       ***
76695>>>>>>>//*** Purpose:                                                              ***
76695>>>>>>>//***   CLI specific functionality. There are several connectivity kits     ***
76695>>>>>>>//***   based on  SQL/92 CLI. Those are:                                    ***
76695>>>>>>>//***    - ODBC_DRV  The Data Access CK for ODBC                            ***
76695>>>>>>>//***    - DB2_DRV   The Data Access CK for DB2                             ***
76695>>>>>>>//***    - MSSQLDRV  The Data Access CK for Microsoft SQL Server            ***
76695>>>>>>>//***                                                                       ***
76695>>>>>>>//***   This package defines the common functionality for all CLI based     ***
76695>>>>>>>//***   drivers.                                                            ***
76695>>>>>>>//***                                                                       ***
76695>>>>>>>//***   Updated:  May 23rd 2008 (Current CK build: 5.0.0.53 )               ***
76695>>>>>>>//***             Added NULLABLE and DEFAULT attributes for DATETIME type   ***
76695>>>>>>>//***   Updated:  Apr  6th 2009 (Current CK build: 5.0.0.61 )               ***
76695>>>>>>>//***             Added DF_DRIVER_MATCH_CLIENT_SERVER_VERSION attribute     ***
76695>>>>>>>//***                   DF_DRIVER_SQLSERVER_CLIENT_VERSION    attribute     ***
76695>>>>>>>//***   Updated:  Mar 30th 2012 (Current CK build: 5.1.0.93 )               ***
76695>>>>>>>//***             Added SQLSERVER2012CLIENT return value for                ***
76695>>>>>>>//***             DF_DRIVER_SQLSERVER_CLIENT_VERSION attribute              ***
76695>>>>>>>//***   Updated:  June 4th 2012 (Current CK build: 5.1.0.96)                ***
76695>>>>>>>//***             Moved SQL Server client constants from cli.pkg to         ***
76695>>>>>>>//***             mssqldrv.pkg                                              ***
76695>>>>>>>//***   Updated:  april 23, 2013 (Current CK build: 6.0.0.4)                ***
76695>>>>>>>//***             Added type mappings attributes                            ***
76695>>>>>>>//***   Updated:  october 11, 2013 (Current CK build: 6.0.0.18)             ***
76695>>>>>>>//***             Added DF_FILE_SQL_FILTER_EQ attribute                     ***
76695>>>>>>>//*****************************************************************************
76695>>>>>>>
76695>>>>>>>//*** We are not using ifndef below because that is not supported in Character Mode
76695>>>>>>>//*** Driver attributes
76695>>>>>>>
76695>>>>>>>
76695>>>>>>>
76695>>>>>>>
76695>>>>>>>
76695>>>>>>>
76695>>>>>>>
76695>>>>>>>
76695>>>>>>>
76695>>>>>>>//------------------------------------------------------------
76695>>>>>>>
76695>>>>>>>
76695>>>>>>>//-------------------------------------
76695>>>>>>>
76695>>>>>>>
76695>>>>>>>
76695>>>>>>>//*** Replacement for logical column number that indicates all columns
76695>>>>>>>
76695>>>>>>>//*** Possible DF_FILE_GENERATE_RECORD_ID_METHOD values
76695>>>>>>>
76695>>>>>>>//*** Possible DF_FIELD_READ_ONLY values
76695>>>>>>>
76695>>>>>>>
76695>>>>>>>//*** Possible DF_DRIVER_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA values
76695>>>>>>>// #Replace MAP_DF_TO_SQL_TYPE_CK5        1       
76695>>>>>>>// #Replace MAP_DF_TO_SQL_TYPE_CK6        2   
76695>>>>>>>
76695>>>>>>>
76695>>>>>>>// Moved to Mssqldrv.pkg
76695>>>>>>>//*** Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
76695>>>>>>>//#REPLACE SQLSERVERUNKNOWNCLIENT  0
76695>>>>>>>//#REPLACE SQLSERVER2000CLIENT     8          //   "SQL Server"
76695>>>>>>>//#REPLACE SQLSERVER2005CLIENT     9          //   "SQL Native Client"
76695>>>>>>>//#REPLACE SQLSERVER2008CLIENT    10          //   "SQL Server Native Client 10.0"
76695>>>>>>>//#Replace SQLSERVER2012CLIENT    11          //   "SQL Server Native Client 11.0"
76695>>>>>>>
76695>>>>>>>//*** Possible SQL Column type values
76695>>>>>>>Define SQL_UNKNOWN_TYPE   For    0
76695>>>>>>>Define SQL_CHAR           For    1
76695>>>>>>>Define SQL_NUMERIC        For    2
76695>>>>>>>Define SQL_DECIMAL        For    3
76695>>>>>>>Define SQL_INTEGER        For    4
76695>>>>>>>Define SQL_SMALLINT       For    5
76695>>>>>>>Define SQL_FLOAT          For    6
76695>>>>>>>Define SQL_REAL           For    7
76695>>>>>>>Define SQL_DOUBLE         For    8
76695>>>>>>>Define SQL_DATETIME       For    9
76695>>>>>>>Define SQL_VARCHAR        For   12
76695>>>>>>>Define SQL_TYPE_DATE      For   91
76695>>>>>>>Define SQL_TYPE_TIME      For   92
76695>>>>>>>Define SQL_TYPE_TIMESTAMP for   93
76695>>>>>>>// Moved to mssqldrv.pkg
76695>>>>>>>//Define SQL_TYPE_TIMESTAMP2 for   (-200) //SQL server datetime2 type */
76695>>>>>>>
76695>>>>>>>
76695>>>>>>>Define SQL_DATE           For    9
76695>>>>>>>Define SQL_INTERVAL       For   10
76695>>>>>>>Define SQL_TIME           For   10
76695>>>>>>>Define SQL_TIMESTAMP      For   11
76695>>>>>>>Define SQL_LONGVARCHAR    For  (-1)
76695>>>>>>>Define SQL_BINARY         For  (-2)
76695>>>>>>>Define SQL_VARBINARY      For  (-3)
76695>>>>>>>Define SQL_LONGVARBINARY  For  (-4)
76695>>>>>>>Define SQL_BIGINT         For  (-5)
76695>>>>>>>Define SQL_TINYINT        For  (-6)
76695>>>>>>>Define SQL_BIT            For  (-7)
76695>>>>>>>Define SQL_WCHAR          For  (-8)
76695>>>>>>>Define SQL_WVARCHAR       For  (-9)
76695>>>>>>>Define SQL_WLONGVARCHAR   For (-10)
76695>>>>>>>Define SQL_GUID           For (-11)
76695>>>>>>>
76695>>>>>>>//*** Driver level attributes
76695>>>>>>>
76695>>>>>>>
76695>>>>>>>//*** Error number constants
76695>>>>>>>
76695>>>>>>>
76695>>>>>>>//*** Call driver function identifiers
76695>>>>>>>
76695>>>>>>>
76695>>>>>>>//*** Init data source types
76695>>>>>>>
76695>>>>>>>
76695>>>>>>>//*** Dummy strings used in the commands
76695>>>>>>>    String  CLI$StrDummy 255
76695>>>>>>>    Integer CLI$IntDummy
76695>>>>>>>
76695>>>>>>>
76695>>>>>>>//*****************************************************************************
76695>>>>>>>//*** CLI_SetConstraint <FileNum> <NewState>                                ***
76695>>>>>>>//***                                                                       ***
76695>>>>>>>//***   Setup a constraint for a file.                                      ***
76695>>>>>>>//*****************************************************************************
76695>>>>>>>
76695>>>>>>>
76695>>>>>>>
76695>>>>>>>
76695>>>>>>>//*****************************************************************************
76695>>>>>>>//*** CLI_Set_Driver_Atrtribute / CLI_Get_Driver_Attribute                  ***
76695>>>>>>>//***                                                                       ***
76695>>>>>>>//*** Set or get an attribute at driver level. These attributes, when set,  ***
76695>>>>>>>//*** will be set for the remainder of the session or until set again. To   ***
76695>>>>>>>//*** permanently set driver level attributes change the driver             ***
76695>>>>>>>//*** configuration file.                                                   ***
76695>>>>>>>//*****************************************************************************
76695>>>>>>>
76695>>>>>>>
76695>>>>>>>
76695>>>>>>>
76695>>>>>>>
76695>>>>>>>
76695>>>>>>>
76695>>>>>>>//*****************************************************************************
76695>>>>>>>//*** Class  : cCLIHandler                                                  ***
76695>>>>>>>//*** Purpose: An instance of this class can be used as a broker object to  ***
76695>>>>>>>//***          call several CLI releated methods.                           ***
76695>>>>>>>//*****************************************************************************
76695>>>>>>>
76695>>>>>>>Class cCLIHandler Is An Array
76696>>>>>>>
76696>>>>>>>    Procedure Construct_Object Integer iImage
76698>>>>>>>        Forward Send Construct_object iImage
76700>>>>>>>
76700>>>>>>>        Property String  psDriverID       Public ""
76701>>>>>>>    End_Procedure // Construct_Object
76702>>>>>>>
76702>>>>>>>
76702>>>>>>>
76702>>>>>>>    //***
76702>>>>>>>    //*** Fucntion: CKRevsion
76702>>>>>>>    //*** Purpose : The revsion of a CLI Connectivity Kit
76702>>>>>>>    //***
76702>>>>>>>
76702>>>>>>>    Function CKRevision Returns String
76704>>>>>>>        Local String  sDriverID
76704>>>>>>>        Local String  sRevision
76704>>>>>>>        Local String  sVoid
76704>>>>>>>        Local Integer iRetval
76704>>>>>>>
76704>>>>>>>        Get psDriverID To sDriverID
76705>>>>>>>        If (sDRiverID <> "") Begin
76707>>>>>>>            Move (Repeat(" ", 255)) To sRevision
76708>>>>>>>            Call_Driver 0 sDRiverID Function CLI_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
76713>>>>>>>        End
76713>>>>>>>>
76713>>>>>>>
76713>>>>>>>        Function_Return sRevision
76714>>>>>>>    End_Function // CKRevision
76715>>>>>>>
76715>>>>>>>
76715>>>>>>>
76715>>>>>>>    //***
76715>>>>>>>    //*** Function: ExtractPartFromRevision
76715>>>>>>>    //*** Purpose : Extarct the Nth part of a a.b.c.d revsion string.
76715>>>>>>>    //***
76715>>>>>>>    //*** Returns : The part version number or -1 if there is no such part number.
76715>>>>>>>    //***
76715>>>>>>>
76715>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
76717>>>>>>>        Local Integer iPartRev
76717>>>>>>>        Local Integer iCurrentPart
76717>>>>>>>        Local Integer iSeparatorPos
76717>>>>>>>
76717>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
76720>>>>>>>
76720>>>>>>>        Move 0 To iCurrentPart
76721>>>>>>>        Repeat
76721>>>>>>>>
76721>>>>>>>            Move (Pos(".", sRevision)) To iSeparatorPos
76722>>>>>>>            If (iSeparatorPos > 0) Begin
76724>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) To iPartRev
76725>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) To sRevision
76726>>>>>>>                Increment iCurrentPart
76727>>>>>>>            End
76727>>>>>>>>
76727>>>>>>>            Else If (sRevision <> "") Begin
76730>>>>>>>                Move sRevision To iPartRev
76731>>>>>>>                Move "" To sRevision
76732>>>>>>>                Increment iCurrentPart
76733>>>>>>>            End
76733>>>>>>>>
76733>>>>>>>            Else ;                Move -1 To iPartRev
76735>>>>>>>        Until (iCurrentPart >= iPartNum Or iPartRev = -1)
76737>>>>>>>
76737>>>>>>>        Function_Return iPartRev
76738>>>>>>>    End_Function // EcxtractPartFromRevision
76739>>>>>>>
76739>>>>>>>
76739>>>>>>>
76739>>>>>>>    //***
76739>>>>>>>    //*** Function: CKMajorRevision
76739>>>>>>>    //*** Purpose : Returns the major revision of the CK
76739>>>>>>>    //***
76739>>>>>>>
76739>>>>>>>    Function CKMajorRevision Returns Integer
76741>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
76742>>>>>>>    End_Function // CKMajorRevision
76743>>>>>>>
76743>>>>>>>
76743>>>>>>>
76743>>>>>>>    //***
76743>>>>>>>    //*** Function: CKMinorRevision
76743>>>>>>>    //*** Purpose : Returns the minor revision of the CK
76743>>>>>>>    //***
76743>>>>>>>
76743>>>>>>>    Function CKMinorRevision Returns Integer
76745>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
76746>>>>>>>    End_Function // CKMinorRevision
76747>>>>>>>
76747>>>>>>>
76747>>>>>>>
76747>>>>>>>    //***
76747>>>>>>>    //*** Function: CKReleaseRevision
76747>>>>>>>    //*** Purpose : Returns the release revision of the CK
76747>>>>>>>    //***
76747>>>>>>>
76747>>>>>>>    Function CKReleaseRevision Returns Integer
76749>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
76750>>>>>>>    End_Function // CKReleaseRevision
76751>>>>>>>
76751>>>>>>>
76751>>>>>>>
76751>>>>>>>    //***
76751>>>>>>>    //*** Function: CKBuildRevision
76751>>>>>>>    //*** Purpose : Returns the major revision of the CK
76751>>>>>>>    //***
76751>>>>>>>
76751>>>>>>>    Function CKBuildRevision Returns Integer
76753>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
76754>>>>>>>    End_Function // CKBuildRevision
76755>>>>>>>
76755>>>>>>>
76755>>>>>>>
76755>>>>>>>    //***
76755>>>>>>>    //*** Function: IsMinimalRevision
76755>>>>>>>    //*** Purpose : Determines if the CK conforms to a passed minimal revsion.
76755>>>>>>>    //***
76755>>>>>>>
76755>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
76757>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_return (TRUE)
76760>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
76763>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_return (TRUE)
76766>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
76769>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_return (TRUE)
76772>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) And iBuild <= CKBuildRevision(Current_object)) ;                    Function_return (TRUE)
76776>>>>>>>            End
76776>>>>>>>>
76776>>>>>>>        End
76776>>>>>>>>
76776>>>>>>>
76776>>>>>>>        Function_Return (FALSE)
76777>>>>>>>    End_Function // IsMinimalRevision
76778>>>>>>>
76778>>>>>>>
76778>>>>>>>
76778>>>>>>>    //***
76778>>>>>>>    //*** Function: RegistrationName
76778>>>>>>>    //*** Purpose : Returns the Connectiivty Kit registration name.
76778>>>>>>>    //***
76778>>>>>>>
76778>>>>>>>    Function RegistrationName Returns String
76780>>>>>>>        Local String  sRegistration
76780>>>>>>>        Local String  sDRiverId
76780>>>>>>>        Local String  sVoid
76780>>>>>>>        Local Integer iRetval
76780>>>>>>>
76780>>>>>>>        Get psDriverID To sDriverID
76781>>>>>>>        If (sDRiverID <> "") Begin
76783>>>>>>>            Move (Repeat(" ", 255)) To sRegistration
76784>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETREGNAME Callback 0 Passing sRegistration sVoid 0 Result iRetval
76789>>>>>>>        End
76789>>>>>>>>
76789>>>>>>>
76789>>>>>>>        Function_Return sRegistration
76790>>>>>>>    End_Function // RegistrationName
76791>>>>>>>
76791>>>>>>>
76791>>>>>>>
76791>>>>>>>    //***
76791>>>>>>>    //*** Function: SerialNumber
76791>>>>>>>    //*** Purpose : Returns the Connectiivty Kit serial number.
76791>>>>>>>    //***
76791>>>>>>>
76791>>>>>>>    Function SerialNumber Returns Integer
76793>>>>>>>        Local String  sDRiverId
76793>>>>>>>        Local String  sVoid
76793>>>>>>>        Local Integer iRetval
76793>>>>>>>
76793>>>>>>>        Get psDriverID To sDriverID
76794>>>>>>>        If (sDRiverID <> "") Begin
76796>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETSERIALNUM Callback 0 Passing sVoid sVoid 0 Result iRetval
76801>>>>>>>        End
76801>>>>>>>>
76801>>>>>>>
76801>>>>>>>        Function_Return iRetval
76802>>>>>>>    End_Function // SerialNumber
76803>>>>>>>
76803>>>>>>>
76803>>>>>>>
76803>>>>>>>    //***
76803>>>>>>>    //*** Function: MaxUsers
76803>>>>>>>    //*** Purpose : Returns the Connectiivty Kit maximum number of users.
76803>>>>>>>    //***
76803>>>>>>>
76803>>>>>>>    Function MaxUsers Returns Integer
76805>>>>>>>        Local String  sDRiverId
76805>>>>>>>        Local String  sVoid
76805>>>>>>>        Local Integer iRetval
76805>>>>>>>
76805>>>>>>>        Get psDriverID To sDriverID
76806>>>>>>>        If (sDRiverID <> "") Begin
76808>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETMAXUSERS Callback 0 Passing sVoid sVoid 0 Result iRetval
76813>>>>>>>        End
76813>>>>>>>>
76813>>>>>>>
76813>>>>>>>        Function_Return iRetval
76814>>>>>>>    End_Function // MaxUsers
76815>>>>>>>
76815>>>>>>>
76815>>>>>>>
76815>>>>>>>    //***
76815>>>>>>>    //*** Procedure: DumpStatus
76815>>>>>>>    //*** Purpose  : Dump the current status of the drver in the passed disk file.
76815>>>>>>>    //***
76815>>>>>>>
76815>>>>>>>    Procedure DumpStatus String sFileName
76817>>>>>>>        Local String  sVoid
76817>>>>>>>        Local String  sDriverID
76817>>>>>>>        Local Integer iVoid
76817>>>>>>>
76817>>>>>>>        Get psDriverID To sDriverID
76818>>>>>>>        If (sDriverID <> "") ;            Call_driver 0 sDriverID Function CLI_DUMPSTATUS Callback 0 Passing sFileName sVoid iVoid Result iVoid
76825>>>>>>>    End_Procedure // DumpStatus
76826>>>>>>>
76826>>>>>>>
76826>>>>>>>
76826>>>>>>>    //***
76826>>>>>>>    //*** Procedure: ReadConfiguration
76826>>>>>>>    //*** Purpose  : Reset all driver level configurable attributes to the
76826>>>>>>>    //***            default value and then reread the configuration.
76826>>>>>>>    //***
76826>>>>>>>
76826>>>>>>>    Procedure ReadConfiguration
76828>>>>>>>        Local String  sVoid
76828>>>>>>>        Local String  sDriverID
76828>>>>>>>        Local Integer iVoid
76828>>>>>>>
76828>>>>>>>        Get psDriverID To sDriverID
76829>>>>>>>        If (sDriverID <> "") ;            Call_driver 0 sDriverID Function CLI_READCONFIGURATION Callback 0 Passing sVoid sVoid iVoid Result iVoid
76836>>>>>>>    End_Procedure // ReadConfiguration
76837>>>>>>>
76837>>>>>>>
76837>>>>>>>
76837>>>>>>>    //***
76837>>>>>>>    //*** Function: TextToRIMValue
76837>>>>>>>    //*** Purpose : Convert a text to the corresponding
76837>>>>>>>    //***           Generate_Record_ID_Method attribute value
76837>>>>>>>    //***
76837>>>>>>>
76837>>>>>>>    Function TextToRIMValue String sText Returns Integer
76839>>>>>>>        If (sText = "None") ;            Function_return RIM_NONE
76842>>>>>>>        Else If (sText = "Identity Column") ;            Function_return RIM_IDENTITY_COLUMN
76846>>>>>>>        Else If (sText = "Dispenser Table") ;            Function_return RIM_DISPENSER_TABLE
76850>>>>>>>        Else If (sText = "External") ;            Function_return RIM_EXTERNAL
76854>>>>>>>    End_Function // TextToRIMValue
76855>>>>>>>
76855>>>>>>>
76855>>>>>>>
76855>>>>>>>    //***
76855>>>>>>>    //*** Function: RIMValueTotext
76855>>>>>>>    //*** Purpose : Convert a Generate_Record_ID_Method attribute value to the
76855>>>>>>>    //***           corresponding text.
76855>>>>>>>    //***
76855>>>>>>>
76855>>>>>>>    Function RIMValueToText Integer iAttrValue Returns String
76857>>>>>>>        If (iAttrValue = RIM_NONE) ;            Function_return "None"
76860>>>>>>>        Else If (iAttrValue = RIM_IDENTITY_COLUMN) ;            Function_return "Identity Column"
76864>>>>>>>        Else If (iAttrValue = RIM_DISPENSER_TABLE) ;            Function_return "Dispenser Table"
76868>>>>>>>        Else If (iAttrValue = RIM_EXTERNAL) ;            Function_return "External"
76872>>>>>>>    End_Function // RIMValueToText
76873>>>>>>>
76873>>>>>>>
76873>>>>>>>
76873>>>>>>>    //***
76873>>>>>>>    //*** Function: TextToROValue
76873>>>>>>>    //*** Purpose : Convert a text to the corresponding
76873>>>>>>>    //***           Generate_Record_ID_Method attribute value
76873>>>>>>>    //***
76873>>>>>>>
76873>>>>>>>    Function TextToROValue String sText Returns Integer
76875>>>>>>>        If (sText = "No") ;            Function_return RO_NO
76878>>>>>>>        Else If (sText = "Ignore Change") ;            Function_return RO_IGNORECHANGE
76882>>>>>>>        Else If (sText = "Accept Change") ;            Function_return RO_ACCEPTCHANGE
76886>>>>>>>        Else If (sText = "Error On Change") ;            Function_return RO_ERRORONCHANGE
76890>>>>>>>    End_Function // TextToRIMValue
76891>>>>>>>
76891>>>>>>>
76891>>>>>>>
76891>>>>>>>    //***
76891>>>>>>>    //*** Function: ROValueTotext
76891>>>>>>>    //*** Purpose : Convert a Generate_Record_ID_Method attribute value to the
76891>>>>>>>    //***           corresponding text.
76891>>>>>>>    //***
76891>>>>>>>
76891>>>>>>>    Function ROValueToText Integer iAttrValue Returns String
76893>>>>>>>        If (iAttrValue = RO_NO) ;            Function_return "No"
76896>>>>>>>        Else If (iAttrValue = RO_IGNORECHANGE) ;            Function_return "Ignore Change"
76900>>>>>>>        Else If (iAttrValue = RO_ACCEPTCHANGE) ;            Function_return "Accept Change"
76904>>>>>>>        Else If (iAttrValue = RO_ERRORONCHANGE) ;            Function_return "Error On Change"
76908>>>>>>>    End_Function // RIMValueToText
76909>>>>>>>
76909>>>>>>>
76909>>>>>>>
76909>>>>>>>    //***
76909>>>>>>>    //*** Function: LastDriverError
76909>>>>>>>    //*** Purpose : Return the text f the last error geneated by the driver.
76909>>>>>>>    //***
76909>>>>>>>
76909>>>>>>>    Function LastDriverError Returns String
76911>>>>>>>        Local String  sDriverID
76911>>>>>>>        Local String  sLastError
76911>>>>>>>        Local String  sLastErrorLength
76911>>>>>>>        Local Integer iLastErrorLength
76911>>>>>>>        Local Integer iVoid
76911>>>>>>>
76911>>>>>>>        //*** Initialize
76911>>>>>>>        Move "" To sLastError
76912>>>>>>>
76912>>>>>>>        Get psDriverID To sDriverID
76913>>>>>>>        If (sDriverID <> "") Begin
76915>>>>>>>            //*** Get the text of the last error
76915>>>>>>>            Move (Repeat(Character(" "), 14)) To sLastErrorlength
76916>>>>>>>            Call_driver 0 sDriverID Function CLI_GETDRIVERATTRIBUTE Callback 0 Passing sLastErrorLength iVoid DRVR_LASTERRORTEXTLENGTH Result iVoid
76921>>>>>>>            Move (Left(sLastErrorLength, Pos(Character(0), sLastErrorLength) - 1)) To iLastErrorLength
76922>>>>>>>
76922>>>>>>>            If (iLastErrorLength > 0) Begin
76924>>>>>>>                Move (Repeat(Character(" "), iLastErrorLength + 1)) To sLastError
76925>>>>>>>                Call_driver 0 sDriverID Function CLI_GETDRIVERATTRIBUTE Callback 0 Passing sLastError iVoid DRVR_LASTERRORTEXT Result iVoid
76930>>>>>>>                Move (Left(sLastError, Pos(Character(0), sLastError) - 1)) To sLastError
76931>>>>>>>            End
76931>>>>>>>>
76931>>>>>>>        End
76931>>>>>>>>
76931>>>>>>>
76931>>>>>>>        Function_Return sLastError
76932>>>>>>>    End_Function // LastDriverError
76933>>>>>>>
76933>>>>>>>
76933>>>>>>>
76933>>>>>>>    //***
76933>>>>>>>    //*** Function: EnumerateTables
76933>>>>>>>    //*** Purpose : Enumerate the tables in a database
76933>>>>>>>    //***
76933>>>>>>>
76933>>>>>>>    Function EnumerateTables String sLogin Returns Integer
76935>>>>>>>        Local String  sDriver
76935>>>>>>>        Local String  sVoid
76935>>>>>>>        Local Integer iNumTables
76935>>>>>>>        Local Integer iVoid
76935>>>>>>>
76935>>>>>>>        Get psDriverID To sDriver
76936>>>>>>>        If (sDriver <> "") ;            Call_driver 0 sDriver Function CLI_ENUMERATE_TABLES Callback 0 Passing sLogin sVoid iVoid Result iNumTables
76943>>>>>>>
76943>>>>>>>        Function_Return iNumTables
76944>>>>>>>    End_Function // EnumerateTables
76945>>>>>>>
76945>>>>>>>
76945>>>>>>>
76945>>>>>>>    //***
76945>>>>>>>    //*** Function: TableName
76945>>>>>>>    //*** Purpose : Returns the name of the table enumerated at the given position
76945>>>>>>>    //***
76945>>>>>>>
76945>>>>>>>    Function TableName Integer iIndex Returns String
76947>>>>>>>        Local String  sDriver
76947>>>>>>>        Local String  sTableName
76947>>>>>>>        Local String  sVoid
76947>>>>>>>        Local Integer iVoid
76947>>>>>>>
76947>>>>>>>        Get psDriverID To sDriver
76948>>>>>>>        If (sDriver <> "") Begin
76950>>>>>>>            Move (Repeat(" ", 255)) To sTableName
76951>>>>>>>            Call_driver 0 sDriver Function CLI_TABLENAME Callback 0 Passing sTableName sVoid iIndex Result iVoid
76956>>>>>>>        End
76956>>>>>>>>
76956>>>>>>>
76956>>>>>>>        Function_Return sTableName
76957>>>>>>>    End_Function // TableName
76958>>>>>>>
76958>>>>>>>
76958>>>>>>>
76958>>>>>>>    //***
76958>>>>>>>    //*** Function: SchemaName
76958>>>>>>>    //*** Purpose : Returns the name of the schema of the table enumerated at the given position
76958>>>>>>>    //***
76958>>>>>>>
76958>>>>>>>    Function SchemaName Integer iIndex Returns String
76960>>>>>>>        Local String  sDriver
76960>>>>>>>        Local String  sSchemaName
76960>>>>>>>        Local String  sVoid
76960>>>>>>>        Local Integer iVoid
76960>>>>>>>
76960>>>>>>>        Get psDriverID To sDriver
76961>>>>>>>        If (sDriver <> "") Begin
76963>>>>>>>            Move (Repeat(" ", 255)) To sSchemaName
76964>>>>>>>            Call_driver 0 sDriver Function CLI_TABLESCHEMA Callback 0 Passing sSchemaName sVoid iIndex Result iVoid
76969>>>>>>>        End
76969>>>>>>>>
76969>>>>>>>
76969>>>>>>>        Function_Return sSchemaName
76970>>>>>>>    End_Function // SchemaName
76971>>>>>>>
76971>>>>>>>
76971>>>>>>>
76971>>>>>>>    //***
76971>>>>>>>    //*** Function: TableType
76971>>>>>>>    //*** Purpose : Returns the type of the table enumerated at the given position.
76971>>>>>>>    //***           Types can be "TABLE", "VIEW", "SYSTEM TABLE", "GLOBAL TEMPORARY",
76971>>>>>>>    //***           "LOCAL TEMPORARY", "ALIAS", "SYNONYM"
76971>>>>>>>    //***
76971>>>>>>>
76971>>>>>>>    Function TableType Integer iIndex Returns String
76973>>>>>>>        Local String  sDriver
76973>>>>>>>        Local String  sTableType
76973>>>>>>>        Local String  sVoid
76973>>>>>>>        Local Integer iVoid
76973>>>>>>>
76973>>>>>>>        Get psDriverID To sDriver
76974>>>>>>>        If (sDriver <> "") Begin
76976>>>>>>>            Move (Repeat(" ", 25)) To sTableType
76977>>>>>>>            Call_driver 0 sDriver Function CLI_TABLETYPE Callback 0 Passing sTableType sVoid iIndex Result iVoid
76982>>>>>>>        End
76982>>>>>>>>
76982>>>>>>>
76982>>>>>>>        Function_Return sTableType
76983>>>>>>>    End_Function // TableType
76984>>>>>>>
76984>>>>>>>
76984>>>>>>>
76984>>>>>>>    //***
76984>>>>>>>    //*** Function: TableComment
76984>>>>>>>    //*** Purpose : Returns the comment of the table enumerated at the given position
76984>>>>>>>    //***
76984>>>>>>>
76984>>>>>>>    Function TableComment Integer iIndex Returns String
76986>>>>>>>        Local String  sDriver
76986>>>>>>>        Local String  sTableComment
76986>>>>>>>        Local String  sVoid
76986>>>>>>>        Local Integer iVoid
76986>>>>>>>
76986>>>>>>>        Get psDriverID To sDriver
76987>>>>>>>        If (sDriver <> "") Begin
76989>>>>>>>            Move (Repeat(" ", 255)) To sTableComment
76990>>>>>>>            Call_driver 0 sDriver Function CLI_TABLECOMMENT Callback 0 Passing sTableComment sVoid iIndex Result iVoid
76995>>>>>>>        End
76995>>>>>>>>
76995>>>>>>>
76995>>>>>>>        Function_Return sTableComment
76996>>>>>>>    End_Function // TableComment
76997>>>>>>>
76997>>>>>>>
76997>>>>>>>
76997>>>>>>>    //***
76997>>>>>>>    //*** Function: EnumerateColumns
76997>>>>>>>    //*** Purpose : Enumerate the columns in a table
76997>>>>>>>    //***
76997>>>>>>>
76997>>>>>>>    Function EnumerateColumns String sLogin String sTableName Returns Integer
76999>>>>>>>        Local String  sDriver
76999>>>>>>>        Local Integer iNumColumns
76999>>>>>>>        Local Integer iVoid
76999>>>>>>>
76999>>>>>>>        Get psDriverID To sDriver
77000>>>>>>>        If (sDriver <> "") ;            Call_driver 0 sDriver Function CLI_ENUMERATE_COLUMNS Callback 0 Passing sLogin sTablename iVoid Result iNumColumns
77007>>>>>>>
77007>>>>>>>        Function_Return iNumColumns
77008>>>>>>>    End_Function // EnumerateColumns
77009>>>>>>>
77009>>>>>>>
77009>>>>>>>
77009>>>>>>>    //***
77009>>>>>>>    //*** Function: ColumnName
77009>>>>>>>    //*** Purpose : Returns the name of the column enumerated at the given position
77009>>>>>>>    //***
77009>>>>>>>
77009>>>>>>>    Function ColumnName Integer iIndex Returns String
77011>>>>>>>        Local String  sDriver
77011>>>>>>>        Local String  sColumnName
77011>>>>>>>        Local String  sVoid
77011>>>>>>>        Local Integer iVoid
77011>>>>>>>
77011>>>>>>>        Get psDriverID To sDriver
77012>>>>>>>        If (sDriver <> "") Begin
77014>>>>>>>            Move (Repeat(" ", 255)) To sColumnName
77015>>>>>>>            Call_driver 0 sDriver Function CLI_COLUMNNAME Callback 0 Passing sColumnName sVoid iIndex Result iVoid
77020>>>>>>>        End
77020>>>>>>>>
77020>>>>>>>
77020>>>>>>>        Function_Return sColumnName
77021>>>>>>>    End_Function // ColumnName
77022>>>>>>>
77022>>>>>>>
77022>>>>>>>
77022>>>>>>>    //***
77022>>>>>>>    //*** Function: CLIDFDateToSQLDate
77022>>>>>>>    //*** Purpose : Convert a DataFlex date to a SQL date using the dummy zero date value.
77022>>>>>>>    //***
77022>>>>>>>
77022>>>>>>>    Function CLIDFDateToSQLDate String sDRiver Date dDFDate Returns String
77024>>>>>>>        Local String sSQLDate
77024>>>>>>>        Local Integer iOrgDateFmt
77024>>>>>>>        Local Integer iOrgDateSep
77024>>>>>>>
77024>>>>>>>        //*** Change date format to military, SQL dates are military dates
77024>>>>>>>        Get_Attribute DF_DATE_FORMAT To iOrgDateFmt
77027>>>>>>>        Get_Attribute DF_DATE_SEPARATOR To iOrgDateSep
77030>>>>>>>        Set_Attribute DF_DATE_FORMAT To DF_DATE_MILITARY
77033>>>>>>>        Set_Attribute DF_DATE_SEPARATOR To (Ascii('-'))
77036>>>>>>>
77036>>>>>>>        //*** We only need to convert if the date is 0
77036>>>>>>>        If (Integer(dDFDate = 0)) ;            CLI_Get_Driver_Attribute sDRiver DRVR_DUMMY_ZERO_DATE_VALUE To sSQLDate
77045>>>>>>>        Else ;            Move dDFDate To sSQLDate
77047>>>>>>>
77047>>>>>>>        //*** Change date format back to original
77047>>>>>>>        Set_Attribute DF_DATE_FORMAT To iOrgDateFmt
77050>>>>>>>        Set_Attribute DF_DATE_SEPARATOR To iOrgDateSep
77053>>>>>>>
77053>>>>>>>        Function_Return sSQLDate
77054>>>>>>>    End_Function // CLIDFDateToSQLDate
77055>>>>>>>
77055>>>>>>>
77055>>>>>>>
77055>>>>>>>    //***
77055>>>>>>>    //*** Function: CLISQLDateToDFDate
77055>>>>>>>    //*** Purpose : Convert a SQL date to a DataFlex date using the dummy zero date value.
77055>>>>>>>    //***
77055>>>>>>>
77055>>>>>>>    Function CLISQLDateToDFDate String sDRiver String sSQLDate Returns Date
77057>>>>>>>        Local Date dDFDate
77057>>>>>>>        Local String sDummyDateValue
77057>>>>>>>        Local Integer iOrgDateFmt
77057>>>>>>>        Local Integer iOrgDateSep
77057>>>>>>>
77057>>>>>>>        //*** Change date format to military, SQL dates are military dates
77057>>>>>>>        Get_Attribute DF_DATE_FORMAT To iOrgDateFmt
77060>>>>>>>        Get_Attribute DF_DATE_SEPARATOR To iOrgDateSep
77063>>>>>>>        Set_Attribute DF_DATE_FORMAT To DF_DATE_MILITARY
77066>>>>>>>        Set_Attribute DF_DATE_SEPARATOR To (Ascii('-'))
77069>>>>>>>
77069>>>>>>>        //*** We only need to convert if the date is the dummy zero date value
77069>>>>>>>        CLI_Get_Driver_Attribute sDRiver DRVR_DUMMY_ZERO_DATE_VALUE To sDummyDateValue
77076>>>>>>>        If (sDummyDateValue = sSQLDate) ;            Move 0 To dDFDate
77079>>>>>>>        Else ;            Move sSQLDate To dDFDate
77081>>>>>>>
77081>>>>>>>        //*** Change date format back to original
77081>>>>>>>        Set_Attribute DF_DATE_FORMAT To iOrgDateFmt
77084>>>>>>>        Set_Attribute DF_DATE_SEPARATOR To iOrgDateSep
77087>>>>>>>
77087>>>>>>>        Function_Return dDFDate
77088>>>>>>>    End_Function // CLISQLDateToDFDate
77089>>>>>>>
77089>>>>>>>
77089>>>>>>>
77089>>>>>>>    //***
77089>>>>>>>    //*** Function: RedirectConnection
77089>>>>>>>    //*** Purpose : Redirect an exisitng connection. The existing connection
77089>>>>>>>    //***           will point to another database but all tables will stay
77089>>>>>>>    //***           open!
77089>>>>>>>    //***
77089>>>>>>>
77089>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
77091>>>>>>>        Local String  sDriver
77091>>>>>>>        Local String  sVoid
77091>>>>>>>        Local Integer iResult
77091>>>>>>>        Local Integer iVoid
77091>>>>>>>
77091>>>>>>>        Get psDriverID To sDriver
77092>>>>>>>        If (sDriver <> "") Begin
77094>>>>>>>            Call_driver 0 sDriver Function CLI_REDIRECTCONNECTION Callback 0 Passing sOldConnection sNewConnection iVoid Result iResult
77099>>>>>>>        End
77099>>>>>>>>
77099>>>>>>>        Function_Return iResult
77100>>>>>>>    End_Function // RedirectConnect
77101>>>>>>>
77101>>>>>>>
77101>>>>>>>
77101>>>>>>>    //***
77101>>>>>>>    //*** Function: CreateConnectionID
77101>>>>>>>    //*** Purpose : Create a DataFlex side connection id that can be used later on.
77101>>>>>>>    //***
77101>>>>>>>
77101>>>>>>>    Function CreateConnectionID String sID String sConnStr Integer iOpt Returns Integer
77103>>>>>>>        Local String  sDriver
77103>>>>>>>        Local Integer iResult
77103>>>>>>>        Local Integer iOptions
77103>>>>>>>
77103>>>>>>>        Get psDriverID to sDriver
77104>>>>>>>        If (Num_Arguments = 2) ;            Move 0 to iOptions
77107>>>>>>>        Else ;            Move iOpt to iOptions
77109>>>>>>>        If (sDriver <> "") Begin
77111>>>>>>>            Call_Driver 0 sDriver Function CLI_CREATECONNECTIONID Callback 0 Passing sID sConnStr iOptions Result iResult
77116>>>>>>>        End
77116>>>>>>>>
77116>>>>>>>        Function_Return iResult
77117>>>>>>>    End_Function // CreateConnectionID
77118>>>>>>>
77118>>>>>>>
77118>>>>>>>
77118>>>>>>>    //***
77118>>>>>>>    //*** Function: DeleteConnectionID
77118>>>>>>>    //*** Purpose : Delete a DataFlex side connection id.
77118>>>>>>>    //***
77118>>>>>>>
77118>>>>>>>    Function DeleteConnectionID String sID Integer iIndex Returns Integer
77120>>>>>>>        Local String  sDriver
77120>>>>>>>        Local Integer iResult
77120>>>>>>>        Local String sVoid
77120>>>>>>>
77120>>>>>>>        Get psDriverID To sDriver
77121>>>>>>>        If (sDriver <> "") Begin
77123>>>>>>>            Call_Driver 0 sDriver Function CLI_DELETECONNECTIONID Callback 0 Passing sID sVoid iIndex Result iResult
77128>>>>>>>        End
77128>>>>>>>>
77128>>>>>>>        Function_Return iResult
77129>>>>>>>    End_Function // DeleteConnectionID
77130>>>>>>>
77130>>>>>>>End_Class // cCLIHandler
77131>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files (x86)\DataFlex 18.2\Pkg\DFBTRDRV.PKG)
77131>>>>>>>//****************************************************************************
77131>>>>>>>//
77131>>>>>>>// $File name  : DFBTRDRV.PKG
77131>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
77131>>>>>>>// Notice      : This package contains constants and commands, used to call
77131>>>>>>>//               specific functions in the DFBTRDRV.
77131>>>>>>>// $Author(s)  : Eddy Kleinjan
77131>>>>>>>//
77131>>>>>>>// $System     : DataFlex Connectivity Kit for Pervasive.SQL
77131>>>>>>>// Created     : 01-07-97 @ 12:00:00
77131>>>>>>>//
77131>>>>>>>// Changed     : 04-04-2001.
77131>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.145
77131>>>>>>>//
77131>>>>>>>// Changed     : June 6, 2001
77131>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.148
77131>>>>>>>//
77131>>>>>>>//               Added DFBTR_DDF_OWNER command.
77131>>>>>>>//
77131>>>>>>>// Changed     : June 12, 2001
77131>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.149
77131>>>>>>>//
77131>>>>>>>//               Added DF_FIELD_IS_NULL and DF_FIELD_NULL_ALLOWED attributes
77131>>>>>>>//
77131>>>>>>>// Changed     : August 4, 2004
77131>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 3.0.0.1
77131>>>>>>>//
77131>>>>>>>//               Added cDfbtrdrvHandler class.
77131>>>>>>>//               New functions in this class:
77131>>>>>>>//                  Function CKRevision Returns String
77131>>>>>>>//                  Function CkUsesUri Returns Integer
77131>>>>>>>//                  Function PSQLRequesterVersionInfo Integer iFileNum Returns String
77131>>>>>>>//                  Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
77131>>>>>>>//                  Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
77131>>>>>>>//
77131>>>>>>>// Changed     : September 30, 2005
77131>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 3.0.0.14
77131>>>>>>>//
77131>>>>>>>//               Bugfix: Prevent compiler errors when no (df)error.pkg is used
77131>>>>>>>//****************************************************************************
77131>>>>>>>Use Ui
77131>>>>>>>//
77131>>>>>>>// Driver Indentification
77131>>>>>>>//
77131>>>>>>>
77131>>>>>>>//*** Driver attributes
77131>>>>>>>//
77131>>>>>>>// Call_Driver functions ID's
77131>>>>>>>//
77131>>>>>>>//
77131>>>>>>>// DFBTRFN_CONVERT_FILE options
77131>>>>>>>//
77131>>>>>>>
77131>>>>>>>//
77131>>>>>>>// DFBTRFN_SET_OWNER options
77131>>>>>>>//
77131>>>>>>>
77131>>>>>>>//
77131>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
77131>>>>>>>//
77131>>>>>>>
77131>>>>>>>
77131>>>>>>>//
77131>>>>>>>// Command to create all vars which may be needed
77131>>>>>>>// in other commands.
77131>>>>>>>//
77131>>>>>>>
77131>>>>>>>
77131>>>>>>>
77131>>>>>>>//
77131>>>>>>>// Command to set the owner of a Btrieve file.
77131>>>>>>>// File must have been opened.
77131>>>>>>>// Filenumber needs to be passed.
77131>>>>>>>// To clear set the owner to "".
77131>>>>>>>// Examples:
77131>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
77131>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
77131>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
77131>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
77131>>>>>>>// To clear:
77131>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
77131>>>>>>>//
77131>>>>>>>
77131>>>>>>>
77131>>>>>>>
77131>>>>>>>//
77131>>>>>>>// Command to parse DFBTR_SET_OWNVER
77131>>>>>>>// options.
77131>>>>>>>//
77131>>>>>>>
77131>>>>>>>
77131>>>>>>>
77131>>>>>>>//
77131>>>>>>>// Command to parse for Callback
77131>>>>>>>//
77131>>>>>>>
77131>>>>>>>
77131>>>>>>>
77131>>>>>>>//
77131>>>>>>>// Command to clear the owner of a Btrieve file.
77131>>>>>>>// File must have been opened.
77131>>>>>>>// Filenumber needs to be passed.
77131>>>>>>>// Examples:
77131>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
77131>>>>>>>//
77131>>>>>>>
77131>>>>>>>
77131>>>>>>>
77131>>>>>>>//
77131>>>>>>>// Command to add a owner name to the internal list of ownernames
77131>>>>>>>// which will be tries when opening files.
77131>>>>>>>//
77131>>>>>>>
77131>>>>>>>
77131>>>>>>>
77131>>>>>>>//
77131>>>>>>>// Command to remove all owners from the internal list of ownernames
77131>>>>>>>//
77131>>>>>>>
77131>>>>>>>
77131>>>>>>>//
77131>>>>>>>// Command to set the owner name to be used when opening the DDF files.
77131>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
77131>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
77131>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
77131>>>>>>>//
77131>>>>>>>
77131>>>>>>>//
77131>>>>>>>// Command to change the transaction type.
77131>>>>>>>// Valid types are:
77131>>>>>>>//     DFBTRTT_NONE
77131>>>>>>>//     DFBTRTT_EXCLUSIVE
77131>>>>>>>//     DFBTRTT_CONCURRENT
77131>>>>>>>//
77131>>>>>>>//
77131>>>>>>>
77131>>>>>>>
77131>>>>>>>
77131>>>>>>>//
77131>>>>>>>// Command to get the current transaction type.
77131>>>>>>>//
77131>>>>>>>
77131>>>>>>>//
77131>>>>>>>// Command to set explicit_locking
77131>>>>>>>//
77131>>>>>>>
77131>>>>>>>//
77131>>>>>>>// Command to get explicit locking
77131>>>>>>>//
77131>>>>>>>
77131>>>>>>>//
77131>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
77131>>>>>>>//
77131>>>>>>>
77131>>>>>>>//
77131>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
77131>>>>>>>//
77131>>>>>>>
77131>>>>>>>//*****************************************************************************
77131>>>>>>>//*** Class  : cDfbtrdrvHandler                                                  ***
77131>>>>>>>//*** Purpose: An instance of this class can be used as a broker object to  ***
77131>>>>>>>//***          call several Dfbtrdrv releated methods.                           ***
77131>>>>>>>//*****************************************************************************
77131>>>>>>>
77131>>>>>>>Class cDFBtrDrvHandler Is An Array
77132>>>>>>>
77132>>>>>>>    Procedure Construct_Object Integer iImage
77134>>>>>>>        Forward Send Construct_object iImage
77136>>>>>>>
77136>>>>>>>        Property String  psDriverID       Public "DFBTRDRV"
77137>>>>>>>    End_Procedure // Construct_Object
77138>>>>>>>
77138>>>>>>>
77138>>>>>>>
77138>>>>>>>    //***
77138>>>>>>>    //*** Function: CKRevsion
77138>>>>>>>    //*** Purpose : The revsion of a Dfbtrdrv Connectivity Kit
77138>>>>>>>    //***
77138>>>>>>>
77138>>>>>>>    Function CKRevision Returns String
77140>>>>>>>        Local String  sDriverID
77140>>>>>>>        Local String  sRevision
77140>>>>>>>        Local String  sVoid
77140>>>>>>>        Local Integer iRetval
77140>>>>>>>
77140>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
77140>>>>>>>        // This error would otherwise be raised when we have an older
77140>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
77140>>>>>>>        Send Ignore_error To Error_object_Id 20491
77141>>>>>>>        Get psDriverID To sDriverID
77142>>>>>>>        Move (Repeat(" ", 255)) To sRevision
77143>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
77148>>>>>>>        Send Trap_Error To Error_object_Id 20491
77149>>>>>>>        If (Trim(sRevision) = "") Begin
77151>>>>>>>            // Unable to get the revision. return all zeroes.
77151>>>>>>>            Move "0.0.0.0" To sRevision
77152>>>>>>>        End
77152>>>>>>>>
77152>>>>>>>        Function_Return sRevision
77153>>>>>>>    End_Function // CKRevision
77154>>>>>>>
77154>>>>>>>    Function CkUsesUri Returns Integer
77156>>>>>>>        Local String  sDriverID
77156>>>>>>>        Local String  sVoid1
77156>>>>>>>        Local String  sVoid2
77156>>>>>>>        Local Integer iRetval
77156>>>>>>>
77156>>>>>>>        Get psDriverID To sDriverID
77157>>>>>>>
77157>>>>>>>        Move 0 To iRetval
77158>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
77158>>>>>>>        // This error would otherwise be raised when we have an older
77158>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
77158>>>>>>>        Send Ignore_error To Error_object_Id 20491
77159>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
77164>>>>>>>        Send Trap_Error To Error_object_Id 20491
77165>>>>>>>
77165>>>>>>>        Function_Return iRetval
77166>>>>>>>    End_Function // CKUsesUri
77167>>>>>>>
77167>>>>>>>
77167>>>>>>>
77167>>>>>>>    //***
77167>>>>>>>    //*** Function: ExtractPartFromRevsion
77167>>>>>>>    //*** Purpose : Extarct the Nth part of a a.b.c.d revsion string.
77167>>>>>>>    //***
77167>>>>>>>    //*** Returns : The part version number or -1 if there is no such part number.
77167>>>>>>>    //***
77167>>>>>>>
77167>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
77169>>>>>>>        Local Integer iPartRev
77169>>>>>>>        Local Integer iCurrentPart
77169>>>>>>>        Local Integer iSeparatorPos
77169>>>>>>>
77169>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
77172>>>>>>>
77172>>>>>>>        Move 0 To iCurrentPart
77173>>>>>>>        Repeat
77173>>>>>>>>
77173>>>>>>>            Move (Pos(".", sRevision)) To iSeparatorPos
77174>>>>>>>            If (iSeparatorPos > 0) Begin
77176>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) To iPartRev
77177>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) To sRevision
77178>>>>>>>                Increment iCurrentPart
77179>>>>>>>            End
77179>>>>>>>>
77179>>>>>>>            Else If (sRevision <> "") Begin
77182>>>>>>>                Move sRevision To iPartRev
77183>>>>>>>                Move "" To sRevision
77184>>>>>>>                Increment iCurrentPart
77185>>>>>>>            End
77185>>>>>>>>
77185>>>>>>>            Else ;                Move -1 To iPartRev
77187>>>>>>>        Until (iCurrentPart >= iPartNum Or iPartRev = -1)
77189>>>>>>>
77189>>>>>>>        Function_Return iPartRev
77190>>>>>>>    End_Function // EcxtractPartFromRevision
77191>>>>>>>
77191>>>>>>>
77191>>>>>>>
77191>>>>>>>    //***
77191>>>>>>>    //*** Function: CKMajorRevision
77191>>>>>>>    //*** Purpose : Returns the major revision of the CK
77191>>>>>>>    //***
77191>>>>>>>
77191>>>>>>>    Function CKMajorRevision Returns Integer
77193>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
77194>>>>>>>    End_Function // CKMajorRevision
77195>>>>>>>
77195>>>>>>>
77195>>>>>>>
77195>>>>>>>    //***
77195>>>>>>>    //*** Function: CKMinorRevision
77195>>>>>>>    //*** Purpose : Returns the minor revision of the CK
77195>>>>>>>    //***
77195>>>>>>>
77195>>>>>>>    Function CKMinorRevision Returns Integer
77197>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
77198>>>>>>>    End_Function // CKMinorRevision
77199>>>>>>>
77199>>>>>>>
77199>>>>>>>
77199>>>>>>>    //***
77199>>>>>>>    //*** Function: CKReleaseRevision
77199>>>>>>>    //*** Purpose : Returns the release revision of the CK
77199>>>>>>>    //***
77199>>>>>>>
77199>>>>>>>    Function CKReleaseRevision Returns Integer
77201>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
77202>>>>>>>    End_Function // CKReleaseRevision
77203>>>>>>>
77203>>>>>>>
77203>>>>>>>
77203>>>>>>>    //***
77203>>>>>>>    //*** Function: CKBuildRevision
77203>>>>>>>    //*** Purpose : Returns the major revision of the CK
77203>>>>>>>    //***
77203>>>>>>>
77203>>>>>>>    Function CKBuildRevision Returns Integer
77205>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
77206>>>>>>>    End_Function // CKBuildRevision
77207>>>>>>>
77207>>>>>>>
77207>>>>>>>
77207>>>>>>>    //***
77207>>>>>>>    //*** Function: IsMinimalRevision
77207>>>>>>>    //*** Purpose : Determines if the CK conforms to a passed minimal revsion.
77207>>>>>>>    //***
77207>>>>>>>
77207>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
77209>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_return (TRUE)
77212>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
77215>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_return (TRUE)
77218>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
77221>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_return (TRUE)
77224>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) And iBuild <= CKBuildRevision(Current_object)) ;                    Function_return (TRUE)
77228>>>>>>>            End
77228>>>>>>>>
77228>>>>>>>        End
77228>>>>>>>>
77228>>>>>>>
77228>>>>>>>        Function_Return (FALSE)
77229>>>>>>>    End_Function // IsMinimalRevision
77230>>>>>>>
77230>>>>>>>    //   Functions to query the Pervasive.SQL version:
77230>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
77230>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
77230>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
77230>>>>>>>    //
77230>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
77230>>>>>>>    //   in the following format:
77230>>>>>>>    //       <version>.<revision>.<type>
77230>>>>>>>    //   possible values for <type>:
77230>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
77230>>>>>>>    //         server using Workgroup authentication mode
77230>>>>>>>    //       C for client cache engine
77230>>>>>>>    //       D for DOS workstation
77230>>>>>>>    //       N for client Requester
77230>>>>>>>    //       S for NetWare server
77230>>>>>>>    //       T for 32-bit Windows server engine
77230>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
77230>>>>>>>    //
77230>>>>>>>    //   example:
77230>>>>>>>    //       8.50.T
77230>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
77230>>>>>>>    //   32-bits Windows server.
77230>>>>>>>    //
77230>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
77230>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
77230>>>>>>>    //
77230>>>>>>>    //   If the version information is not available or can not be obtained
77230>>>>>>>    //   the functions will return "0.0.0"
77230>>>>>>>
77230>>>>>>>
77230>>>>>>>    //***
77230>>>>>>>    //*** Function: PSQLRequesterVersionInfo
77230>>>>>>>    //*** Purpose : Returns the version information of the
77230>>>>>>>    //***           Pervasive.SQL Client requester.
77230>>>>>>>
77230>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
77232>>>>>>>
77232>>>>>>>        Local String  sDriverID
77232>>>>>>>        Local String  sVersion
77232>>>>>>>        Local String  sVoid
77232>>>>>>>        Local Integer iRetval
77232>>>>>>>
77232>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
77232>>>>>>>        // This error would otherwise be raised when we have an older
77232>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
77232>>>>>>>        Send Ignore_error To Error_object_Id 20491
77233>>>>>>>        Get psDriverID To sDriverID
77234>>>>>>>        Move (Repeat(" ", 255)) To sVersion
77235>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
77240>>>>>>>        Send Trap_Error To Error_object_Id 20491
77241>>>>>>>        If (Trim(sVersion) = "") Begin
77243>>>>>>>            // Unable to get the revision. return all zeroes.
77243>>>>>>>            Move "0.0.0" To sVersion
77244>>>>>>>        End
77244>>>>>>>>
77244>>>>>>>        Function_Return sVersion
77245>>>>>>>    End_Function //  PSQLRequesterVersion
77246>>>>>>>
77246>>>>>>>    //***
77246>>>>>>>    //*** Function: PSQLLocalEngineVersionInfo
77246>>>>>>>    //*** Purpose : Returns the version information of the
77246>>>>>>>    //***           Pervasive.SQL Local Engine
77246>>>>>>>
77246>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
77248>>>>>>>
77248>>>>>>>        Local String  sDriverID
77248>>>>>>>        Local String  sVersion
77248>>>>>>>        Local String  sVoid
77248>>>>>>>        Local Integer iRetval
77248>>>>>>>
77248>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
77248>>>>>>>        // This error would otherwise be raised when we have an older
77248>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
77248>>>>>>>        Send Ignore_error To Error_object_Id 20491
77249>>>>>>>        Get psDriverID To sDriverID
77250>>>>>>>        Move (Repeat(" ", 255)) To sVersion
77251>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
77256>>>>>>>        Send Trap_Error To Error_object_Id 20491
77257>>>>>>>        If (Trim(sVersion) = "") Begin
77259>>>>>>>            // Unable to get the revision. return all zeroes.
77259>>>>>>>            Move "0.0.0" To sVersion
77260>>>>>>>        End
77260>>>>>>>>
77260>>>>>>>        Function_Return sVersion
77261>>>>>>>    End_Function //  PSQLLocalEngineVersion
77262>>>>>>>
77262>>>>>>>    //***
77262>>>>>>>    //*** Function: PSQLServerEngineVersionInfo
77262>>>>>>>    //*** Purpose : Returns the version information of the
77262>>>>>>>    //***           Pervasive.SQL Server Engine
77262>>>>>>>
77262>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
77264>>>>>>>
77264>>>>>>>        Local String  sDriverID
77264>>>>>>>        Local String  sVersion
77264>>>>>>>        Local String  sVoid
77264>>>>>>>        Local Integer iRetval
77264>>>>>>>
77264>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
77264>>>>>>>        // This error would otherwise be raised when we have an older
77264>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
77264>>>>>>>        Send Ignore_error To Error_object_Id 20491
77265>>>>>>>        Get psDriverID To sDriverID
77266>>>>>>>        Move (Repeat(" ", 255)) To sVersion
77267>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
77272>>>>>>>        Send Trap_Error To Error_object_Id 20491
77273>>>>>>>        If (Trim(sVersion) = "") Begin
77275>>>>>>>            // Unable to get the revision. return all zeroes.
77275>>>>>>>            Move "0.0.0" To sVersion
77276>>>>>>>        End
77276>>>>>>>>
77276>>>>>>>        Function_Return sVersion
77277>>>>>>>    End_Function //  PSQLServerEngineVersion
77278>>>>>>>
77278>>>>>>>End_Class // cDfbtrdrvHandler
77279>>>>>>>
77279>>>>>
77279>>>>>
77279>>>>>External_Function WNetGetUser "WNetGetUserA" MPR.DLL Pointer lpName Pointer lpUser_Name Pointer lpLength Returns DWord
77280>>>>>
77280>>>>>Register_Function phoWorkspace Returns Handle
77280>>>>>Register_Function Help_filename Returns String
77280>>>>>Register_Function GetHelpFile Returns String
77280>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
77280>>>>>
77280>>>>>//****************************************************************************
77280>>>>>// $Module type: FUNCTION
77280>>>>>// $Module name: Network_User_Name
77280>>>>>// $Author     : AK/VOO/KCR
77280>>>>>// Created     : 09-24-96 @ 19:17
77280>>>>>//
77280>>>>>// Description
77280>>>>>//    This function reads the current username Of windows and returns that
77280>>>>>//    name or an text unknown user
77280>>>>>//
77280>>>>>// $Rev History
77280>>>>>//  02/22/2012  Ask Windows how long the size of the name should be
77280>>>>>//  07/25/2003  Replaced obsolete code
77280>>>>>//  09/24/1996  Module header created
77280>>>>>//****************************************************************************
77280>>>>>Function Network_User_Name for cDesktop Returns String
77282>>>>>    String sName
77282>>>>>    Integer iRetval iLength
77282>>>>>
77282>>>>>    Move 0 to iLength
77283>>>>>    Move (WNetGetUser (0, 0, AddressOf (iLength))) to iRetval
77284>>>>>    ZeroString iLength to sName
77285>>>>>    Move (WNetGetUser (0, AddressOf (sName), AddressOf (iLength))) to iRetval
77286>>>>>
77286>>>>>    If (iRetval = NO_ERROR) Begin
77288>>>>>        Function_Return (CString (sName))
77289>>>>>    End
77289>>>>>>
77289>>>>>    
77289>>>>>    Function_Return "User Unknown"
77290>>>>>End_Function
77291>>>>>
77291>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
77291>>>>>Type MEMORYSTATUS
77291>>>>>   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
77291>>>>>   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
77291>>>>>   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
77291>>>>>   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
77291>>>>>   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
77291>>>>>   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
77291>>>>>   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
77291>>>>>   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
77291>>>>>End_Type // MEMORYSTATUS
77291>>>>>
77291>>>>>External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
77292>>>>>
77292>>>>>Struct tWinMemoryStatusEx
77292>>>>>    UInteger dwLength                
77292>>>>>    UInteger dwMemoryLoad          
77292>>>>>    UBigInt ullTotalPhys           
77292>>>>>    UBigInt ullAvailPhys           
77292>>>>>    UBigInt ullTotalPageFile       
77292>>>>>    UBigInt ullAvailPageFile       
77292>>>>>    UBigInt ullTotalVirtual        
77292>>>>>    UBigInt ullAvailVirtual        
77292>>>>>    UBigInt ullAvailExtendedVirtual
77292>>>>>End_Struct
77292>>>>>
77292>>>>>External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
77293>>>>>
77293>>>>>Class SysinfoDisplay is a cTextEdit
77294>>>>>    Procedure Construct_Object
77296>>>>>        Forward Send Construct_Object
77298>>>>>
77298>>>>>        Set Location To 6 6
77299>>>>>        Set Size To 110 255
77300>>>>>        Set Read_Only_State To True
77301>>>>>        Set pbWrap to False
77302>>>>>    End_Procedure
77303>>>>>
77303>>>>>    //****************************************************************************
77303>>>>>    // $Module type: PROCEDURE
77303>>>>>    // $Module name: Show_Current_Directory
77303>>>>>    // $Author     : VOO
77303>>>>>    // Created     : 06-10-96 @ 15:24
77303>>>>>    //
77303>>>>>    // Description
77303>>>>>    //    This method will show the name Of the current directory in the system
77303>>>>>    //    information box
77303>>>>>    //
77303>>>>>    // $Rev History
77303>>>>>    //    06-10-96  Module header created
77303>>>>>    //****************************************************************************
77303>>>>>    Procedure Show_Current_Directory
77305>>>>>        String sDir
77305>>>>>
77305>>>>>        Get_Current_Directory To sDir
77306>>>>>
77306>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
77307>>>>>    End_Procedure
77308>>>>>
77308>>>>>    Procedure Show_Windows_Directory
77310>>>>>        String sWindir
77310>>>>>
77310>>>>>        Get_Windows_Directory To sWindir
77311>>>>>
77311>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
77312>>>>>    End_Procedure
77313>>>>>
77313>>>>>    Procedure Show_Current_User
77315>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
77316>>>>>    End_Procedure
77317>>>>>
77317>>>>>    Procedure Show_Number_Format
77319>>>>>        Integer iFormat
77319>>>>>        String sFormatText
77319>>>>>
77319>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
77322>>>>>        Move (Character (iFormat)) To sFormatText
77323>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
77324>>>>>
77324>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
77327>>>>>        Move (Character (iFormat)) to sFormatText
77328>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
77329>>>>>    End_Procedure
77330>>>>>
77330>>>>>    Procedure Show_Filelist_Name
77332>>>>>        String sFilename
77332>>>>>
77332>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
77335>>>>>
77335>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
77336>>>>>        Send AppendTextLn ""
77337>>>>>    End_Procedure
77338>>>>>
77338>>>>>    Procedure Show_Lock_Delay
77340>>>>>        Integer iLockdelay
77340>>>>>
77340>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
77343>>>>>
77343>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
77344>>>>>    End_Procedure
77345>>>>>
77345>>>>>    Procedure Show_Lock_Timeout
77347>>>>>        Integer iLockTimeout
77347>>>>>
77347>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
77350>>>>>
77350>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
77351>>>>>    End_Procedure
77352>>>>>
77352>>>>>    Procedure Show_Screen_Size
77354>>>>>        Integer iYscreensize iXscreensize
77354>>>>>
77354>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
77355>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
77356>>>>>
77356>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
77357>>>>>    End_Procedure
77358>>>>>
77358>>>>>    Procedure Show_Page_Size
77360>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
77361>>>>>    End_procedure
77362>>>>>
77362>>>>>    Procedure Show_Date
77364>>>>>        Date dToday
77364>>>>>
77364>>>>>        Sysdate dToday
77365>>>>>
77365>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
77366>>>>>    End_procedure
77367>>>>>
77367>>>>>    Procedure Show_Date_Format
77369>>>>>        Integer iDateFormat
77369>>>>>        String sDateFormat
77369>>>>>
77369>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
77372>>>>>        Case Begin
77372>>>>>            Case (iDateFormat = DF_DATE_USA)
77374>>>>>                Move C_$USA To sDateFormat
77375>>>>>                Case Break
77376>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
77379>>>>>                Move C_$European To sDateFormat
77380>>>>>                Case Break
77381>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
77384>>>>>                Move C_$Military To sDateFormat
77385>>>>>                Case Break
77386>>>>>            Case Else
77386>>>>>                Move C_$UnknownDateType To sDateFormat
77387>>>>>                Case Break
77388>>>>>        Case End
77388>>>>>
77388>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
77389>>>>>    End_Procedure
77390>>>>>
77390>>>>>    Procedure Show_Systemresources
77392>>>>>        tWinMemoryStatusEx MemoryStatusInfo
77392>>>>>        tWinMemoryStatusEx MemoryStatusInfo
77392>>>>>        Integer iRetval
77392>>>>>
77392>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
77393>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
77394>>>>>        If (iRetval = 0) Begin
77396>>>>>            Move (ShowLastError ()) to iRetval
77397>>>>>        End
77397>>>>>>
77397>>>>>
77397>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, MemoryStatusInfo.ullTotalPhys))
77398>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, MemoryStatusInfo.dwMemoryLoad))
77399>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
77400>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
77401>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
77402>>>>>    End_Procedure
77403>>>>>
77403>>>>>    Procedure Show_Registration
77405>>>>>        String sRegName
77405>>>>>        Integer iSN iMaxUsers
77405>>>>>
77405>>>>>        Registration sRegName iSN
77406>>>>>>
77406>>>>>        
77406>>>>>        Get_Licensed_Max_Users to iMaxUsers
77407>>>>>
77407>>>>>        Send AppendTextLn ""
77408>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
77409>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
77410>>>>>        Send AppendTextLn (SFormat (C_$MaxNumUsers, iMaxUsers))
77411>>>>>    End_Procedure
77412>>>>>
77412>>>>>    //****************************************************************************
77412>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
77412>>>>>    // To the workspace object passing the an object and message To send back
77412>>>>>    // To this object. It is expected that the workspace object will send this
77412>>>>>    // message for every line Of information it wants displayed (passing the
77412>>>>>    // information To be displayed
77412>>>>>    //****************************************************************************
77412>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
77412>>>>>
77412>>>>>    Procedure Show_ServicePack
77414>>>>>        String sKey sVersionDescription sVersion 
77414>>>>>        Handle hoRegistry
77414>>>>>        Boolean bExists bOpened
77414>>>>>        
77414>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
77415>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
77416>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
77417>>>>>
77417>>>>>        Move C_DFVersionRegistryRoot to sKey
77418>>>>>        Get KeyExists of hoRegistry sKey to bExists
77419>>>>>        If (bExists) Begin
77421>>>>>            Get OpenKey of hoRegistry sKey to bOpened
77422>>>>>            If (bOpened) Begin
77424>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
77425>>>>>                If (bExists) Begin
77427>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersionDescription
77428>>>>>                End
77428>>>>>>
77428>>>>>                
77428>>>>>                Get ValueExists of hoRegistry "CurrentVersion" to bExists
77429>>>>>                If (bExists) Begin
77431>>>>>                    Get ReadString of hoRegistry "CurrentVersion" to sVersion
77432>>>>>                End                
77432>>>>>>
77432>>>>>                Send CloseKey of hoRegistry
77433>>>>>            End
77433>>>>>>
77433>>>>>        End
77433>>>>>>
77433>>>>>        Send Destroy of hoRegistry
77434>>>>>
77434>>>>>        If (sVersionDescription <> "") Begin
77436>>>>>           Send AppendTextLn (sVersionDescription * "-" * sVersion)
77437>>>>>           Send AppendTextLn ""
77438>>>>>        End
77438>>>>>>
77438>>>>>    End_Procedure
77439>>>>>    
77439>>>>>
77439>>>>>    Procedure Show_WorkspaceInformation
77441>>>>>        Integer hoWorkspace
77441>>>>>
77441>>>>>        If (ghoApplication <> 0) Begin
77443>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
77444>>>>>            If (hoWorkspace <> 0) Begin
77446>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self (Refproc (AppendTextLn))
77447>>>>>                Send AppendTextLn ""
77448>>>>>            End
77448>>>>>>
77448>>>>>        End
77448>>>>>>
77448>>>>>    End_Procedure
77449>>>>>
77449>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
77451>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
77452>>>>>    End_Function
77453>>>>>
77453>>>>>    Procedure Show_Versions
77455>>>>>        Integer iVersion iRevision iBuild
77455>>>>>
77455>>>>>        Version_Information iVersion iRevision iBuild
77457>>>>>
77457>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(Self,iVersion,iRevision,iBuild) ))
77458>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(Self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
77459>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(Self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
77460>>>>>    End_Procedure
77461>>>>>    
77461>>>>>    Function CKRevisionNumber String sDriverID Returns String
77463>>>>>        Handle hoCLIHandler
77463>>>>>        Handle hoDFBtrDrvHandler
77463>>>>>        String sCKRevision
77463>>>>>
77463>>>>>
77463>>>>>        If (sDriverID = "MSSQLDRV" or sDriverID = "ODBC_DRV" or sDriverID = "DB2_DRV") Begin
77465>>>>>            Get Create (RefClass(cCLIHandler)) to hoCLIHandler
77466>>>>>            Set psDriverID of hoCLIHandler to sDriverID
77467>>>>>            Move (CKRevision(hoCLIHandler)) to sCKRevision
77468>>>>>            Send Destroy of hoCLIHandler
77469>>>>>        End
77469>>>>>>
77469>>>>>        Else Begin
77470>>>>>            If (sDriverID = "DFBTRDRV") Begin
77472>>>>>                Get Create (RefClass(cDFBtrDrvHandler)) to hoDFBtrDrvHandler
77473>>>>>                Set psDriverID of hoDFBtrDrvHandler to sDriverID
77474>>>>>                Move (CKRevision(hoDFBtrDrvHandler)) to sCKRevision
77475>>>>>                Send Destroy of hoDFBtrDrvHandler
77476>>>>>            End
77476>>>>>>
77476>>>>>        End
77476>>>>>>
77476>>>>>        
77476>>>>>        Function_Return sCKRevision
77477>>>>>    End_Function
77478>>>>>    
77478>>>>>    
77478>>>>>    Function IsDataAccessCK String sDriverID Returns Boolean
77480>>>>>        
77480>>>>>        If (sDriverID = "DATAFLEX") Begin
77482>>>>>            Function_Return False
77483>>>>>        End
77483>>>>>>
77483>>>>>    
77483>>>>>        Function_Return (sDriverID = "MSSQLDRV" or sDriverID = "ODBC_DRV" or sDriverID = "DB2_DRV" or sDriverID = "DFBTRDRV")
77484>>>>>    End_Function    
77485>>>>>
77485>>>>>
77485>>>>>    //***
77485>>>>>    //*** BW
77485>>>>>    //*** Procedure: Show_Drivers
77485>>>>>    //*** Purpose  : Show loaded database drivers
77485>>>>>    //***
77485>>>>>
77485>>>>>    Procedure Show_Drivers
77487>>>>>        String sCurrentDriver sRevNumber
77487>>>>>        String sLoadedDrivers
77487>>>>>        Integer iNumberOfDrivers iCount
77487>>>>>        Boolean bOK
77487>>>>>
77487>>>>>        Move "" To sLoadedDrivers
77488>>>>>        Get_Attribute DF_NUMBER_DRIVERS To iNumberOfDrivers
77491>>>>>        For iCount From 1 To iNumberOfDrivers
77497>>>>>>
77497>>>>>            Get_Attribute DF_DRIVER_NAME Of iCount To sCurrentDriver
77500>>>>>            If (sLoadedDrivers <> "") Begin
77502>>>>>                Move (Append (sLoadedDrivers, ", ")) To sLoadedDrivers
77503>>>>>            End
77503>>>>>>
77503>>>>>            Get IsDataAccessCK sCurrentDriver to bOK
77504>>>>>            If (bOK) Begin
77506>>>>>                Get CKRevisionNumber sCurrentDriver to sRevNumber
77507>>>>>                Move (sCurrentDriver * "(" + sRevNumber + ")") to sCurrentDriver
77508>>>>>            End
77508>>>>>>
77508>>>>>            Move (Append (sLoadedDrivers, sCurrentDriver)) To sLoadedDrivers
77509>>>>>        Loop
77510>>>>>>
77510>>>>>        Send AppendTextLn (SFormat (C_$DatabaseDriver, sLoadedDrivers))
77511>>>>>    End_Procedure
77512>>>>>
77512>>>>>    Procedure Show_HelpFile
77514>>>>>        String sHelpFile
77514>>>>>        Integer eHelpType
77514>>>>>
77514>>>>>        If (ghoApplication <> 0) Begin
77516>>>>>            Get peHelpType Of ghoApplication To eHelpType
77517>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
77519>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
77520>>>>>            End
77520>>>>>>
77520>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
77523>>>>>                Get Help_filename Of Help_object_id To sHelpFile
77524>>>>>            End
77524>>>>>>
77524>>>>>            Else Begin
77525>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
77526>>>>>            End
77526>>>>>>
77526>>>>>
77526>>>>>            Send AppendTextLn ""
77527>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
77528>>>>>        End
77528>>>>>>
77528>>>>>    End_Procedure
77529>>>>>
77529>>>>>    Procedure Show_EnterAsTab
77531>>>>>        Boolean bEnterKeyAsTabKey
77531>>>>>        String sText
77531>>>>>
77531>>>>>        If (ghoApplication <> 0) Begin
77533>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
77534>>>>>            If (bEnterKeyAsTabKey) Begin
77536>>>>>                Move "True" To sText
77537>>>>>            End
77537>>>>>>
77537>>>>>            Else Begin
77538>>>>>                Move "False" To sText
77539>>>>>            End
77539>>>>>>
77539>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
77540>>>>>        End
77540>>>>>>
77540>>>>>    End_Procedure
77541>>>>>
77541>>>>>    //****************************************************************************
77541>>>>>    // $Module type: PROCEDURE
77541>>>>>    // $Module name: Add_Focus
77541>>>>>    // $Author     : VOO
77541>>>>>    // Created     : 24-09-96 @ 19:43
77541>>>>>    //
77541>>>>>    // Description
77541>>>>>    //    During activation we will remove the old information and add the newly
77541>>>>>    //    found systeminformation
77541>>>>>    //
77541>>>>>    // $Rev History
77541>>>>>    //    24-09-96  Module header created
77541>>>>>    //****************************************************************************
77541>>>>>    Procedure Add_Focus Integer hoRoot
77543>>>>>        Forward Send Add_Focus hoRoot
77545>>>>>
77545>>>>>        Send Delete_Data
77546>>>>>
77546>>>>>        Set Changed_State To False
77547>>>>>        Set Read_Only_State To True
77548>>>>>
77548>>>>>        Send Show_ServicePack
77549>>>>>        Send Show_Versions   
77550>>>>>        Send Show_Drivers         
77551>>>>>        Send Show_HelpFile
77552>>>>>        Send Show_Current_Directory
77553>>>>>        Send Show_Filelist_Name          
77554>>>>>        If (ghoApplication <> 0) Begin
77556>>>>>            Send Show_WorkSpaceInformation // added To show WS info
77557>>>>>        End
77557>>>>>>
77557>>>>>        Send Show_Current_User 
77558>>>>>        Send Show_Windows_Directory 
77559>>>>>        Send Show_Screen_Size
77560>>>>>        Send Show_Page_Size
77561>>>>>        Send Show_EnterAsTab        
77562>>>>>        Send Show_Number_Format
77563>>>>>        Send Show_Date_Format
77564>>>>>        Send Show_Lock_Delay
77565>>>>>        Send Show_Lock_Timeout
77566>>>>>        Send Show_Date
77567>>>>>        Send Show_Systemresources
77568>>>>>        Send Show_Registration
77569>>>>>        Send Beginning_of_Data
77570>>>>>
77570>>>>>        Set Icon to 'default.ico'
77571>>>>>    End_Procedure
77572>>>>>End_Class
77573>>>>>
77573>>>>>//****************************************************************************
77573>>>>>// $Module type: OBJECT
77573>>>>>// $Module name: Sysinfo_Dialog
77573>>>>>// $Author     : VOO
77573>>>>>// Created     : 24-09-96 @ 18:47
77573>>>>>//
77573>>>>>// Description
77573>>>>>//    This object shows the systeminformation on the screen
77573>>>>>//
77573>>>>>// $Rev History
77573>>>>>//    24-09-96  Module header created
77573>>>>>//****************************************************************************
77573>>>>>Class SysInfoDialog Is A ModalPanel
77574>>>>>    Procedure Construct_Object
77576>>>>>        Forward Send Construct_Object
77578>>>>>
77578>>>>>        Set Label to C_$SystemInformation
77579>>>>>        Set Size to 140 267
77580>>>>>        Set piMinSize to 140 267
77581>>>>>        Set Locate_Mode To CENTER_ON_SCREEN
77582>>>>>        Set Border_Style to Border_Thick
77583>>>>>
77583>>>>>        Object oSysinfoDisplay Is A SysInfoDisplay
77585>>>>>            Set peAnchors to anAll
77586>>>>>        End_Object
77587>>>>>
77587>>>>>        Object oCloseButton Is A Button
77589>>>>>            Set Label To C_$Close
77590>>>>>            Set Location To 120 210
77591>>>>>            Set Message Item 0 To (Refproc (Close_Panel))
77592>>>>>            Set Default_State To True
77593>>>>>            Set peAnchors to anBottomRight
77594>>>>>        End_Object
77595>>>>>
77595>>>>>        On_Key kCancel Send Close_Panel
77596>>>>>    End_Procedure
77597>>>>>End_Class
77598>>>>>
77598>>>>>// Purpose:
77598>>>>>//
77598>>>>>// Ken Ross 12/17/96 5:16PM
77598>>>>>//
77598>>>>>Class AboutDialog Is A ModalPanel
77599>>>>>    Procedure Construct_Object
77601>>>>>        String sVdfRootDir
77601>>>>>
77601>>>>>        Forward Send Construct_Object
77603>>>>>
77603>>>>>        Set Label To C_$About
77604>>>>>        Set Size to 89 212
77605>>>>>        Set Locate_Mode To CENTER_ON_SCREEN
77606>>>>>
77606>>>>>        Object oSysInfoDialog Is A SysInfoDialog
77608>>>>>        End_Object
77609>>>>>
77609>>>>>        Object oBox Is A Container3d
77611>>>>>            Set Border_Style To Border_StaticEdge
77612>>>>>            Set Size to 63 202
77613>>>>>            Set Location To 4 5
77614>>>>>
77614>>>>>            Object oAboutGraphic Is A BitmapContainer
77616>>>>>                Set Border_Style To Border_None
77617>>>>>                Set Bitmap_Style To Bitmap_Center
77618>>>>>                Set Size To 48 48
77619>>>>>                Set Location To 7 2
77620>>>>>            End_Object
77621>>>>>
77621>>>>>            Object oProductName Is A TextBox
77623>>>>>                Set Label To C_$ProductName
77624>>>>>                Set Size To 10 45
77625>>>>>                Set Location To 8 53
77626>>>>>            End_Object
77627>>>>>
77627>>>>>            Object oVersion Is A TextBox
77629>>>>>                Set Label To C_$Version
77630>>>>>                Set Size To 10 25
77631>>>>>                Set Location To 21 53
77632>>>>>            End_Object
77633>>>>>
77633>>>>>            Object oCopyright Is A TextBox
77635>>>>>                Set Label To C_$Copyright
77636>>>>>                Set Size To 10 31
77637>>>>>                Set Location To 34 53
77638>>>>>            End_Object
77639>>>>>
77639>>>>>            Object oAuthor Is A TextBox
77641>>>>>                Set Label To C_$Author
77642>>>>>                Set Size To 10 22
77643>>>>>                Set Location To 46 53
77644>>>>>            End_Object
77645>>>>>        End_Object
77646>>>>>
77646>>>>>        Object oOKButton Is A Button
77648>>>>>            On_Item C_$OK Send Close_Panel
77649>>>>>            Set Size To 14 50
77650>>>>>            Set Location To 71 157
77651>>>>>        End_Object
77652>>>>>
77652>>>>>        Object oSysInfoButton Is A Button
77654>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
77655>>>>>            Set Size To 14 50
77656>>>>>            Set Location To 71 101
77657>>>>>        End_Object
77658>>>>>
77658>>>>>        On_Key Kcancel Send KeyAction Of oOKButton
77659>>>>>
77659>>>>>        Set Logo To "DacAbout.bmp"  // square bitmaps Of 42x42 work best
77660>>>>>    End_Procedure
77661>>>>>
77661>>>>>    Procedure Set ProductName String sProductName
77663>>>>>        Set Label Of oProductName To sProductName
77664>>>>>    End_Procedure
77665>>>>>
77665>>>>>    Procedure Set Version String sVersion
77667>>>>>        Set Label Of oVersion To sVersion
77668>>>>>    End_Procedure
77669>>>>>
77669>>>>>    Procedure Set Copyright string sCopyright
77671>>>>>        Set Label Of oCopyright To sCopyright
77672>>>>>    End_Procedure
77673>>>>>
77673>>>>>    Procedure Set Author String sAuthor
77675>>>>>        Set Label Of oAuthor To sAuthor
77676>>>>>    End_Procedure
77677>>>>>
77677>>>>>    Procedure Set Logo string sLogo
77679>>>>>        // square bitmaps Of 42x42 work best
77679>>>>>        Set Bitmap Of oAboutGraphic To sLogo
77680>>>>>    End_Procedure
77681>>>>>
77681>>>>>    Procedure Show_Sysinfo
77683>>>>>        Send Popup_Modal Of oSysinfoDialog
77684>>>>>    End_Procedure
77685>>>>>
77685>>>>>    Procedure End_Construct_Object
77687>>>>>        Handle hoVersionInfo
77687>>>>>        Boolean bIncluded
77687>>>>>        Integer iMajor iMinor iRelease iBuild
77687>>>>>        String sLabel
77687>>>>>
77687>>>>>        Get Label Of oVersion To sLabel
77688>>>>>        If (sLabel = C_$VERSION) Begin
77690>>>>>            // set it To the version info Of the program, if available
77690>>>>>            If (ghoApplication <> 0) Begin
77692>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
77693>>>>>                If (hoVersionInfo <> 0) Begin
77695>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
77696>>>>>                    If (bIncluded) Begin
77698>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
77699>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
77700>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
77701>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
77702>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sLabel
77703>>>>>                        Set Version to sLabel
77704>>>>>                    End
77704>>>>>>
77704>>>>>                End
77704>>>>>>
77704>>>>>            End
77704>>>>>>
77704>>>>>        End
77704>>>>>>
77704>>>>>
77704>>>>>        Forward Send End_Construct_Object
77706>>>>>    End_Procedure
77707>>>>>End_Class
77708>>>
77708>>>// *************************************************************************
77708>>>//  Public message. This is the default message. It is expected that you will
77708>>>//   create your own message to override this
77708>>>// *************************************************************************
77708>>>
77708>>>Procedure Activate_About
77711>>>   Send DoAbout "" "" "" "" ""
77712>>>End_Procedure
77713>>>
77713>>>// *************************************************************************
77713>>>//  Public message. It is expected that you will send this message (most
77713>>>//  likely from Activate_About. This creates an about object, activates it
77713>>>//  and destroys it when done. It is not exepected that you will augment this.
77713>>>// *************************************************************************
77713>>>
77713>>>Procedure DoAbout string sTitle string sVersion string sCopyRight string sAuthor string sBitmap
77716>>>        integer hoObj hoMain
77716>>>
77716>>>        // create object
77716>>>        Object About is an AboutDialog
77718>>>            // if no title passed use the label of the main panel
77718>>>            // (if a main panel exists).
77718>>>            if sTitle     eq '' Begin
77720>>>                Get Main_Window of desktop to hoMain
77721>>>                if hoMain Get Label of hoMain to sTitle
77724>>>            end
77724>>>>
77724>>>            set productname to sTitle
77725>>>            set version     to sVersion
77726>>>            set copyright   to sCopyRight
77727>>>            set author      to sAuthor
77728>>>            If sBitmap    ne '' ;               set logo to sBitMap // square bitmaps of 42x42 work best
77731>>>            Move self to hoObj // object Id
77732>>>        End_Object
77733>>>        Send Popup   of hoObj    // popup the about object
77734>>>        Send Destroy of hoObj // when done, it will be destroyed
77735>>>End_procedure
77736>        Use RegistroEmpleado.vw
Including file: RegistroEmpleado.vw    (C:\DataFlex Projects\Control Marcajes\AppSrc\RegistroEmpleado.vw)
77736>>>Use Windows.pkg
77736>>>Use DFClient.pkg
77736>>>Use cNacionalidadDataDictionary.dd
Including file: cNacionalidadDataDictionary.dd    (C:\DataFlex Projects\Control Marcajes\DDSrc\cNacionalidadDataDictionary.dd)
77736>>>>>Use DataDict.pkg
77736>>>>>
77736>>>>>Open Nacionalidad
Including file: Nacionalidad.fd    (C:\DataFlex Projects\Control Marcajes\DDSrc\Nacionalidad.fd)
77738>>>>>Open Empleado
Including file: Empleado.fd    (C:\DataFlex Projects\Control Marcajes\DDSrc\Empleado.fd)
77740>>>>>Open Autoincrementable
Including file: Autoincrementable.fd    (C:\DataFlex Projects\Control Marcajes\DDSrc\Autoincrementable.fd)
77742>>>>>
77742>>>>>Register_Object ListadoNacionalidades
77742>>>>>
77742>>>>>Class cNacionalidadDataDictionary is a DataDictionary
77743>>>>>    
77743>>>>>    Procedure Construct_Object
77745>>>>>        Forward Send Construct_Object
77747>>>>>        Set Main_File to Nacionalidad.File_Number
77748>>>>>
77748>>>>>        Set Add_System_File to Autoincrementable.File_Number DD_Lock_On_All
77749>>>>>
77749>>>>>        Set Add_Client_File to Empleado.File_Number
77750>>>>>
77750>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_NOPUT to True
77751>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
77752>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
77753>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
77754>>>>>
77754>>>>>        Set Field_Option Field Nacionalidad.Numero DD_AUTOFIND to True
77755>>>>>        Set Key_Field_State Field Nacionalidad.Numero to True
77756>>>>>        Set Field_Auto_Increment Field Nacionalidad.Numero to File_Field Autoincrementable.NumNacionalidad
77757>>>>>
77757>>>>>        Set Field_Option Field Nacionalidad.Pais DD_AUTOFIND to True
77758>>>>>        Set Field_Option Field Nacionalidad.Pais DD_CAPSLOCK to True
77759>>>>>        Set Field_Option Field Nacionalidad.Pais DD_REQUIRED to True
77760>>>>>        
77760>>>>>
77760>>>>>    End_Procedure
77761>>>>>
77761>>>>>End_Class
77762>>>>>
77762>>>>>
77762>>>Use cEmpleadoDataDictionary.dd
Including file: cEmpleadoDataDictionary.dd    (C:\DataFlex Projects\Control Marcajes\DDSrc\cEmpleadoDataDictionary.dd)
77762>>>>>Use DataDict.pkg
77762>>>>>
77762>>>>>Open Empleado
77764>>>>>Open Nacionalidad
77766>>>>>Open Marcaje
Including file: Marcaje.fd    (C:\DataFlex Projects\Control Marcajes\DDSrc\Marcaje.fd)
77768>>>>>Open Autoincrementable
77770>>>>>
77770>>>>>Register_Object ListaEmpleado
77770>>>>>Register_Object ListaNacionalidad
77770>>>>>
77770>>>>>Class cEmpleadoDataDictionary is a DataDictionary
77771>>>>>    
77771>>>>>    Procedure Construct_Object
77773>>>>>        Forward Send Construct_Object
77775>>>>>        Set Main_File to Empleado.File_Number
77776>>>>>
77776>>>>>        Set Add_System_File to Autoincrementable.File_Number DD_Lock_On_All
77777>>>>>
77777>>>>>        Set Add_Client_File to Marcaje.File_Number
77778>>>>>
77778>>>>>        Set Add_Server_File to Nacionalidad.File_Number
77779>>>>>
77779>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_NOPUT to True
77780>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
77781>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
77782>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
77783>>>>>
77783>>>>>        Set Field_Option Field Empleado.Numero DD_AUTOFIND to True
77784>>>>>        Set Key_Field_State Field Empleado.Numero to True
77785>>>>>        Set Field_Auto_Increment Field Empleado.Numero to File_Field Autoincrementable.NumEmpleado
77786>>>>>        Set Field_Prompt_Object Field Empleado.Numero to ListaEmpleado
77787>>>>>
77787>>>>>        Set Field_Option Field Empleado.PrimerNombre DD_CAPSLOCK to True
77788>>>>>        Set Field_Option Field Empleado.PrimerNombre DD_REQUIRED to True
77789>>>>>        Set Field_Option Field Empleado.PrimerNombre DD_AUTOFIND to True
77790>>>>>
77790>>>>>        Set Field_Option Field Empleado.SegundoNombre DD_AUTOFIND to True
77791>>>>>        Set Field_Option Field Empleado.SegundoNombre DD_CAPSLOCK to True
77792>>>>>        Set Field_Option Field Empleado.SegundoNombre DD_REQUIRED to True
77793>>>>>
77793>>>>>        Set Field_Option Field Empleado.PrimerApellido DD_AUTOFIND to True
77794>>>>>        Set Field_Option Field Empleado.PrimerApellido DD_CAPSLOCK to True
77795>>>>>        Set Field_Option Field Empleado.PrimerApellido DD_REQUIRED to True
77796>>>>>
77796>>>>>        Set Field_Option Field Empleado.SegundoApellido DD_AUTOFIND to True
77797>>>>>        Set Field_Option Field Empleado.SegundoApellido DD_CAPSLOCK to True
77798>>>>>        Set Field_Option Field Empleado.SegundoApellido DD_REQUIRED to True
77799>>>>>
77799>>>>>         
77799>>>>>        Set Field_Option Field Empleado.Nacionalidad DD_AUTOFIND to True
77800>>>>>        Set Field_Prompt_Object Field Empleado.Nacionalidad to ListaNacionalidad
77801>>>>>        Set Field_Option Field Empleado.Nacionalidad DD_CAPSLOCK to True
77802>>>>>        Set Field_Option Field Empleado.Nacionalidad DD_REQUIRED to True
77803>>>>>        
77803>>>>>       
77803>>>>>        
77803>>>>>         
77803>>>>>
77803>>>>>    End_Procedure
77804>>>>>
77804>>>>>End_Class
77805>>>>>
77805>>>>>Use ListaNacionalidad.sl
Including file: ListaNacionalidad.sl    (C:\DataFlex Projects\Control Marcajes\AppSrc\ListaNacionalidad.sl)
77805>>>>>>>//**************************************************************
77805>>>>>>>// TableLookup.tpl for Windows application for Spanish 
77805>>>>>>>// translated by Moose Software (www.moose-software.com) 
77805>>>>>>>// 13/07/2010 Revised for VDF 16.0 by Moose Software
77805>>>>>>>// 05/02/2012 Revised for VDF 17.0 by Moose Software
77805>>>>>>>// 13/06/2013 Revised for VDF 17.1 by Moose Software
77805>>>>>>>// 02/05/2014 Revised for VDF 18.0 by Moose Software
77805>>>>>>>//*************************************************************
77805>>>>>>>
77805>>>>>>>Use Windows.pkg
77805>>>>>>>Use DFClient.pkg
77805>>>>>>>use DFSellst.pkg
77805>>>>>>>Use cNacionalidadDataDictionary.dd
77805>>>>>>>
77805>>>>>>>Object ListaNacionalidad is a dbModalPanel
77807>>>>>>>    Object oNacionalidad_DD is a cNacionalidadDataDictionary
77809>>>>>>>    End_Object
77810>>>>>>>
77810>>>>>>>    Set Main_DD to oNacionalidad_DD
77811>>>>>>>    Set Server to oNacionalidad_DD
77812>>>>>>>
77812>>>>>>>    Set Size to 133 292
77813>>>>>>>    Set Location     to 4 5
77814>>>>>>>    Set Border_Style to Border_Thick
77815>>>>>>>    Set Label to "Lista de Nacionalidades"
77816>>>>>>>
77816>>>>>>>    Object oSelList is a dbList
77818>>>>>>>        Set peAnchors to anAll
77819>>>>>>>        Set Size      to 105 280
77820>>>>>>>        Set Location  to 6 6
77821>>>>>>>
77821>>>>>>>        Begin_Row
77824>>>>>>>            Entry_Item Nacionalidad.Numero
77825>>>>>>>            Entry_Item Nacionalidad.Pais
77826>>>>>>>        End_Row
77831>>>>>>>
77831>>>>>>>        Set Main_File to Nacionalidad.File_Number
77832>>>>>>>
77832>>>>>>>        Set Form_Width 0 to 84
77833>>>>>>>        Set Header_Label 0 to "Numero"
77834>>>>>>>        Set Form_Width 1 to 270
77835>>>>>>>        Set Header_Label 1 to "Pais"
77836>>>>>>>    End_Object
77837>>>>>>>
77837>>>>>>>    Object oOK_bn is a Button
77839>>>>>>>        Set Label     to "&Aceptar"
77840>>>>>>>        Set Location  to 115 128
77841>>>>>>>        Set peAnchors to anBottomRight
77842>>>>>>>
77842>>>>>>>        Procedure OnClick
77845>>>>>>>            Send Ok of oSelList
77846>>>>>>>        End_Procedure
77847>>>>>>>
77847>>>>>>>    End_Object
77848>>>>>>>
77848>>>>>>>    Object oCancel_bn is a Button
77850>>>>>>>        Set Label     to "&Cancelar"
77851>>>>>>>        Set Location  to 115 182
77852>>>>>>>        Set peAnchors to anBottomRight
77853>>>>>>>
77853>>>>>>>        Procedure OnClick
77856>>>>>>>            Send Cancel of oSelList
77857>>>>>>>        End_Procedure
77858>>>>>>>
77858>>>>>>>    End_Object
77859>>>>>>>
77859>>>>>>>    Object oSearch_bn is a Button
77861>>>>>>>        Set Label     to "&Buscar..."
77862>>>>>>>        Set Location  to 115 236
77863>>>>>>>        Set peAnchors to anBottomRight
77864>>>>>>>
77864>>>>>>>        Procedure OnClick
77867>>>>>>>            Send Search of oSelList
77868>>>>>>>        End_Procedure
77869>>>>>>>
77869>>>>>>>    End_Object
77870>>>>>>>
77870>>>>>>>    On_Key Key_Alt+Key_A Send KeyAction of oOk_bn
77871>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_bn
77872>>>>>>>    On_Key Key_Alt+Key_B Send KeyAction of oSearch_bn
77873>>>>>>>
77873>>>>>>>End_Object
77874>>>>>>>
77874>>>>>>>//*********************************************** end of TableLookup.tpl for Spanish ****************
77874>>>>>>>
77874>>>>>
77874>>>>>Use ListaEmpleado.sl
Including file: ListaEmpleado.sl    (C:\DataFlex Projects\Control Marcajes\AppSrc\ListaEmpleado.sl)
77874>>>>>>>//**************************************************************
77874>>>>>>>// TableLookup.tpl for Windows application for Spanish 
77874>>>>>>>// translated by Moose Software (www.moose-software.com) 
77874>>>>>>>// 13/07/2010 Revised for VDF 16.0 by Moose Software
77874>>>>>>>// 05/02/2012 Revised for VDF 17.0 by Moose Software
77874>>>>>>>// 13/06/2013 Revised for VDF 17.1 by Moose Software
77874>>>>>>>// 02/05/2014 Revised for VDF 18.0 by Moose Software
77874>>>>>>>//*************************************************************
77874>>>>>>>
77874>>>>>>>Use Windows.pkg
77874>>>>>>>Use DFClient.pkg
77874>>>>>>>use DFSellst.pkg
77874>>>>>>>Use cNacionalidadDataDictionary.dd
77874>>>>>>>Use cEmpleadoDataDictionary.dd
77874>>>>>>>
77874>>>>>>>Object ListaEmpleado is a dbModalPanel
77876>>>>>>>    Object oNacionalidad_DD is a cNacionalidadDataDictionary
77878>>>>>>>    End_Object
77879>>>>>>>
77879>>>>>>>    Object oEmpleado_DD is a cEmpleadoDataDictionary
77881>>>>>>>        Set DDO_Server to oNacionalidad_DD
77882>>>>>>>    End_Object
77883>>>>>>>
77883>>>>>>>    Set Main_DD to oEmpleado_DD
77884>>>>>>>    Set Server to oEmpleado_DD
77885>>>>>>>
77885>>>>>>>    Set Size to 133 455
77886>>>>>>>    Set Location     to 4 5
77887>>>>>>>    Set Border_Style to Border_Thick
77888>>>>>>>    Set Label to "Lista de Empleado"
77889>>>>>>>
77889>>>>>>>    Object oSelList is a dbList
77891>>>>>>>        Set peAnchors to anAll
77892>>>>>>>        Set Size to 105 443
77893>>>>>>>        Set Location  to 6 6
77894>>>>>>>
77894>>>>>>>        Begin_Row
77897>>>>>>>            Entry_Item Empleado.Numero
77898>>>>>>>            Entry_Item Empleado.PrimerNombre
77899>>>>>>>            Entry_Item Empleado.SegundoNombre
77900>>>>>>>            Entry_Item Empleado.PrimerApellido
77901>>>>>>>            Entry_Item Empleado.SegundoApellido
77902>>>>>>>            Entry_Item Nacionalidad.Pais
77903>>>>>>>        End_Row
77908>>>>>>>
77908>>>>>>>        Set Main_File to Empleado.File_Number
77909>>>>>>>
77909>>>>>>>        Set Form_Width 0 to 24
77910>>>>>>>        Set Header_Label 0 to "#"
77911>>>>>>>        Set Form_Width 1 to 60
77912>>>>>>>        Set Header_Label 1 to "Primer Nombre"
77913>>>>>>>        Set Form_Width 2 to 60
77914>>>>>>>        Set Header_Label 2 to "Segundo Nombre"
77915>>>>>>>        Set Form_Width 3 to 60
77916>>>>>>>        Set Header_Label 3 to "Primer Apellido"
77917>>>>>>>        Set Form_Width 4 to 60
77918>>>>>>>        Set Header_Label 4 to "Segundo Apellido"
77919>>>>>>>        Set Form_Width 5 to 60
77920>>>>>>>        Set Header_Label 5 to "Pais"
77921>>>>>>>    End_Object
77922>>>>>>>
77922>>>>>>>    Object oOK_bn is a Button
77924>>>>>>>        Set Label     to "&Aceptar"
77925>>>>>>>        Set Location to 115 291
77926>>>>>>>        Set peAnchors to anBottomRight
77927>>>>>>>
77927>>>>>>>        Procedure OnClick
77930>>>>>>>            Send Ok of oSelList
77931>>>>>>>        End_Procedure
77932>>>>>>>
77932>>>>>>>    End_Object
77933>>>>>>>
77933>>>>>>>    Object oCancel_bn is a Button
77935>>>>>>>        Set Label     to "&Cancelar"
77936>>>>>>>        Set Location to 115 345
77937>>>>>>>        Set peAnchors to anBottomRight
77938>>>>>>>
77938>>>>>>>        Procedure OnClick
77941>>>>>>>            Send Cancel of oSelList
77942>>>>>>>        End_Procedure
77943>>>>>>>
77943>>>>>>>    End_Object
77944>>>>>>>
77944>>>>>>>    Object oSearch_bn is a Button
77946>>>>>>>        Set Label     to "&Buscar..."
77947>>>>>>>        Set Location to 115 399
77948>>>>>>>        Set peAnchors to anBottomRight
77949>>>>>>>
77949>>>>>>>        Procedure OnClick
77952>>>>>>>            Send Search of oSelList
77953>>>>>>>        End_Procedure
77954>>>>>>>
77954>>>>>>>    End_Object
77955>>>>>>>
77955>>>>>>>    On_Key Key_Alt+Key_A Send KeyAction of oOk_bn
77956>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_bn
77957>>>>>>>    On_Key Key_Alt+Key_B Send KeyAction of oSearch_bn
77958>>>>>>>
77958>>>>>>>End_Object
77959>>>>>>>
77959>>>>>>>//*********************************************** end of TableLookup.tpl for Spanish ****************
77959>>>>>>>
77959>>>Use DFEntry.pkg
77959>>>Use cDbCJGrid.pkg
77959>>>Use cdbCJGridColumn.pkg
77959>>>Use cDbCJGridColumnSuggestion.pkg
Including file: cDbCJGridColumnSuggestion.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cDbCJGridColumnSuggestion.pkg)
77959>>>>>Use WinSuggestion.pkg
Including file: WinSuggestion.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\WinSuggestion.pkg)
77959>>>>>>>// 
77959>>>>>>>
77959>>>>>>>Use Windows.pkg
77959>>>>>>>Use tWinStructs.pkg
77959>>>>>>>Use tSuggestion.pkg
Including file: tSuggestion.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\tSuggestion.pkg)
77959>>>>>>>>>// struct used for suggestion forms, representing an item of data
77959>>>>>>>>>Enum_List 
77959>>>>>>>>>    Define smFind
77959>>>>>>>>>    Define smValidationTable
77959>>>>>>>>>    Define smCustom
77959>>>>>>>>>End_Enum_List
77959>>>>>>>>>
77959>>>>>>>>>Struct tSuggestion
77959>>>>>>>>>    String sRowId
77959>>>>>>>>>    String[] aValues
77959>>>>>>>>>End_Struct
77959>>>>>>>>>
77959>>>>>>>Use cTimer.pkg
Including file: cTimer.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cTimer.pkg)
77959>>>>>>>>>// cTimer class
77959>>>>>>>>>//
77959>>>>>>>>>// This supercedes the DFTimer class. 
77959>>>>>>>>>// It is simpler and more flexible
77959>>>>>>>>>
77959>>>>>>>>>Use Dftimer.pkg // we still use the Timer Manager classes and global objects
Including file: Dftimer.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\Dftimer.pkg)
77959>>>>>>>>>>>//************************************************************************
77959>>>>>>>>>>>//--- DFTimer   Timer package for DataFlex programs
77959>>>>>>>>>>>//
77959>>>>>>>>>>>// Copyright (c) 1983-2002 Data Access Corporation, Miami Florida,
77959>>>>>>>>>>>// All rights reserved.
77959>>>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
77959>>>>>>>>>>>//
77959>>>>>>>>>>>//************************************************************************
77959>>>>>>>>>>>//  Description:
77959>>>>>>>>>>>//      This package contains all components needed to implement timers
77959>>>>>>>>>>>//      in a DataFlex 4 program.
77959>>>>>>>>>>>//
77959>>>>>>>>>>>//
77959>>>>>>>>>>>//  Author: Eddy Kleinjan, Data Access Nederland
77959>>>>>>>>>>>//************************************************************************
77959>>>>>>>>>>>// 03/03/2001 EK  Fixed Timer_Active_State to check for valid windows
77959>>>>>>>>>>>//                handle before trying to set or kill a timer.
77959>>>>>>>>>>>//                Fixed Kill_All_Timers to check for valid windows
77959>>>>>>>>>>>//                handle before trying to kill a timer.
77959>>>>>>>>>>>//                The windows handle might not exist anymore when the
77959>>>>>>>>>>>//                program is being exited using Exit_Application.
77959>>>>>>>>>>>// 12/13/2001 JJT fixed Timer_Active_State to check for -1 (not 0). Fixed a
77959>>>>>>>>>>>//                a bug where set Timeout started inactive timers.
77959>>>>>>>>>>>//                Added code to force timer object to desktop
77959>>>>>>>>>>>//************************************************************************
77959>>>>>>>>>>>// CLASS DFTimer
77959>>>>>>>>>>>//
77959>>>>>>>>>>>// Usage:
77959>>>>>>>>>>>//    Object MyTimer is a DFTimer
77959>>>>>>>>>>>//
77959>>>>>>>>>>>//        Set Timeout to 2000                             // Default 1000
77959>>>>>>>>>>>//        Set Auto_Start_State to TRUE|FALSE              // Default TRUE
77959>>>>>>>>>>>//        Set Auto_Stop_State to TRUE|FALSE               // Default TRUE
77959>>>>>>>>>>>//        Set Timer_Message to MyMessage                  // Default 0
77959>>>>>>>>>>>//        Set Timer_Object to (MyObject(self))            // Default 0
77959>>>>>>>>>>>//        Set Timer_Active_State to TRUE|FALSE            // Default FALSE
77959>>>>>>>>>>>//
77959>>>>>>>>>>>//        // Augment when no Timer_Message
77959>>>>>>>>>>>//        Procedure OnTimer
77959>>>>>>>>>>>//            Send Info_Box "HEY, WAKE UP!"
77959>>>>>>>>>>>//        End_Procedure
77959>>>>>>>>>>>//
77959>>>>>>>>>>>//    End_Object
77959>>>>>>>>>>>//
77959>>>>>>>>>>>// DESCRIPTION
77959>>>>>>>>>>>//      Objects of this class can be used to trigger an event after a
77959>>>>>>>>>>>//      certain amount of time has passed. You can specify this time
77959>>>>>>>>>>>//      by setting the Timeout property of the object. This timeout
77959>>>>>>>>>>>//      is in miliseconds.
77959>>>>>>>>>>>//
77959>>>>>>>>>>>//      Whenever a timer event happens, it will notify the object by
77959>>>>>>>>>>>//      sending an OnTimer event. You can trap this event to do whatever
77959>>>>>>>>>>>//      you want the timer to do. By default this OnTimer event
77959>>>>>>>>>>>//      will send the Timer_Message to Timer_Object, when these have
77959>>>>>>>>>>>//      been specified.
77959>>>>>>>>>>>//
77959>>>>>>>>>>>//      By default, you have to activate a timer by setting its
77959>>>>>>>>>>>//      Timer_Active_State to TRUE. When the timer has been placed
77959>>>>>>>>>>>//      inside a user-interface object, it can also be activated
77959>>>>>>>>>>>//      automatically when this user-interface object is being
77959>>>>>>>>>>>//      activated. This only happes when it Auto_Start_State is TRUE,
77959>>>>>>>>>>>//      which is the default setting. In such a case, the timer will
77959>>>>>>>>>>>//      also automatically being stopped when the user-interface
77959>>>>>>>>>>>//      object is taken of the screen. This depends on the
77959>>>>>>>>>>>//      Auto_Stop_Timer state to happen.
77959>>>>>>>>>>>//
77959>>>>>>>>>>>//      When you need to set a new timeout value, you can do so
77959>>>>>>>>>>>//      even when the timer is active. It will adjust the timeout
77959>>>>>>>>>>>//      immediately.
77959>>>>>>>>>>>//
77959>>>>>>>>>>>//      Note that timer events depend on Windows for the delivery of
77959>>>>>>>>>>>//      the event. Since timer events get a low priority in Windows,
77959>>>>>>>>>>>//      it might put your program on hold when other programs are very
77959>>>>>>>>>>>//      busy. In such a case, you will only receive one timer event
77959>>>>>>>>>>>//      after the process stopped. There is no way, other than
77959>>>>>>>>>>>//      calculating it yourself, to determine how many time has passed
77959>>>>>>>>>>>//      or how many timer event should have happened since the last
77959>>>>>>>>>>>//      timer event or timer activation.
77959>>>>>>>>>>>//
77959>>>>>>>>>>>// PUBLIC INTERFACE
77959>>>>>>>>>>>//
77959>>>>>>>>>>>//    PROPERTIES
77959>>>>>>>>>>>//
77959>>>>>>>>>>>//    Auto_Start_State When TRUE (default) the timer will be activated
77959>>>>>>>>>>>//                     automatically when the object will be (virtually)
77959>>>>>>>>>>>//                     paged on the screen.
77959>>>>>>>>>>>//                     Example: When a timer object has been placed
77959>>>>>>>>>>>//                     inside a view, then the timer will be activated
77959>>>>>>>>>>>//                     when the view is activated.
77959>>>>>>>>>>>//
77959>>>>>>>>>>>//    Auto_Stop_State  When TRUE (default) the timer will be deactivated
77959>>>>>>>>>>>//                     automatically when the object will be (virtually)
77959>>>>>>>>>>>//                     taken off the screen.
77959>>>>>>>>>>>//
77959>>>>>>>>>>>//    Timeout          The timeout value for the timer to fire. The
77959>>>>>>>>>>>//                     timeout value must be set in miliseconds.
77959>>>>>>>>>>>//                     This property may be set even when the timer is
77959>>>>>>>>>>>//                     active. The new timeout value will be applied
77959>>>>>>>>>>>//                     immediately.
77959>>>>>>>>>>>//                     NOTE: The timeout set here is never precise. It
77959>>>>>>>>>>>//                     depends on Windows to deliver the message to our
77959>>>>>>>>>>>//                     application.
77959>>>>>>>>>>>//                     Default 1000.
77959>>>>>>>>>>>//
77959>>>>>>>>>>>//    Timer_Active_State
77959>>>>>>>>>>>//                     Set to TRUE to activate the timer, to FALSE to
77959>>>>>>>>>>>//                     deactivate the timer.
77959>>>>>>>>>>>//
77959>>>>>>>>>>>//
77959>>>>>>>>>>>//    Timer_Message    This property can be set to a messageID which has
77959>>>>>>>>>>>//                     to be sent whenever a timer event occurs. Default
77959>>>>>>>>>>>//                     this message will be send to the object itself
77959>>>>>>>>>>>//                     unless a Timer_Object as been specified.
77959>>>>>>>>>>>//
77959>>>>>>>>>>>//    Timer_Object     This property can be set to an objectID which has
77959>>>>>>>>>>>//                     to receive the Timer_Message whenever a timer
77959>>>>>>>>>>>//                     event occurs. This value has no meaning when
77959>>>>>>>>>>>//                     no Timer_Message has been set.
77959>>>>>>>>>>>//
77959>>>>>>>>>>>//    METHODS
77959>>>>>>>>>>>//
77959>>>>>>>>>>>//    OnTimer          This event will happen whenever the specified
77959>>>>>>>>>>>//                     amount of time has passed and the timer is
77959>>>>>>>>>>>//                     active. By default it sends the message in
77959>>>>>>>>>>>//                     the Timer_Message property to the object in
77959>>>>>>>>>>>//                     the Timer_Object when these have been specified.
77959>>>>>>>>>>>//                     When you don't need this, you can just override
77959>>>>>>>>>>>//                     the OnTimer event.
77959>>>>>>>>>>>//
77959>>>>>>>>>>>// PUBLIC INTERFACE
77959>>>>>>>>>>>//
77959>>>>>>>>>>>//    Page_Object      Has been augmented to auto_start the timer when
77959>>>>>>>>>>>//                     it becomes active as part or a user-interface
77959>>>>>>>>>>>//                     object.
77959>>>>>>>>>>>//
77959>>>>>>>>>>>//    Page_Delete      Has been augmented to auto_stop the timer when
77959>>>>>>>>>>>//                     it is deactivated as part or a user-interface
77959>>>>>>>>>>>//                     object.
77959>>>>>>>>>>>//
77959>>>>>>>>>>>//    Destroy_Object   Has been augmented to deactivate the timer.
77959>>>>>>>>>>>//
77959>>>>>>>>>>>Use LanguageText.pkg
77959>>>>>>>>>>>Use Windows.pkg
77959>>>>>>>>>>>Use WinUser.pkg
77959>>>>>>>>>>>
77959>>>>>>>>>>>External_Function SetTimer "SetTimer" User32.DLL ;    Integer hWnd ;    Integer idTimer ;    Integer idTimeout ;    Pointer tmprc ;    Returns Integer
77960>>>>>>>>>>>
77960>>>>>>>>>>>External_Function KillTimer "KillTimer" User32.DLL ;    Integer hWnd ;    Integer idTimer ;    Returns Integer
77961>>>>>>>>>>>
77961>>>>>>>>>>>// This global integer holds the ID of the object
77961>>>>>>>>>>>// that manages all timers.
77961>>>>>>>>>>>Integer giTimerManager
77961>>>>>>>>>>>
77961>>>>>>>>>>>// This class is used to store the object IDs
77961>>>>>>>>>>>// of the active timer objects. It augments
77961>>>>>>>>>>>// the Destroy_Object procedure to notify
77961>>>>>>>>>>>// the DFTimerManager to kill all its active
77961>>>>>>>>>>>// timers.
77961>>>>>>>>>>>// NOTE: This class looks very much like the
77961>>>>>>>>>>>// Set class. I didn't want to use Set because
77961>>>>>>>>>>>// Remove_Element shifts items which I don't
77961>>>>>>>>>>>// want to happen because item numbers are used
77961>>>>>>>>>>>// as timerIDs.
77961>>>>>>>>>>>
77961>>>>>>>>>>>Class TimersArray is an Array
77962>>>>>>>>>>>
77962>>>>>>>>>>>    Function Find_Object Integer iObj Returns Integer
77964>>>>>>>>>>>        Integer iMax
77964>>>>>>>>>>>        Integer iItem
77964>>>>>>>>>>>        Integer iValue
77964>>>>>>>>>>>        Get Item_count to iMax
77965>>>>>>>>>>>        Decrement iMax
77966>>>>>>>>>>>        For iItem from 1 to iMax
77972>>>>>>>>>>>>
77972>>>>>>>>>>>            Get Integer_Value item iItem to iValue
77973>>>>>>>>>>>            If iValue EQ iObj;                Function_Return iItem
77976>>>>>>>>>>>        Loop
77977>>>>>>>>>>>>
77977>>>>>>>>>>>        Function_Return -1
77978>>>>>>>>>>>    End_Function
77979>>>>>>>>>>>
77979>>>>>>>>>>>    Procedure Add_Object Integer iObj Returns Integer
77981>>>>>>>>>>>        Integer iItem
77981>>>>>>>>>>>        Get Find_Object iObj to iItem
77982>>>>>>>>>>>        If iItem LT 0 Begin
77984>>>>>>>>>>>            Get Find_Object 0 to iItem
77985>>>>>>>>>>>            If iItem LT 0 ;                Get Item_Count to iItem
77988>>>>>>>>>>>        End
77988>>>>>>>>>>>>
77988>>>>>>>>>>>        Set Array_Value item iItem to iObj
77989>>>>>>>>>>>        Procedure_Return iItem
77990>>>>>>>>>>>    End_Procedure
77991>>>>>>>>>>>
77991>>>>>>>>>>>    Procedure Remove_Object Integer iObj
77993>>>>>>>>>>>        Integer iItem
77993>>>>>>>>>>>        Get Find_Object iObj to iItem
77994>>>>>>>>>>>        If iItem GT 0 ;            Set Array_Value item iItem to 0
77997>>>>>>>>>>>    End_Procedure
77998>>>>>>>>>>>
77998>>>>>>>>>>>    Procedure Destroy_Object
78000>>>>>>>>>>>        Delegate Send Kill_All_Timers
78002>>>>>>>>>>>        Forward Send Destroy_Object
78004>>>>>>>>>>>    End_Procedure
78005>>>>>>>>>>>
78005>>>>>>>>>>>End_Class // TimersArray
78006>>>>>>>>>>>
78006>>>>>>>>>>>// This class is the actual timer manager
78006>>>>>>>>>>>// A timer will be created when Message Set_Timer_Active_State
78006>>>>>>>>>>>// has been send. This message needs two arguments. The first
78006>>>>>>>>>>>// is the objectID of the object to receive the timer event,
78006>>>>>>>>>>>// and the second is state. The object which ID has been passed,
78006>>>>>>>>>>>// needs to have a Timeout property to return the timeout for the
78006>>>>>>>>>>>// timer and it also needs to handle the MSG_OnTimer whenever a
78006>>>>>>>>>>>// timer event occurs.
78006>>>>>>>>>>>// The objectID of the Object will be placed in an array which contains
78006>>>>>>>>>>>// the objectIDs of all active timers. The Windows timer ID of a timer
78006>>>>>>>>>>>// is the itemnumber of the object in the array.
78006>>>>>>>>>>>//
78006>>>>>>>>>>>Class DFTimerManager is a DfBaseControl
78007>>>>>>>>>>>
78007>>>>>>>>>>>    Procedure Construct_Object
78009>>>>>>>>>>>
78009>>>>>>>>>>>        Forward Send Construct_Object
78011>>>>>>>>>>>
78011>>>>>>>>>>>        Set Visible_State to FALSE
78012>>>>>>>>>>>
78012>>>>>>>>>>>        Set External_Class_Name "cVdfTimer" to "static"
78013>>>>>>>>>>>        Set External_Message WM_TIMER to OnTimer
78014>>>>>>>>>>>
78014>>>>>>>>>>>        Object TimersArray is a TimersArray
78016>>>>>>>>>>>            Set Array_Value item 0 to -9999 // So we don't use item 0
78017>>>>>>>>>>>        End_Object
78018>>>>>>>>>>>
78018>>>>>>>>>>>        Move self to giTimerManager
78019>>>>>>>>>>>
78019>>>>>>>>>>>    End_Procedure
78020>>>>>>>>>>>
78020>>>>>>>>>>>    Procedure Set Timer_Active_State Integer iObj Integer iState
78022>>>>>>>>>>>        Integer iTimerID
78022>>>>>>>>>>>        Integer iTimeout
78022>>>>>>>>>>>        Integer iResult
78022>>>>>>>>>>>        Integer iSet
78022>>>>>>>>>>>        Dword   nResult
78022>>>>>>>>>>>        Handle  hWnd
78022>>>>>>>>>>>
78022>>>>>>>>>>>        // Get the handle of this object
78022>>>>>>>>>>>        Get Window_Handle to hWnd
78023>>>>>>>>>>>        If (Not(hWnd)) Begin
78025>>>>>>>>>>>            Error DFERR_DFTIMER C_$TimerNoHandle
78026>>>>>>>>>>>>
78026>>>>>>>>>>>            Procedure_Return
78027>>>>>>>>>>>        End
78027>>>>>>>>>>>>
78027>>>>>>>>>>>
78027>>>>>>>>>>>        // Test if handle is valid. If not, we leave.
78027>>>>>>>>>>>        If (Not(IsWindow(hWnd))) ;            Procedure_Return
78030>>>>>>>>>>>
78030>>>>>>>>>>>        Move (TimersArray(self)) to iSet
78031>>>>>>>>>>>
78031>>>>>>>>>>>        If (iSet) Begin
78033>>>>>>>>>>>
78033>>>>>>>>>>>            // Let's create or modify a timer
78033>>>>>>>>>>>            If iState Begin
78035>>>>>>>>>>>
78035>>>>>>>>>>>                // Get the exising to new TimerID
78035>>>>>>>>>>>                Get MSG_Add_Object of iSet iObj to iTimerID
78036>>>>>>>>>>>
78036>>>>>>>>>>>                // Set/Modify the timer
78036>>>>>>>>>>>                Get Timeout of iObj to iTimeout
78037>>>>>>>>>>>                Move (SetTimer(hWnd, iTimerID, iTimeout, 0)) to iResult
78038>>>>>>>>>>>                If Not iResult Begin
78040>>>>>>>>>>>                    Error DFERR_DFTIMER C_$TooManyTimers
78041>>>>>>>>>>>>
78041>>>>>>>>>>>                    Procedure_Return
78042>>>>>>>>>>>                End
78042>>>>>>>>>>>>
78042>>>>>>>>>>>
78042>>>>>>>>>>>            End
78042>>>>>>>>>>>>
78042>>>>>>>>>>>
78042>>>>>>>>>>>            // Let's kill an existing timer
78042>>>>>>>>>>>            Else Begin
78043>>>>>>>>>>>
78043>>>>>>>>>>>                // Look up the object in the set
78043>>>>>>>>>>>                Get Find_Object of iSet iObj to iTimerID
78044>>>>>>>>>>>
78044>>>>>>>>>>>                If iTimerID EQ -1 ;                    Procedure_Return
78047>>>>>>>>>>>
78047>>>>>>>>>>>                // Kill the timer
78047>>>>>>>>>>>                Move (KillTimer(hWnd, iTimerID)) to iResult
78048>>>>>>>>>>>                If Not iResult Begin
78050>>>>>>>>>>>                    Move (GetLastError()) to nResult
78051>>>>>>>>>>>                    Error DFERR_DFTIMER (C_$CantKillTimer * string(nResult) - "!")
78052>>>>>>>>>>>>
78052>>>>>>>>>>>                    Procedure_Return
78053>>>>>>>>>>>                End
78053>>>>>>>>>>>>
78053>>>>>>>>>>>
78053>>>>>>>>>>>                // Remove the objectID
78053>>>>>>>>>>>                Send Remove_Object to iSet iObj
78054>>>>>>>>>>>            End
78054>>>>>>>>>>>>
78054>>>>>>>>>>>        End
78054>>>>>>>>>>>>
78054>>>>>>>>>>>    End_Procedure
78055>>>>>>>>>>>
78055>>>>>>>>>>>    Function Timer_Active_State Integer iObj Returns Integer
78057>>>>>>>>>>>        Integer iResult
78057>>>>>>>>>>>        Get Find_Object of (TimersArray(self)) iObj to iResult
78058>>>>>>>>>>>        Function_Return (iResult<>-1) // note: -1= not found
78059>>>>>>>>>>>    End_Function
78060>>>>>>>>>>>
78060>>>>>>>>>>>    // Will be called by the Set when it is being destroyed.
78060>>>>>>>>>>>    Procedure Kill_All_Timers
78062>>>>>>>>>>>        Integer iMax
78062>>>>>>>>>>>        Integer iSet
78062>>>>>>>>>>>        Integer iItem
78062>>>>>>>>>>>        Integer iObj
78062>>>>>>>>>>>        Integer iResult
78062>>>>>>>>>>>        Handle  hWnd
78062>>>>>>>>>>>
78062>>>>>>>>>>>        // Get the handle of this object
78062>>>>>>>>>>>        Get Window_Handle to hWnd
78063>>>>>>>>>>>        If (Not(hWnd)) Begin
78065>>>>>>>>>>>            Error DFERR_DFTIMER C_$TimerNoHandle
78066>>>>>>>>>>>>
78066>>>>>>>>>>>            Procedure_Return
78067>>>>>>>>>>>        End
78067>>>>>>>>>>>>
78067>>>>>>>>>>>
78067>>>>>>>>>>>        // If the window handle is no longer valid, we
78067>>>>>>>>>>>        // leave this procedure. This can happen when the
78067>>>>>>>>>>>        // program is begin aborted using Exit_Application
78067>>>>>>>>>>>        If (Not(IsWindow(hWnd))) ;            Procedure_Return
78070>>>>>>>>>>>
78070>>>>>>>>>>>        // Scan the set and kill all known timers
78070>>>>>>>>>>>        Move (TimersArray(self)) to iSet
78071>>>>>>>>>>>        If (iSet) Begin
78073>>>>>>>>>>>            Get Item_Count of iSet to iMax
78074>>>>>>>>>>>            Decrement iMax
78075>>>>>>>>>>>            For iItem From 1 to iMax
78081>>>>>>>>>>>>
78081>>>>>>>>>>>                Get Integer_Value of iSet item iItem to iObj
78082>>>>>>>>>>>                If iObj Begin
78084>>>>>>>>>>>                    Move (KillTimer(hWnd, iItem)) to iResult
78085>>>>>>>>>>>                    Set Array_Value of iSet item iItem to 0
78086>>>>>>>>>>>                End
78086>>>>>>>>>>>>
78086>>>>>>>>>>>            Loop
78087>>>>>>>>>>>>
78087>>>>>>>>>>>        End
78087>>>>>>>>>>>>
78087>>>>>>>>>>>
78087>>>>>>>>>>>    End_Procedure
78088>>>>>>>>>>>
78088>>>>>>>>>>>    Procedure OnTimer Integer wParam Integer lParam
78090>>>>>>>>>>>        Integer iObj
78090>>>>>>>>>>>        Get Integer_Value of (TimersArray(self)) item wParam to iObj
78091>>>>>>>>>>>        If Not iObj Begin
78093>>>>>>>>>>>            Error DFERR_DFTIMER C_$TimerWithoutObject
78094>>>>>>>>>>>>
78094>>>>>>>>>>>            Procedure_Return
78095>>>>>>>>>>>        End
78095>>>>>>>>>>>>
78095>>>>>>>>>>>        Send OnTimer to iObj wParam lParam
78096>>>>>>>>>>>    End_Procedure
78097>>>>>>>>>>>
78097>>>>>>>>>>>    Procedure Destroy_Object
78099>>>>>>>>>>>        Send Kill_All_Timers
78100>>>>>>>>>>>        Forward Send Destroy_Object
78102>>>>>>>>>>>        Move 0 to giTimerManager
78103>>>>>>>>>>>    End_Procedure
78104>>>>>>>>>>>
78104>>>>>>>>>>>End_Class // DFTimerManger
78105>>>>>>>>>>>
78105>>>>>>>>>>>
78105>>>>>>>>>>>
78105>>>>>>>>>>>
78105>>>>>>>>>>>// This class acts as a container for the
78105>>>>>>>>>>>// timer manager object. This is needed because
78105>>>>>>>>>>>// A DFTimerManager object created directly at the
78105>>>>>>>>>>>// desktop doesn't have a Window_Handle which we
78105>>>>>>>>>>>// need to create a Windoows timer. By placing
78105>>>>>>>>>>>// this non-visual container around the timer
78105>>>>>>>>>>>// manager, it does get a Window_Handle.
78105>>>>>>>>>>>// The procedure End_Construct_Object has been
78105>>>>>>>>>>>// augmented to create a window and also
78105>>>>>>>>>>>// automatically page all children, which will
78105>>>>>>>>>>>// be the timer manager.
78105>>>>>>>>>>>//
78105>>>>>>>>>>>Class DFTimerManagerPanel is a dfBasePanel
78106>>>>>>>>>>>
78106>>>>>>>>>>>    Procedure Construct_Object
78108>>>>>>>>>>>        Forward Send Construct_Object
78110>>>>>>>>>>>        Set Visible_State to FALSE
78111>>>>>>>>>>>        Object DFTimerManager is a DFTimerManager
78113>>>>>>>>>>>        End_Object
78114>>>>>>>>>>>    End_Procedure
78115>>>>>>>>>>>
78115>>>>>>>>>>>    Procedure End_Construct_Object
78117>>>>>>>>>>>        Forward Send End_Construct_Object
78119>>>>>>>>>>>        Send Page_Object TRUE
78120>>>>>>>>>>>        Broadcast Send Page_Object TRUE
78122>>>>>>>>>>>    End_Procedure
78123>>>>>>>>>>>
78123>>>>>>>>>>>End_Class
78124>>>>>>>>>>>
78124>>>>>>>>>>>// This is the class the user uses to create DFTimer objects
78124>>>>>>>>>>>
78124>>>>>>>>>>>
78124>>>>>>>>>>>//{ OverrideProperty=Skip_State DesignTime=False }
78124>>>>>>>>>>>//{ OverrideProperty=TypeFace DesignTime=False }
78124>>>>>>>>>>>Class DFTimer is a Textbox
78125>>>>>>>>>>>
78125>>>>>>>>>>>    Procedure Construct_Object
78127>>>>>>>>>>>        Forward Send Construct_Object
78129>>>>>>>>>>>
78129>>>>>>>>>>>        // Make sure this object never appears
78129>>>>>>>>>>>        Set Visible_State to FALSE
78130>>>>>>>>>>>
78130>>>>>>>>>>>        Property Integer Private.Timeout    1000
78131>>>>>>>>>>>
78131>>>>>>>>>>>        Property Integer Timer_Message      0
78132>>>>>>>>>>>        Property Integer Timer_Object       0
78133>>>>>>>>>>>        Property Integer Auto_Start_State   True
78134>>>>>>>>>>>        Property Integer Auto_Stop_State    True
78135>>>>>>>>>>>    End_Procedure
78136>>>>>>>>>>>
78136>>>>>>>>>>>    Procedure Set Timer_Active_State Integer iState
78138>>>>>>>>>>>        Integer iObj
78138>>>>>>>>>>>        Move self to iObj
78139>>>>>>>>>>>        If giTimerManager ;            Set Timer_Active_State of giTimerManager iObj to iState
78142>>>>>>>>>>>    End_Procedure
78143>>>>>>>>>>>
78143>>>>>>>>>>>    Function Timer_Active_State Returns Integer
78145>>>>>>>>>>>        Integer iState
78145>>>>>>>>>>>        Integer iObj
78145>>>>>>>>>>>        Move self to iObj
78146>>>>>>>>>>>        If giTimerManager ;            Get Timer_Active_State of giTimerManager iObj to iState
78149>>>>>>>>>>>        Function_Return iState
78150>>>>>>>>>>>    End_Function
78151>>>>>>>>>>>
78151>>>>>>>>>>>    Procedure Set Timeout Integer iTimeout
78153>>>>>>>>>>>        Integer iActive
78153>>>>>>>>>>>        Set Private.Timeout to iTimeout
78154>>>>>>>>>>>        Get Timer_Active_State to iActive
78155>>>>>>>>>>>        If iActive ;            Set Timer_Active_State to TRUE
78158>>>>>>>>>>>    End_Procedure
78159>>>>>>>>>>>
78159>>>>>>>>>>>    Function Timeout Returns Integer
78161>>>>>>>>>>>        Integer iTimeout
78161>>>>>>>>>>>        Get Private.Timeout to iTimeout
78162>>>>>>>>>>>        Function_Return iTimeout
78163>>>>>>>>>>>    End_Function
78164>>>>>>>>>>>
78164>>>>>>>>>>>    Procedure OnTimer Integer iwParam Integer ilParam
78166>>>>>>>>>>>        Integer iMsg
78166>>>>>>>>>>>        Integer iObj
78166>>>>>>>>>>>        Get Timer_Message to iMsg
78167>>>>>>>>>>>        If (iMsg) Begin
78169>>>>>>>>>>>            Get Timer_Object  to iObj
78170>>>>>>>>>>>            If iObj ;                Send iMsg to iObj iwParam ilParam
78173>>>>>>>>>>>            Else ;                Send iMsg iwParam ilParam
78175>>>>>>>>>>>        End
78175>>>>>>>>>>>>
78175>>>>>>>>>>>    End_Procedure
78176>>>>>>>>>>>
78176>>>>>>>>>>>    // Augmented to Auto_Start a timer
78176>>>>>>>>>>>    //
78176>>>>>>>>>>>    Procedure Page_Object Integer iState
78178>>>>>>>>>>>        Forward Send Page_Object iState
78180>>>>>>>>>>>        If (iState AND Auto_Start_State(self)) ;            Set Timer_Active_State to TRUE
78183>>>>>>>>>>>    End_Procedure
78184>>>>>>>>>>>
78184>>>>>>>>>>>    // Augmented to Auto_Stop a timer
78184>>>>>>>>>>>    //
78184>>>>>>>>>>>    Procedure Page_Delete
78186>>>>>>>>>>>        If (Auto_Stop_State(self)) ;            Set Timer_Active_State to FALSE
78189>>>>>>>>>>>        Forward Send Page_Delete
78191>>>>>>>>>>>    End_Procedure
78192>>>>>>>>>>>
78192>>>>>>>>>>>    // Augmented to stop the timer
78192>>>>>>>>>>>    //
78192>>>>>>>>>>>    Procedure Destroy_Object
78194>>>>>>>>>>>        Set Timer_Active_State to FALSE
78195>>>>>>>>>>>        Forward Send Destroy_Object
78197>>>>>>>>>>>    End_Procedure
78198>>>>>>>>>>>
78198>>>>>>>>>>>End_Class // DFTimer
78199>>>>>>>>>>>
78199>>>>>>>>>>>//
78199>>>>>>>>>>>// This was moved into a method so it can be reliable created
78199>>>>>>>>>>>// at the desktop. Note that cDesktop adds method to cDesktop class (class of desktop)
78199>>>>>>>>>>>//
78199>>>>>>>>>>>Procedure CreateDfTimerManagerPanel FOR cDesktop
78201>>>>>>>>>>>    // Create the Desktop Timer Manager Object.
78201>>>>>>>>>>>    Object DFTimerManagerPanel is a DFTimerManagerPanel
78203>>>>>>>>>>>    End_Object
78204>>>>>>>>>>>End_Procedure
78205>>>>>>>>>>>
78205>>>>>>>>>>>Send CreateDfTimerManagerPanel of DESKTOP
78206>>>>>>>>>>>
78206>>>>>>>>>
78206>>>>>>>>>Class cTimer is a cObject
78207>>>>>>>>>
78207>>>>>>>>>    Procedure Construct_Object
78209>>>>>>>>>        Forward Send Construct_Object
78211>>>>>>>>>        Property Integer piPrivate_Timeout 1000
78212>>>>>>>>>    End_Procedure
78213>>>>>>>>>
78213>>>>>>>>>    Procedure Set pbEnabled Boolean bEnabled
78215>>>>>>>>>        If giTimerManager Begin
78217>>>>>>>>>            Set Timer_Active_State of giTimerManager Self to bEnabled
78218>>>>>>>>>        End
78218>>>>>>>>>>
78218>>>>>>>>>    End_Procedure
78219>>>>>>>>>
78219>>>>>>>>>    Function pbEnabled Returns Boolean
78221>>>>>>>>>        Boolean bEnabled
78221>>>>>>>>>        If giTimerManager Begin
78223>>>>>>>>>            Get Timer_Active_State of giTimerManager Self to bEnabled
78224>>>>>>>>>        End
78224>>>>>>>>>>
78224>>>>>>>>>        Function_Return bEnabled
78225>>>>>>>>>    End_Function
78226>>>>>>>>>
78226>>>>>>>>>    Procedure Set piTimeout Integer iTimeout
78228>>>>>>>>>        Boolean bEnabled
78228>>>>>>>>>        Set piPrivate_Timeout to iTimeout
78229>>>>>>>>>        Get pbEnabled to bEnabled
78230>>>>>>>>>        If bEnabled Begin
78232>>>>>>>>>            Set pbEnabled to True
78233>>>>>>>>>        End
78233>>>>>>>>>>
78233>>>>>>>>>    End_Procedure
78234>>>>>>>>>
78234>>>>>>>>>    Function piTimeout Returns Integer
78236>>>>>>>>>        Integer iTimeout
78236>>>>>>>>>        Get piPrivate_Timeout to iTimeout
78237>>>>>>>>>        Function_Return iTimeout
78238>>>>>>>>>    End_Function
78239>>>>>>>>>
78239>>>>>>>>>    Procedure OnTimer
78241>>>>>>>>>    End_Procedure
78242>>>>>>>>>    
78242>>>>>>>>>    // this is needed by the timer manager 
78242>>>>>>>>>    Function Timeout Returns Integer
78244>>>>>>>>>        Integer iTimeout
78244>>>>>>>>>        Get piPrivate_Timeout to iTimeout
78245>>>>>>>>>        Function_Return iTimeout
78246>>>>>>>>>    End_Function
78247>>>>>>>>>
78247>>>>>>>>>    Procedure Destroy_Object
78249>>>>>>>>>        Set pbEnabled to False
78250>>>>>>>>>        Forward Send Destroy_Object
78252>>>>>>>>>    End_Procedure
78253>>>>>>>>>
78253>>>>>>>>>End_Class
78254>>>>>>>Use cRichEdit.pkg
Including file: cRichEdit.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cRichEdit.pkg)
78254>>>>>>>>>use Windows.pkg
78254>>>>>>>>>Use cEdit_Mixin.pkg
78254>>>>>>>>>
78254>>>>>>>>>// DFO: cRichEdit.Dfo
78254>>>>>>>>>// DFC: cRichEdit.Dfc
78254>>>>>>>>>
78254>>>>>>>>>// constants used for RichEdit Properties
78254>>>>>>>>>// peAlignment 
78254>>>>>>>>>Enum_List 
78254>>>>>>>>>    Define alLeft   for 1 
78254>>>>>>>>>    Define alRight  for 2 
78254>>>>>>>>>    Define alCenter for 3 
78254>>>>>>>>>End_Enum_List 
78254>>>>>>>>>
78254>>>>>>>>>// peBullets 
78254>>>>>>>>>Enum_List 
78254>>>>>>>>>    Define buNone 
78254>>>>>>>>>    Define buBullets 
78254>>>>>>>>>    Define buArabicNumbers 
78254>>>>>>>>>    Define buLowerLetters 
78254>>>>>>>>>    Define buUpperLetters 
78254>>>>>>>>>    Define buLowerRomans 
78254>>>>>>>>>    Define buUpperRomans 
78254>>>>>>>>>End_Enum_List 
78254>>>>>>>>>
78254>>>>>>>>>// peBulletStyle 
78254>>>>>>>>>Enum_List 
78254>>>>>>>>>    Define busRightParen   for 0 
78254>>>>>>>>>    Define busEncloseParen for 256 
78254>>>>>>>>>    Define busPeriod       for 512 
78254>>>>>>>>>    Define busNumberOnly   for 768 
78254>>>>>>>>>    Define busNoDisplay    for 1024 
78254>>>>>>>>>End_Enum_List
78254>>>>>>>>>    
78254>>>>>>>>>// peLineSpacingType
78254>>>>>>>>>Enum_List 
78254>>>>>>>>>    Define lstSingle
78254>>>>>>>>>    Define lstSingleAndOneHalf
78254>>>>>>>>>    Define lstDouble
78254>>>>>>>>>End_Enum_List
78254>>>>>>>>>
78254>>>>>>>>>Class cRichEdit Is A DFBaseRichEdit
78255>>>>>>>>>
78255>>>>>>>>>    Procedure Construct_Object
78257>>>>>>>>>        Forward Send Construct_Object
78259>>>>>>>>>        Send Define_cEdit_Mixin
78260>>>>>>>>>
78260>>>>>>>>>        On_key Key_Ctrl+Key_B send ToggleBold
78261>>>>>>>>>        On_key Key_Ctrl+Key_I send ToggleItalics
78262>>>>>>>>>        On_key Key_Ctrl+Key_U send ToggleUnderline
78263>>>>>>>>>
78263>>>>>>>>>    End_Procedure // Construct_Object
78264>>>>>>>>>
78264>>>>>>>>>    Import_Class_Protocol cEdit_Mixin
78265>>>>>>>>>    
78265>>>>>>>>>    Procedure ToggleBold
78267>>>>>>>>>        Set pbBold to (not(pbBold(self))) 
78268>>>>>>>>>    end_procedure
78269>>>>>>>>>    
78269>>>>>>>>>    Procedure ToggleItalics
78271>>>>>>>>>        Set pbItalics to (not(pbItalics(self))) 
78272>>>>>>>>>    end_procedure
78273>>>>>>>>>    
78273>>>>>>>>>    Procedure ToggleUnderline
78275>>>>>>>>>       Set pbUnderLine to (not(pbUnderLine(self))) 
78276>>>>>>>>>    end_procedure
78277>>>>>>>>>
78277>>>>>>>>>End_Class
78278>>>>>>>>>
78278>>>>>>>Use sql.pkg
Including file: sql.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\sql.pkg)
78278>>>>>>>>>//*****************************************************************************
78278>>>>>>>>>//*** SQL.pkg                                                               ***
78278>>>>>>>>>//***                                                                       ***
78278>>>>>>>>>//*** Author: Ben Weijers                                                   ***
78278>>>>>>>>>//***         Data Access Wordwide                                          ***
78278>>>>>>>>>//***         14 February 2000                                              ***
78278>>>>>>>>>//***                                                                       ***
78278>>>>>>>>>//*** Purpose:                                                              ***
78278>>>>>>>>>//***   Embedded SQL manager.                                               ***
78278>>>>>>>>>//***                                                                       ***
78278>>>>>>>>>//*** Changes:                                                              ***
78278>>>>>>>>>//***                                                                       ***
78278>>>>>>>>>//***   March 14, 2001. CLI Connectivity Kits 2.0.0.13                      ***
78278>>>>>>>>>//***       Allocate memory before call_driver command with spaces instead  ***
78278>>>>>>>>>//***       of binary zeroes.                                               ***
78278>>>>>>>>>//***                                                                       ***
78278>>>>>>>>>//*****************************************************************************
78278>>>>>>>>>
78278>>>>>>>>>Use UI
78278>>>>>>>>>Use CLI
78278>>>>>>>>>Use Case.mac
78278>>>>>>>>>
78278>>>>>>>>>//Doc/ Ignore=True
78278>>>>>>>>>//*** Global object handle for the manager
78278>>>>>>>>>Integer _embsqlghoSQLHandleMngr
78278>>>>>>>>>
78278>>>>>>>>>//*** Global stroage for results
78278>>>>>>>>>Integer SQLResult
78278>>>>>>>>>
78278>>>>>>>>>//*** Embedded SQL function constants
78278>>>>>>>>>Define FUNC_SQLCONNECT             For 1000000
78278>>>>>>>>>Define FUNC_SQLFILECONNECT         For 1000001
78278>>>>>>>>>Define FUNC_SQLDISCONNECT          For 1000002
78278>>>>>>>>>Define FUNC_SQLOPEN                For 1000003
78278>>>>>>>>>Define FUNC_SQLCLOSE               For 1000004
78278>>>>>>>>>Define FUNC_SQLPREPARE             For 1000005
78278>>>>>>>>>Define FUNC_SQLEXECUTE             For 1000006
78278>>>>>>>>>Define FUNC_SQLEXECDIRECT          For 1000007
78278>>>>>>>>>Define FUNC_SQLFETCH               For 1000008
78278>>>>>>>>>Define FUNC_SQLCOLUMNINFO          For 1000009
78278>>>>>>>>>Define FUNC_SQLCOLUMNVALUE         For 1000010
78278>>>>>>>>>Define FUNC_SQLBINDFILE            For 1000011
78278>>>>>>>>>Define FUNC_SQLGETDATA             For 1000012
78278>>>>>>>>>Define FUNC_SQLCOLSTRINGATTRIBLEN  For 1000013
78278>>>>>>>>>Define FUNC_SQLCOLSTRINGATTRIB     For 1000014
78278>>>>>>>>>Define FUNC_SQLCOLINTATTRIB        For 1000015
78278>>>>>>>>>Define FUNC_SQLSTMTINTATTRIB       For 1000016
78278>>>>>>>>>Define FUNC_SQLSETPROCNAME         For 1000017
78278>>>>>>>>>DEfine FUNC_SQLSETPROCARG          For 1000018
78278>>>>>>>>>Define FUNC_SQLCALL                For 1000019
78278>>>>>>>>>Define FUNC_SQLGETPROCARGLEN       For 1000020
78278>>>>>>>>>Define FUNC_SQLGETPROCARG          For 1000021
78278>>>>>>>>>Define FUNC_SQLGETPROCRETVALLEN    For 1000022
78278>>>>>>>>>Define FUNC_SQLGETPROCRETVAL       For 1000023
78278>>>>>>>>>Define FUNC_SQLNEXTRESULTSET       For 1000024
78278>>>>>>>>>Define FUNC_SQLBUFFERSTATUS        For 1000025
78278>>>>>>>>>
78278>>>>>>>>>//*** Embedded SQL statement attribute constants
78278>>>>>>>>>Define SQLSTMTATTRIB_COLUMNCOUNT    For 1
78278>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT       For 2
78278>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT_TYPE  For 3
78278>>>>>>>>>
78278>>>>>>>>>//*** Embedded SQL column attribute constants
78278>>>>>>>>>Define SQLCOLATTRIB_SIZE           For 1
78278>>>>>>>>>Define SQLCOLATTRIB_LENGTH         For 1
78278>>>>>>>>>Define SQLCOLATTRIB_PRECISION      For 2
78278>>>>>>>>>Define SQLCOLATTRIB_LABEL          For 3
78278>>>>>>>>>Define SQLCOLATTRIB_BASECOLUMNNAME For 4
78278>>>>>>>>>Define SQLCOLATTRIB_BASETABLENAME  For 5
78278>>>>>>>>>Define SQLCOLATTRIB_SQLTYPE        For 6
78278>>>>>>>>>Define SQLCOLATTRIB_NULLABLE       For 7
78278>>>>>>>>>Define SQLCOLATTRIB_DFTYPE         For 8
78278>>>>>>>>>
78278>>>>>>>>>//*** Possible SQL Column type values
78278>>>>>>>>>Define SQL_UNKNOWN_TYPE   For    0
78278>>>>>>>>>Define SQL_CHAR           For    1
78278>>>>>>>>>Define SQL_NUMERIC        For    2
78278>>>>>>>>>Define SQL_DECIMAL        For    3
78278>>>>>>>>>Define SQL_INTEGER        For    4
78278>>>>>>>>>Define SQL_SMALLINT       For    5
78278>>>>>>>>>Define SQL_FLOAT          For    6
78278>>>>>>>>>Define SQL_REAL           For    7
78278>>>>>>>>>Define SQL_DOUBLE         For    8
78278>>>>>>>>>Define SQL_DATETIME       For    9
78278>>>>>>>>>Define SQL_VARCHAR        For   12
78278>>>>>>>>>Define SQL_TYPE_DATE      For   91
78278>>>>>>>>>Define SQL_TYPE_TIME      For   92
78278>>>>>>>>>Define SQL_TYPE_TIMESTAMP For   93
78278>>>>>>>>>
78278>>>>>>>>>Define SQL_DATE           For    9
78278>>>>>>>>>Define SQL_INTERVAL       For   10
78278>>>>>>>>>Define SQL_TIME           For   10
78278>>>>>>>>>Define SQL_TIMESTAMP      For   11
78278>>>>>>>>>Define SQL_LONGVARCHAR    For  (-1)
78278>>>>>>>>>Define SQL_BINARY         For  (-2)
78278>>>>>>>>>Define SQL_VARBINARY      For  (-3)
78278>>>>>>>>>Define SQL_LONGVARBINARY  For  (-4)
78278>>>>>>>>>Define SQL_BIGINT         For  (-5)
78278>>>>>>>>>Define SQL_TINYINT        For  (-6)
78278>>>>>>>>>Define SQL_BIT            For  (-7)
78278>>>>>>>>>Define SQL_GUID           For (-11)
78278>>>>>>>>>
78278>>>>>>>>>
78278>>>>>>>>>
78278>>>>>>>>>//*****************************************************************************
78278>>>>>>>>>//*** Class  : cSQLStatement                                                ***
78278>>>>>>>>>//*** Purpose: Statement object for embedded sql                            ***
78278>>>>>>>>>//***                                                                       ***
78278>>>>>>>>>//*** Description:                                                          ***
78278>>>>>>>>>//***   An object is created for each statement. These will be children     ***
78278>>>>>>>>>//***   of cSQLConnection objects which manage the create and destruction   ***
78278>>>>>>>>>//***   of these.                                                           ***
78278>>>>>>>>>//*****************************************************************************
78278>>>>>>>>>
78278>>>>>>>>>Class cSQLStatement is an Array
78279>>>>>>>>>
78279>>>>>>>>>    Procedure Construct_object Integer Image
78281>>>>>>>>>        Forward Send Construct_object Image
78283>>>>>>>>>
78283>>>>>>>>>        Property Integer phCLIHandle      public 0
78284>>>>>>>>>        Property String  psDriverID       Public ""
78285>>>>>>>>>        Property Integer phStmtConnection Public 0
78286>>>>>>>>>        Property Integer piLastColumn     Public 0
78287>>>>>>>>>        Property Integer piLastArgument   Public 0
78288>>>>>>>>>        Property Integer piBindFile       Public 0
78289>>>>>>>>>
78289>>>>>>>>>        Set Delegation_mode To NO_Delegation
78290>>>>>>>>>    End_procedure // Construct_object
78291>>>>>>>>>
78291>>>>>>>>>
78291>>>>>>>>>
78291>>>>>>>>>    //***
78291>>>>>>>>>    //*** Procedure: StoreHandleInfo
78291>>>>>>>>>    //*** Purpose  : Store basic information about the statement handle.
78291>>>>>>>>>    //***
78291>>>>>>>>>
78291>>>>>>>>>    Procedure StoreHandleInfo Integer iCLIHandle String sDrvrId Integer iParentHandle
78293>>>>>>>>>        Set phCLIHandle      To iCLIHandle
78294>>>>>>>>>        Set psDriverID       To sDrvrId
78295>>>>>>>>>        Set phStmtConnection To iParentHandle
78296>>>>>>>>>    End_Procedure // StoreHandleInfo
78297>>>>>>>>>
78297>>>>>>>>>
78297>>>>>>>>>
78297>>>>>>>>>    //***
78297>>>>>>>>>    //*** Procedure: FreeHandle
78297>>>>>>>>>    //*** Purpose  : Free a handle. Since a handle is stored in an
78297>>>>>>>>>    //***            cSQLStatement object, we destroy the object.
78297>>>>>>>>>    //***
78297>>>>>>>>>
78297>>>>>>>>>    Procedure FreeHandle
78299>>>>>>>>>        Send Destroy_Object
78300>>>>>>>>>    End_Procedure // FreeHandle
78301>>>>>>>>>
78301>>>>>>>>>
78301>>>>>>>>>
78301>>>>>>>>>    //***
78301>>>>>>>>>    //*** Procedure: HandleError
78301>>>>>>>>>    //*** Puprose  : Handle an error that has occured while checking properties.
78301>>>>>>>>>    //***
78301>>>>>>>>>
78301>>>>>>>>>    Procedure HandleError Integer ihstmt Integer ihdbc String sDrvrId String sOriginMsg
78303>>>>>>>>>        Local Integer iErrHandle
78303>>>>>>>>>        Local Integer iErrNum
78303>>>>>>>>>        Local String  sLocationInfo
78303>>>>>>>>>
78303>>>>>>>>>        //*** Get the DataFlex statement identifier
78303>>>>>>>>>        Move Current_object To iErrHandle
78304>>>>>>>>>
78304>>>>>>>>>        //*** Determine error number
78304>>>>>>>>>        If (ihstmt = 0) ;            Move CLIERR_SQLINVALID_CLI_STMT_HANDLE To iErrNum
78307>>>>>>>>>        Else If (ihdbc = 0) ;            Move CLIERR_SQLINVALID_CLI_CONN_HANDLE To iErrNum
78311>>>>>>>>>        Else If (sDrvrId = "") ;            Move CLIERR_SQLINVALID_DRIVER_ID To iErrNum
78315>>>>>>>>>        Else ;            Move CLIERR_SQL_ERROR To iErrNum
78317>>>>>>>>>
78317>>>>>>>>>        //*** Create location ifnormation
78317>>>>>>>>>        Move "[" To sLocationInfo
78318>>>>>>>>>        If (sOriginMsg <> "") Begin
78320>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) To sLocationInfo
78321>>>>>>>>>            Move (Append(sLocationInfo, ", "))       To sLocationInfo
78322>>>>>>>>>        End
78322>>>>>>>>>>
78322>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) To sLocationInfo
78323>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          To sLocationInfo
78324>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 To sLocationInfo
78325>>>>>>>>>
78325>>>>>>>>>        //*** Generate the error
78325>>>>>>>>>        Error iErrNum sLocationInfo
78326>>>>>>>>>>
78326>>>>>>>>>    End_Procedure // HandleError
78327>>>>>>>>>
78327>>>>>>>>>
78327>>>>>>>>>
78327>>>>>>>>>    //***
78327>>>>>>>>>    //*** Procedure: StmtError
78327>>>>>>>>>    //*** Purpose  : Handle general error not related to the properties
78327>>>>>>>>>    //***
78327>>>>>>>>>
78327>>>>>>>>>    Procedure StmtError Integer iErrNum String sErrText String sOriginMsg
78329>>>>>>>>>        Local Integer iErrHandle
78329>>>>>>>>>        Local String  sLocationInfo
78329>>>>>>>>>
78329>>>>>>>>>        //*** Get the DataFlex statement identifier
78329>>>>>>>>>        Move Current_object To iErrHandle
78330>>>>>>>>>
78330>>>>>>>>>
78330>>>>>>>>>        //*** Create location information
78330>>>>>>>>>        Move "[" To sLocationInfo
78331>>>>>>>>>        If (sOriginMsg <> "") Begin
78333>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) To sLocationInfo
78334>>>>>>>>>            Move (Append(sLocationInfo, ", "))       To sLocationInfo
78335>>>>>>>>>        End
78335>>>>>>>>>>
78335>>>>>>>>>        If (sErrtext <> "") Begin
78337>>>>>>>>>            Move (Append(sLocationInfo, sErrtext)) To sLocationInfo
78338>>>>>>>>>            Move (Append(sLocationInfo, ", "))     To sLocationInfo
78339>>>>>>>>>        End
78339>>>>>>>>>>
78339>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) To sLocationInfo
78340>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          To sLocationInfo
78341>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 To sLocationInfo
78342>>>>>>>>>
78342>>>>>>>>>        //*** Generate the error
78342>>>>>>>>>        Error iErrNum sLocationInfo
78343>>>>>>>>>>
78343>>>>>>>>>    End_Procedure // StmtError
78344>>>>>>>>>
78344>>>>>>>>>
78344>>>>>>>>>
78344>>>>>>>>>    //***
78344>>>>>>>>>    //*** Procedure: SQLIllegalAttribute
78344>>>>>>>>>    //*** Purpose  : Handle an illegal attribute error
78344>>>>>>>>>    //***
78344>>>>>>>>>
78344>>>>>>>>>    Procedure SQLIllegalAttribute String sErrText String sOriginMsg
78346>>>>>>>>>        Local Integer bReport
78346>>>>>>>>>
78346>>>>>>>>>        Get_attribute DF_REPORT_UNSUPPORTED_ATTRIBUTES To bReport
78349>>>>>>>>>        If (bReport) ;            Send StmtError CLIERR_SQLINVALID_ATTRIBUTE sErrtext sOriginMsg
78352>>>>>>>>>    End_Procedure // SQLIllegalAttribute
78353>>>>>>>>>
78353>>>>>>>>>
78353>>>>>>>>>
78353>>>>>>>>>    //***
78353>>>>>>>>>    //*** Function: SQLPrivateColumnIsLegal
78353>>>>>>>>>    //*** Purpose : Check if a column number is legal
78353>>>>>>>>>    //***
78353>>>>>>>>>
78353>>>>>>>>>    Function SQLPrivateColumnIsLegal Integer ihdbc String sDrvrId Integer ihstmt Integer iCol Returns Integer
78355>>>>>>>>>        Local Integer bLegal
78355>>>>>>>>>        Local Integer iNumColumns
78355>>>>>>>>>
78355>>>>>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt To iNumColumns
78356>>>>>>>>>        If (iCol > 0 And iCol <= iNumColumns) ;            Move DFTRUE To bLegal
78359>>>>>>>>>        Else ;            Move DFFALSE To bLegal
78361>>>>>>>>>
78361>>>>>>>>>        Function_Return bLegal
78362>>>>>>>>>    End_Function // SQLPrivateColumnIsLegal
78363>>>>>>>>>
78363>>>>>>>>>
78363>>>>>>>>>
78363>>>>>>>>>    //***
78363>>>>>>>>>    //*** Procedure: SQLClose
78363>>>>>>>>>    //*** Purpose  : Close a statement and free all alllocated resources
78363>>>>>>>>>    //***
78363>>>>>>>>>
78363>>>>>>>>>    Procedure SQLClose
78365>>>>>>>>>        Local Integer ihdbc
78365>>>>>>>>>        Local Integer ihstmt
78365>>>>>>>>>        Local Integer iVoid
78365>>>>>>>>>        Local String  sDrvrId
78365>>>>>>>>>        Local String  sEmpty
78365>>>>>>>>>
78365>>>>>>>>>        //*** Initialize
78365>>>>>>>>>        Move "" To sEmpty
78366>>>>>>>>>
78366>>>>>>>>>        //*** Get the cli handle to the connection
78366>>>>>>>>>        Get phCLIHandle        To ihstmt
78367>>>>>>>>>        Get psDriverId         To sDrvrId
78368>>>>>>>>>        Get phStmtConnection   To ihdbc
78369>>>>>>>>>
78369>>>>>>>>>        //*** Free the CLI handle
78369>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
78371>>>>>>>>>            //*** Call the driver function to close
78371>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCLOSE ;                        Callback Current_Object ;                        Passing ihdbc sEmpty ihstmt ;                        Result iVoid
78376>>>>>>>>>
78376>>>>>>>>>            //*** Free the DataFlex handle
78376>>>>>>>>>            Send FreeHandle
78377>>>>>>>>>        End
78377>>>>>>>>>>
78377>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLClose"
78379>>>>>>>>>    End_procedure // SQLClose
78380>>>>>>>>>
78380>>>>>>>>>
78380>>>>>>>>>
78380>>>>>>>>>    //***
78380>>>>>>>>>    //*** Procedure: SQLPrepare
78380>>>>>>>>>    //*** Purpose  : Prepare a statement for execution
78380>>>>>>>>>    //***
78380>>>>>>>>>
78380>>>>>>>>>    Procedure SQLPrepare String sStatement
78382>>>>>>>>>        Local Integer ihdbc
78382>>>>>>>>>        Local Integer ihstmt
78382>>>>>>>>>        Local Integer iVoid
78382>>>>>>>>>        Local String  sDrvrId
78382>>>>>>>>>
78382>>>>>>>>>        //*** Get the cli handle to the connection
78382>>>>>>>>>        Get phCLIHandle       To ihstmt
78383>>>>>>>>>        Get psDriverId        To sDrvrId
78384>>>>>>>>>        Get phStmtConnection  To ihdbc
78385>>>>>>>>>
78385>>>>>>>>>        //*** Prepare
78385>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
78387>>>>>>>>>            //*** Call the driver function to prepare
78387>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLPREPARE ;                        Callback Current_Object ;                        Passing ihdbc sStatement ihstmt ;                        Result iVoid
78392>>>>>>>>>        End
78392>>>>>>>>>>
78392>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrepare"
78394>>>>>>>>>    End_procedure // SQLPrepare
78395>>>>>>>>>
78395>>>>>>>>>
78395>>>>>>>>>
78395>>>>>>>>>    //***
78395>>>>>>>>>    //*** Procedure: SQLExecute
78395>>>>>>>>>    //*** Purpose  : Execute a prepared statement
78395>>>>>>>>>    //***
78395>>>>>>>>>
78395>>>>>>>>>    Procedure SQLExecute
78397>>>>>>>>>        Local Integer ihdbc
78397>>>>>>>>>        Local Integer ihstmt
78397>>>>>>>>>        Local Integer iVoid
78397>>>>>>>>>        Local String  sDrvrId
78397>>>>>>>>>        Local String  sEmpty
78397>>>>>>>>>
78397>>>>>>>>>        //*** Initialize
78397>>>>>>>>>        Move "" To sEmpty
78398>>>>>>>>>
78398>>>>>>>>>        //*** Get the cli handle to the connection
78398>>>>>>>>>        Get phCLIHandle       To ihstmt
78399>>>>>>>>>        Get psDriverId        To sDrvrId
78400>>>>>>>>>        Get phStmtConnection  To ihdbc
78401>>>>>>>>>
78401>>>>>>>>>        //*** Execute
78401>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
78403>>>>>>>>>            //*** Call the driver function to execute
78403>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLEXECUTE ;                        Callback Current_Object ;                        Passing ihdbc sEmpty ihstmt ;                        Result iVoid
78408>>>>>>>>>        End
78408>>>>>>>>>>
78408>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLExecute"
78410>>>>>>>>>    End_Procedure // SQLExecute
78411>>>>>>>>>
78411>>>>>>>>>
78411>>>>>>>>>
78411>>>>>>>>>    //***
78411>>>>>>>>>    //*** Procedure: SQLExecDirect
78411>>>>>>>>>    //*** Purpose  : Prepare and execute a statement
78411>>>>>>>>>    //***
78411>>>>>>>>>
78411>>>>>>>>>    Procedure SQLExecDirect String sStatement
78413>>>>>>>>>        Local Integer ihdbc
78413>>>>>>>>>        Local Integer ihstmt
78413>>>>>>>>>        Local Integer iVoid
78413>>>>>>>>>        Local String  sDrvrId
78413>>>>>>>>>
78413>>>>>>>>>        //*** Get the cli handle to the connection
78413>>>>>>>>>        Get phCLIHandle        To ihstmt
78414>>>>>>>>>        Get psDriverId         To sDrvrId
78415>>>>>>>>>        Get phStmtConnection   To ihdbc
78416>>>>>>>>>
78416>>>>>>>>>        //*** ExecDirect
78416>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
78418>>>>>>>>>            //*** Call the driver function to execdirect
78418>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLEXECDIRECT ;                        Callback Current_Object ;                        Passing ihdbc sStatement ihstmt ;                        Result iVoid
78423>>>>>>>>>        End
78423>>>>>>>>>>
78423>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLExecDirect"
78425>>>>>>>>>    End_procedure // SQLExecDirect
78426>>>>>>>>>
78426>>>>>>>>>
78426>>>>>>>>>
78426>>>>>>>>>    //***
78426>>>>>>>>>    //*** Procedure: SQLFetch
78426>>>>>>>>>    //*** Purpose  : Fetch the next row
78426>>>>>>>>>    //*** Returns  : 0   = No more data
78426>>>>>>>>>    //***            <>0 = Success
78426>>>>>>>>>    //***
78426>>>>>>>>>
78426>>>>>>>>>    Function SQLFetch Returns Integer
78428>>>>>>>>>        Local Integer ihdbc
78428>>>>>>>>>        Local Integer ihstmt
78428>>>>>>>>>        Local Integer iResult
78428>>>>>>>>>        Local String  sDrvrId
78428>>>>>>>>>        Local String  sEmpty
78428>>>>>>>>>
78428>>>>>>>>>        //*** Initialize
78428>>>>>>>>>        Move "" To sEmpty
78429>>>>>>>>>        Move 0  To iResult
78430>>>>>>>>>
78430>>>>>>>>>        //*** Get the cli handle to the connection
78430>>>>>>>>>        Get phCLIHandle        To ihstmt
78431>>>>>>>>>        Get psDriverId         To sDrvrId
78432>>>>>>>>>        Get phStmtConnection   To ihdbc
78433>>>>>>>>>
78433>>>>>>>>>        //*** Fetch
78433>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
78435>>>>>>>>>            Indicate Err False
78436>>>>>>>>>
78436>>>>>>>>>            //*** Call the driver function to fetch
78436>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLFETCH ;                        Callback Current_Object ;                        Passing ihdbc sEmpty ihstmt ;                        Result iResult
78441>>>>>>>>>
78441>>>>>>>>>            //*** If something went wrong, adjust the result
78441>>>>>>>>>            If (Err) ;                Move 0 To iResult
78444>>>>>>>>>
78444>>>>>>>>>            Set piLastcolumn To 0
78445>>>>>>>>>        End
78445>>>>>>>>>>
78445>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLFetch"
78447>>>>>>>>>
78447>>>>>>>>>        Function_return iResult
78448>>>>>>>>>    End_Function // SQLFetch
78449>>>>>>>>>
78449>>>>>>>>>
78449>>>>>>>>>
78449>>>>>>>>>    //***
78449>>>>>>>>>    //*** Function: SQLNextColumn
78449>>>>>>>>>    //*** Purpose : Get the next column
78449>>>>>>>>>    //***
78449>>>>>>>>>
78449>>>>>>>>>    Function SQLNextColumn Returns String
78451>>>>>>>>>        Local Integer iCol
78451>>>>>>>>>        Local String  sResult
78451>>>>>>>>>
78451>>>>>>>>>        Get piLastColumn To iCol
78452>>>>>>>>>        Increment iCol
78453>>>>>>>>>        Get SQLColumnValue iCol To sResult
78454>>>>>>>>>        Set piLastColumn To iCol
78455>>>>>>>>>
78455>>>>>>>>>        Function_return sResult
78456>>>>>>>>>    End_Function // SQLNextColumn
78457>>>>>>>>>
78457>>>>>>>>>
78457>>>>>>>>>
78457>>>>>>>>>    //***
78457>>>>>>>>>    //*** Function: SQLColumnValue
78457>>>>>>>>>    //*** Purpose : Return the value of a column in a fetched row of a given
78457>>>>>>>>>    //***           statement.
78457>>>>>>>>>    //***
78457>>>>>>>>>
78457>>>>>>>>>    Function SQLColumnValue Integer iCol Returns String
78459>>>>>>>>>        Local Integer ihdbc
78459>>>>>>>>>        Local Integer ihstmt
78459>>>>>>>>>        Local String  sDrvrId
78459>>>>>>>>>        Local String  sResult
78459>>>>>>>>>
78459>>>>>>>>>        //*** Initialize
78459>>>>>>>>>        Move "" To sResult
78460>>>>>>>>>
78460>>>>>>>>>        //*** Get the cli handle to the connection
78460>>>>>>>>>        Get phCLIHandle       To ihstmt
78461>>>>>>>>>        Get psDriverId        To sDrvrId
78462>>>>>>>>>        Get phStmtConnection  To ihdbc
78463>>>>>>>>>
78463>>>>>>>>>        //*** Get the value
78463>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") ;            Get SQLPrivateColumnValue iCol ihdbc sDRvrId ihstmt To sResult
78466>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnValue"
78468>>>>>>>>>
78468>>>>>>>>>        Function_return sResult
78469>>>>>>>>>    End_Function // SQLColumnValue
78470>>>>>>>>>
78470>>>>>>>>>    Function SQLPrivateColumnValue Integer iCol Integer ihdbc String sDrvrId Integer ihstmt Returns String
78472>>>>>>>>>        Local Integer iVoid
78472>>>>>>>>>        Local Integer iColSize
78472>>>>>>>>>        Local String  sResult
78472>>>>>>>>>        Local String  sEmpty
78472>>>>>>>>>        Local Integer bLegalColumn
78472>>>>>>>>>
78472>>>>>>>>>        //*** Initialize
78472>>>>>>>>>        Move "" To sEmpty
78473>>>>>>>>>
78473>>>>>>>>>        //*** Get the value
78473>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
78475>>>>>>>>>            //*** Check if the column exists
78475>>>>>>>>>            Get SQLPrivateColumnIsLegal ihdbc sDrvrId ihstmt iCol To bLegalColumn
78476>>>>>>>>>            If (bLegalColumn) Begin
78478>>>>>>>>>                //*** Determine the column size
78478>>>>>>>>>                Get SQLPrivateColAttribute iCol SQLCOLATTRIB_SIZE ihdbc sDrvrId ihstmt To iColSize
78479>>>>>>>>>                If (iColSize > 0) Begin
78481>>>>>>>>>                    //*** Setup function arguments
78481>>>>>>>>>                    Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                                Callback Current_Object ;                                Passing ihdbc iCol ihstmt ;                                Result iVoid
78486>>>>>>>>>
78486>>>>>>>>>                    //*** Allocate
78486>>>>>>>>>                    Move (Repeat(' ', iColSize)) To sResult
78487>>>>>>>>>
78487>>>>>>>>>                    //*** Call the driver function to get the value
78487>>>>>>>>>                    Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                                Callback Current_Object ;                                Passing sResult sEmpty 0 ;                                Result iVoid
78492>>>>>>>>>                End
78492>>>>>>>>>>
78492>>>>>>>>>            End
78492>>>>>>>>>>
78492>>>>>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLPrivateColumnValue"
78494>>>>>>>>>        End
78494>>>>>>>>>>
78494>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateColumnValue"
78496>>>>>>>>>
78496>>>>>>>>>        Function_return sResult
78497>>>>>>>>>    End_Function // SQLColumnValue
78498>>>>>>>>>
78498>>>>>>>>>
78498>>>>>>>>>
78498>>>>>>>>>    //***
78498>>>>>>>>>    //*** Procedure: SQLBindFile
78498>>>>>>>>>    //*** Purpose  : Add a file to the files used to place the statement result in.
78498>>>>>>>>>    //***
78498>>>>>>>>>
78498>>>>>>>>>    Procedure SQLBindFile Integer iFileNum
78500>>>>>>>>>        Local Integer ihdbc
78500>>>>>>>>>        Local Integer ihstmt
78500>>>>>>>>>        Local Integer iVoid
78500>>>>>>>>>        Local String  sDrvrId
78500>>>>>>>>>        Local String  sFileType
78500>>>>>>>>>        Local Integer bIsOpen
78500>>>>>>>>>
78500>>>>>>>>>        //*** Get the cli handle to the connection
78500>>>>>>>>>        Get phCLIHandle       To ihstmt
78501>>>>>>>>>        Get psDriverId        To sDrvrId
78502>>>>>>>>>        Get phStmtConnection  To ihdbc
78503>>>>>>>>>
78503>>>>>>>>>        //*** If a file number is not passed see if we can use the statement's
78503>>>>>>>>>        //*** default file number which is usually set with SetFileConnection
78503>>>>>>>>>        If (iFileNum = 0) Begin
78505>>>>>>>>>            Get piBindFile To iFileNum
78506>>>>>>>>>            If (iFileNum = 0) Begin
78508>>>>>>>>>                //*** Logic error, if 0 is passed as filenumber, piBindFile should be set.
78508>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_BIND_FILE "piBindFile should be set" "SQLBindFile"
78509>>>>>>>>>
78509>>>>>>>>>                Move 0 to SQLResult
78510>>>>>>>>>                Procedure_Return
78511>>>>>>>>>            End
78511>>>>>>>>>>
78511>>>>>>>>>        End
78511>>>>>>>>>>
78511>>>>>>>>>
78511>>>>>>>>>        //*** Bind the file
78511>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
78513>>>>>>>>>            //*** Chek if the file is open
78513>>>>>>>>>            Get_attribute DF_FILE_OPENED Of iFileNum To bIsOpen
78516>>>>>>>>>            If (bIsOpen) Begin
78518>>>>>>>>>                //*** Check if the file has the correct type
78518>>>>>>>>>                Get_attribute DF_FILE_DRIVER Of iFileNum To sFileType
78521>>>>>>>>>                If (sFileType = sDrvrId) Begin
78523>>>>>>>>>                    //*** Call the driver function to add a file to a statement
78523>>>>>>>>>                    Call_driver 0 sDrvrId Function FUNC_SQLBINDFILE ;                                Callback Current_Object ;                                Passing ihdbc iFileNum ihstmt ;                                Result iVoid
78528>>>>>>>>>                End
78528>>>>>>>>>>
78528>>>>>>>>>                Else ;                    Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File" * String(iFileNum) * "type incompatible with statement ("  + sFileType + ")") "SQLBindFile"
78530>>>>>>>>>            End
78530>>>>>>>>>>
78530>>>>>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File not open (number =" * String(iFileNum) + ")") "SQLBindFile"
78532>>>>>>>>>        End
78532>>>>>>>>>>
78532>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLBindFile"
78534>>>>>>>>>    End_Procedure // SQLBindFile
78535>>>>>>>>>
78535>>>>>>>>>
78535>>>>>>>>>
78535>>>>>>>>>    //*************************************************************************
78535>>>>>>>>>    //*** Function: SQLGetData                                              ***
78535>>>>>>>>>    //*** Purpose : Get data of a column.                                   ***
78535>>>>>>>>>    //*************************************************************************
78535>>>>>>>>>
78535>>>>>>>>>    Function SQLGetData Integer iCol Integer iLen Returns String
78537>>>>>>>>>        Local Integer ihdbc
78537>>>>>>>>>        Local Integer ihstmt
78537>>>>>>>>>        Local Integer iVoid
78537>>>>>>>>>        Local Integer iColSize
78537>>>>>>>>>        Local Integer iResult
78537>>>>>>>>>        Local String  sDrvrId
78537>>>>>>>>>        Local String  sResult
78537>>>>>>>>>        Local String  sEmpty
78537>>>>>>>>>        Local Integer bLegalColumn
78537>>>>>>>>>
78537>>>>>>>>>        //*** Initialize
78537>>>>>>>>>        Move "" To sEmpty
78538>>>>>>>>>        Move 0 To iResult
78539>>>>>>>>>
78539>>>>>>>>>        //*** Get the cli handle to the connection
78539>>>>>>>>>        Get phCLIHandle       To ihstmt
78540>>>>>>>>>        Get psDriverId        To sDrvrId
78541>>>>>>>>>        Get phStmtConnection  To ihdbc
78542>>>>>>>>>
78542>>>>>>>>>        //*** Get the data
78542>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
78544>>>>>>>>>            //*** Check if the column exists
78544>>>>>>>>>            Get SQLPrivateColumnIsLegal ihdbc sDrvrId ihstmt iCol To bLegalColumn
78545>>>>>>>>>            If (bLegalColumn) Begin
78547>>>>>>>>>                If (iLen = 0) ;                    Get SQLPrivateColumnValue iCol ihdbc sDrvrId ihstmt To sResult
78550>>>>>>>>>                Else Begin
78551>>>>>>>>>                    //*** Setup function arguments
78551>>>>>>>>>                    Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                                Callback Current_Object ;                                Passing ihdbc iCol ihstmt ;                                Result iVoid
78556>>>>>>>>>
78556>>>>>>>>>                    //*** Allocate
78556>>>>>>>>>                    Move (Repeat(' ', iLen)) To sResult
78557>>>>>>>>>
78557>>>>>>>>>                    Indicate Err False
78558>>>>>>>>>
78558>>>>>>>>>                    //*** Call the driver function to get the data
78558>>>>>>>>>                    Call_driver 0 sDrvrId Function FUNC_SQLGETDATA ;                                Callback Current_Object ;                                Passing sResult sEmpty iLen ;                                Result iResult
78563>>>>>>>>>
78563>>>>>>>>>                    //*** If something went wrong, adjust the result
78563>>>>>>>>>                    If (Err) ;                        Move 0 To iResult
78566>>>>>>>>>                End
78566>>>>>>>>>>
78566>>>>>>>>>            End
78566>>>>>>>>>>
78566>>>>>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLGetData"
78568>>>>>>>>>        End
78568>>>>>>>>>>
78568>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetData"
78570>>>>>>>>>
78570>>>>>>>>>        //*** Fill global result
78570>>>>>>>>>        Move iResult To SQLResult
78571>>>>>>>>>
78571>>>>>>>>>        Function_Return sResult
78572>>>>>>>>>    End_Function // SQLGetData
78573>>>>>>>>>
78573>>>>>>>>>
78573>>>>>>>>>
78573>>>>>>>>>    //***
78573>>>>>>>>>    //*** Function: SQLColumnMap
78573>>>>>>>>>    //*** Purpose : Map a column name to a number, if the name id not found no
78573>>>>>>>>>    //***           error is generated the returned number will be 0 (zero) in
78573>>>>>>>>>    //***           that case
78573>>>>>>>>>    //***
78573>>>>>>>>>
78573>>>>>>>>>    Function SQLColumnMap String sColname Returns Integer
78575>>>>>>>>>        Local Integer ihdbc
78575>>>>>>>>>        Local Integer ihstmt
78575>>>>>>>>>        Local Integer iNumColumns
78575>>>>>>>>>        Local Integer iColCount
78575>>>>>>>>>        Local Integer iColNum
78575>>>>>>>>>        Local String  sDrvrId
78575>>>>>>>>>        Local String  sCurColName
78575>>>>>>>>>
78575>>>>>>>>>        //*** Get the cli handle to the connection
78575>>>>>>>>>        Get phCLIHandle       To ihstmt
78576>>>>>>>>>        Get psDriverId        To sDrvrId
78577>>>>>>>>>        Get phStmtConnection  To ihdbc
78578>>>>>>>>>
78578>>>>>>>>>        //*** Get the number by looping through the column names
78578>>>>>>>>>        Move 0 To iColNum
78579>>>>>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt To iNumColumns
78580>>>>>>>>>        For iColCount From 1 To iNumColumns
78586>>>>>>>>>>
78586>>>>>>>>>            Get SQLPrivateColAttribute iColCount SQLCOLATTRIB_LABEL ihdbc sDrvrId ihstmt To sCurColName
78587>>>>>>>>>            If (Uppercase(Trim(sColName)) = Uppercase(Trim(sCurColName))) ;                Move iColCount To iColNum
78590>>>>>>>>>
78590>>>>>>>>>            If (iColNum) ;                Break
78593>>>>>>>>>        Loop
78594>>>>>>>>>>
78594>>>>>>>>>
78594>>>>>>>>>        Function_return iColNum
78595>>>>>>>>>    End_Function // SQLColumnMap
78596>>>>>>>>>
78596>>>>>>>>>
78596>>>>>>>>>
78596>>>>>>>>>    //***
78596>>>>>>>>>    //*** Function: SQLStmtAttribute
78596>>>>>>>>>    //*** Purpose : Get a statement attribute
78596>>>>>>>>>    //***
78596>>>>>>>>>
78596>>>>>>>>>    Function SQLStmtAttribute Integer iAttribId Returns String
78598>>>>>>>>>        Local Integer ihdbc
78598>>>>>>>>>        Local Integer ihstmt
78598>>>>>>>>>        Local String  sResult
78598>>>>>>>>>        Local String  sDrvrId
78598>>>>>>>>>
78598>>>>>>>>>        //*** Initialize
78598>>>>>>>>>        Move "" To sResult
78599>>>>>>>>>
78599>>>>>>>>>        //*** Get the cli handle to the connection
78599>>>>>>>>>        Get phCLIHandle       To ihstmt
78600>>>>>>>>>        Get psDriverId        To sDrvrId
78601>>>>>>>>>        Get phStmtConnection  To ihdbc
78602>>>>>>>>>
78602>>>>>>>>>        //*** Get the attribute
78602>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") ;            Get SQLPrivateStmtAttribute iAttribId ihdbc sDrvrId ihstmt To sResult
78605>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLStmtAttribute"
78607>>>>>>>>>
78607>>>>>>>>>        Function_Return sResult
78608>>>>>>>>>    End_Function // SQLStmtAttibute
78609>>>>>>>>>
78609>>>>>>>>>    Function SQLPrivateStmtAttribute Integer iAttribId Integer ihdbc String sDrvrId Integer ihstmt Returns String
78611>>>>>>>>>        Local String  sResult
78611>>>>>>>>>        Local Integer iLen
78611>>>>>>>>>        Local Integer bLegalAttrib
78611>>>>>>>>>
78611>>>>>>>>>        //*** Initialize
78611>>>>>>>>>        Move ""     To sResult
78612>>>>>>>>>
78612>>>>>>>>>        //*** Get the attribute
78612>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
78614>>>>>>>>>            Case Begin
78614>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_COLUMNCOUNT)
78616>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT)
78619>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT_TYPE)
78622>>>>>>>>>                    Move DFTRUE To bLegalAttrib
78623>>>>>>>>>                    Break
78624>>>>>>>>>
78624>>>>>>>>>                Case Else
78624>>>>>>>>>                    Move DFFALSE To bLegalAttrib
78625>>>>>>>>>                    Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLPrivateStmtAttribute"
78626>>>>>>>>>            Case End
78626>>>>>>>>>
78626>>>>>>>>>            If (bLegalAttrib) Begin
78628>>>>>>>>>                //*** Setup function arguments
78628>>>>>>>>>                Call_driver 0 sDrvrId Function FUNC_SQLSTMTINTATTRIB ;                            Callback Current_Object ;                            Passing ihdbc iAttribId ihstmt ;                            Result sResult
78633>>>>>>>>>            End
78633>>>>>>>>>>
78633>>>>>>>>>        End
78633>>>>>>>>>>
78633>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateStmtAttribute"
78635>>>>>>>>>
78635>>>>>>>>>        Function_Return sResult
78636>>>>>>>>>    End_Function // SQLPrivateStmtAttribute
78637>>>>>>>>>
78637>>>>>>>>>
78637>>>>>>>>>
78637>>>>>>>>>    //***
78637>>>>>>>>>    //*** Function: SQLColAttribute
78637>>>>>>>>>    //*** Purpose : Get a column's attribute
78637>>>>>>>>>    //***
78637>>>>>>>>>
78637>>>>>>>>>    Function SQLColAttribute Integer iCol Integer iAttribId Returns String
78639>>>>>>>>>        Local Integer ihdbc
78639>>>>>>>>>        Local Integer ihstmt
78639>>>>>>>>>        Local String  sResult
78639>>>>>>>>>        Local String  sDrvrId
78639>>>>>>>>>
78639>>>>>>>>>        //*** Initialize
78639>>>>>>>>>        Move "" To sResult
78640>>>>>>>>>
78640>>>>>>>>>        //*** Get the cli handle to the connection
78640>>>>>>>>>        Get phCLIHandle       To ihstmt
78641>>>>>>>>>        Get psDriverId        To sDrvrId
78642>>>>>>>>>        Get phStmtConnection  To ihdbc
78643>>>>>>>>>
78643>>>>>>>>>        //*** Get the attribute
78643>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") ;            Get SQLPrivateColAttribute iCol iAttribId ihdbc sDrvrId ihstmt To sResult
78646>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLColAttribute"
78648>>>>>>>>>
78648>>>>>>>>>        Function_Return sResult
78649>>>>>>>>>    End_Function // SQLColAttribute
78650>>>>>>>>>
78650>>>>>>>>>    Function SQLPrivateColAttribute Integer iCol Integer iAttribId Integer ihdbc String sDrvrId Integer ihstmt Returns String
78652>>>>>>>>>        Local String  sResult
78652>>>>>>>>>        Local String  sEmpty
78652>>>>>>>>>        Local Integer bIsStringAttribute
78652>>>>>>>>>        Local Integer iLen
78652>>>>>>>>>        Local Integer iVoid
78652>>>>>>>>>        Local Integer bLegalAttrib
78652>>>>>>>>>        Local Integer bLegalColumn
78652>>>>>>>>>
78652>>>>>>>>>        //*** Initialize
78652>>>>>>>>>        Move "" To sResult
78653>>>>>>>>>        Move "" To sEmpty
78654>>>>>>>>>        MOve 0  To iLen
78655>>>>>>>>>
78655>>>>>>>>>        //*** Get the attribute
78655>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
78657>>>>>>>>>            Get SQLPrivateColumnIsLegal ihdbc sDrvrId ihstmt iCol To bLegalColumn
78658>>>>>>>>>            If (bLegalColumn) Begin
78660>>>>>>>>>                //*** Determine the atributes type
78660>>>>>>>>>                Case Begin
78660>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_SIZE)
78662>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_LENGTH)
78665>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_PRECISION)
78668>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_SQLTYPE)
78671>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_NULLABLE)
78674>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_DFTYPE)
78677>>>>>>>>>                        Move DFFALSE To bIsStringAttribute
78678>>>>>>>>>                        Move DFTRUE To bLegalAttrib
78679>>>>>>>>>                        Break
78680>>>>>>>>>
78680>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_LABEL)
78683>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_BASECOLUMNNAME)
78686>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_BASETABLENAME)
78689>>>>>>>>>                        Move DFTRUE To bIsStringAttribute
78690>>>>>>>>>                        Move DFTRUE To bLegalAttrib
78691>>>>>>>>>                        Break
78692>>>>>>>>>
78692>>>>>>>>>                    Case Else
78692>>>>>>>>>                        Move DFFALSE To bLegalAttrib
78693>>>>>>>>>                        Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLPrivateColAttribute"
78694>>>>>>>>>                Case End
78694>>>>>>>>>
78694>>>>>>>>>                If (bLegalAttrib) Begin
78696>>>>>>>>>                    //*** Setup function arguments
78696>>>>>>>>>                    Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                                Callback Current_Object ;                                Passing ihdbc iCol ihstmt ;                                Result iVoid
78701>>>>>>>>>
78701>>>>>>>>>                    If (bIsStringAttribute) Begin
78703>>>>>>>>>                        //*** Call the driver function to get the data length
78703>>>>>>>>>                        Call_driver 0 sDrvrId Function FUNC_SQLCOLSTRINGATTRIBLEN ;                                    Callback Current_Object ;                                    Passing sEmpty sEmpty iAttribId ;                                    Result iLen
78708>>>>>>>>>
78708>>>>>>>>>                        If (iLen) Begin
78710>>>>>>>>>                            //*** Allocate
78710>>>>>>>>>                            Move (Repeat(' ', iLen)) To sResult
78711>>>>>>>>>
78711>>>>>>>>>                            //*** Call the driver function to get the name
78711>>>>>>>>>                            Call_driver 0 sDrvrId Function FUNC_SQLCOLSTRINGATTRIB ;                                        Callback Current_Object ;                                        Passing sResult sEmpty iAttribId ;                                        Result iVoid
78716>>>>>>>>>                        End
78716>>>>>>>>>>
78716>>>>>>>>>                    End
78716>>>>>>>>>>
78716>>>>>>>>>                    Else Begin
78717>>>>>>>>>                        //*** get the attribute
78717>>>>>>>>>                        Call_driver 0 sDrvrId Function FUNC_SQLCOLINTATTRIB ;                                    Callback Current_Object ;                                    Passing sEmpty sEmpty iAttribId ;                                    Result sResult
78722>>>>>>>>>                    End
78722>>>>>>>>>>
78722>>>>>>>>>                End
78722>>>>>>>>>>
78722>>>>>>>>>            End
78722>>>>>>>>>>
78722>>>>>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLPrivateColAttribute"
78724>>>>>>>>>        End
78724>>>>>>>>>>
78724>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateColAttribute"
78726>>>>>>>>>
78726>>>>>>>>>        Function_Return sResult
78727>>>>>>>>>    End_Function // SQLPrivateColAttribute
78728>>>>>>>>>
78728>>>>>>>>>
78728>>>>>>>>>
78728>>>>>>>>>    //***
78728>>>>>>>>>    //*** Procedure: SQLSetProcedureName
78728>>>>>>>>>    //*** Purpsoe  : Preapre for calling a stored procedure, pass the procedure name.
78728>>>>>>>>>    //***
78728>>>>>>>>>
78728>>>>>>>>>    Procedure SQLSetProcedureName String sProcName
78730>>>>>>>>>        Local Integer ihdbc
78730>>>>>>>>>        Local Integer ihstmt
78730>>>>>>>>>        Local String  sDrvrId
78730>>>>>>>>>        Local Integer iVoid
78730>>>>>>>>>        Local String  sEmpty
78730>>>>>>>>>
78730>>>>>>>>>        //*** Initialize
78730>>>>>>>>>        Move "" To sEmpty
78731>>>>>>>>>
78731>>>>>>>>>        //*** Get the cli handle to the connection
78731>>>>>>>>>        Get phCLIHandle       To ihstmt
78732>>>>>>>>>        Get psDriverId        To sDrvrId
78733>>>>>>>>>        Get phStmtConnection  To ihdbc
78734>>>>>>>>>
78734>>>>>>>>>        //*** Call the procedure
78734>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
78736>>>>>>>>>            //*** Call the procedure
78736>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLSETPROCNAME ;                        Callback Current_Object ;                        Passing ihdbc sProcName ihstmt ;                        Result iVoid
78741>>>>>>>>>
78741>>>>>>>>>            Set piLastArgument To 0
78742>>>>>>>>>        End
78742>>>>>>>>>>
78742>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetProcedurename"
78744>>>>>>>>>    End_Procedure // SQLSetProcedureName
78745>>>>>>>>>
78745>>>>>>>>>
78745>>>>>>>>>
78745>>>>>>>>>    //***
78745>>>>>>>>>    //*** Function: SQLSetNextArgument
78745>>>>>>>>>    //*** Purpose : Pass the next argument
78745>>>>>>>>>    //***
78745>>>>>>>>>
78745>>>>>>>>>    Procedure SQLSetNextArgument String sArgument
78747>>>>>>>>>        Local Integer iArgnum
78747>>>>>>>>>
78747>>>>>>>>>        Get piLastArgument To iArgnum
78748>>>>>>>>>        Increment iArgnum
78749>>>>>>>>>        Send SQLSetArgument iArgnum sArgument
78750>>>>>>>>>        Set piLastArgument To iArgnum
78751>>>>>>>>>    End_Procedure // SQLSetNextArgument
78752>>>>>>>>>
78752>>>>>>>>>
78752>>>>>>>>>
78752>>>>>>>>>    //***
78752>>>>>>>>>    //*** Procedure: SQLSetArgument
78752>>>>>>>>>    //*** Purpose  : Set the next argument
78752>>>>>>>>>    //***
78752>>>>>>>>>
78752>>>>>>>>>    Procedure SQLSetArgument Integer iArgnum String sArgument
78754>>>>>>>>>        Local Integer ihdbc
78754>>>>>>>>>        Local Integer ihstmt
78754>>>>>>>>>        Local String  sDrvrId
78754>>>>>>>>>        Local Integer iVoid
78754>>>>>>>>>        Local String  sEmpty
78754>>>>>>>>>
78754>>>>>>>>>        //*** Initialize
78754>>>>>>>>>        Move "" To sEmpty
78755>>>>>>>>>
78755>>>>>>>>>        //*** Get the cli handle to the connection
78755>>>>>>>>>        Get phCLIHandle       To ihstmt
78756>>>>>>>>>        Get psDriverId        To sDrvrId
78757>>>>>>>>>        Get phStmtConnection  To ihdbc
78758>>>>>>>>>
78758>>>>>>>>>        //*** Call the procedure
78758>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
78760>>>>>>>>>            //*** Pass the information
78760>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback Current_Object ;                        Passing ihdbc iArgnum ihstmt ;                        Result iVoid
78765>>>>>>>>>
78765>>>>>>>>>            //*** Pass the argument
78765>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLSETPROCARG ;                        Callback Current_Object ;                        Passing sArgument sEmpty 0 ;                        Result iVoid
78770>>>>>>>>>        End
78770>>>>>>>>>>
78770>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetArgument"
78772>>>>>>>>>    End_Procedure // SQLSetArgument
78773>>>>>>>>>
78773>>>>>>>>>
78773>>>>>>>>>
78773>>>>>>>>>    //***
78773>>>>>>>>>    //*** Procedure: SQLCall
78773>>>>>>>>>    //*** Purpose  : Call a stored procedure
78773>>>>>>>>>    //***
78773>>>>>>>>>
78773>>>>>>>>>    Procedure SQLCall
78775>>>>>>>>>        Local Integer ihdbc
78775>>>>>>>>>        Local Integer ihstmt
78775>>>>>>>>>        Local String  sDrvrId
78775>>>>>>>>>        Local Integer iVoid
78775>>>>>>>>>        Local String  sEmpty
78775>>>>>>>>>
78775>>>>>>>>>        //*** Initialize
78775>>>>>>>>>        Move "" To sEmpty
78776>>>>>>>>>
78776>>>>>>>>>        //*** Get the cli handle to the connection
78776>>>>>>>>>        Get phCLIHandle       To ihstmt
78777>>>>>>>>>        Get psDriverId        To sDrvrId
78778>>>>>>>>>        Get phStmtConnection  To ihdbc
78779>>>>>>>>>
78779>>>>>>>>>        //*** Call the procedure
78779>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
78781>>>>>>>>>            //*** Call the procedure
78781>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCALL ;                        Callback Current_Object ;                        Passing ihdbc sEmpty ihstmt ;                        Result iVoid
78786>>>>>>>>>
78786>>>>>>>>>            Set piLastArgument To 0
78787>>>>>>>>>        End
78787>>>>>>>>>>
78787>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLCall"
78789>>>>>>>>>    End_Procedure // SQLCall
78790>>>>>>>>>
78790>>>>>>>>>
78790>>>>>>>>>
78790>>>>>>>>>    //***
78790>>>>>>>>>    //*** Function: SQLGetNextArgument
78790>>>>>>>>>    //*** Purpose : Get the next argument
78790>>>>>>>>>    //***
78790>>>>>>>>>
78790>>>>>>>>>    Function SQLGetNextArgument Returns String
78792>>>>>>>>>        Local Integer iArgnum
78792>>>>>>>>>        Local String  sResult
78792>>>>>>>>>
78792>>>>>>>>>        Get piLastArgument To iArgnum
78793>>>>>>>>>        Increment iArgnum
78794>>>>>>>>>        Get SQLGetArgument iArgnum To sResult
78795>>>>>>>>>        Set piLastArgument To iArgnum
78796>>>>>>>>>
78796>>>>>>>>>        Function_return sResult
78797>>>>>>>>>    End_Function // SQLGetNextArgument
78798>>>>>>>>>
78798>>>>>>>>>
78798>>>>>>>>>
78798>>>>>>>>>    //***
78798>>>>>>>>>    //*** Function: SQLGetArgument
78798>>>>>>>>>    //*** Purpose : Get the specified argument from a procedure
78798>>>>>>>>>    //***
78798>>>>>>>>>
78798>>>>>>>>>    Function SQLGetArgument Integer iArgnum Returns String
78800>>>>>>>>>        Local Integer ihdbc
78800>>>>>>>>>        Local Integer ihstmt
78800>>>>>>>>>        Local String  sDrvrId
78800>>>>>>>>>        Local Integer iVoid
78800>>>>>>>>>        Local String  sEmpty
78800>>>>>>>>>        Local String  sArgument
78800>>>>>>>>>        Local Integer iLen
78800>>>>>>>>>
78800>>>>>>>>>        //*** Initialize
78800>>>>>>>>>        Move "" To sEmpty
78801>>>>>>>>>        Move "" To sArgument
78802>>>>>>>>>
78802>>>>>>>>>        //*** Get the cli handle to the connection
78802>>>>>>>>>        Get phCLIHandle       To ihstmt
78803>>>>>>>>>        Get psDriverId        To sDrvrId
78804>>>>>>>>>        Get phStmtConnection  To ihdbc
78805>>>>>>>>>
78805>>>>>>>>>        //*** Call the procedure
78805>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
78807>>>>>>>>>            //*** Pass the information
78807>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback Current_Object ;                        Passing ihdbc iArgnum ihstmt ;                        Result iVoid
78812>>>>>>>>>
78812>>>>>>>>>            //*** Get the length
78812>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLGETPROCARGLEN ;                        Callback Current_Object ;                        Passing sEmpty sEmpty 0 ;                        Result iLen
78817>>>>>>>>>
78817>>>>>>>>>            If (iLen) Begin
78819>>>>>>>>>                //*** Allocate
78819>>>>>>>>>                Move (Repeat(' ', iLen)) To sArgument
78820>>>>>>>>>
78820>>>>>>>>>                //*** Pass the argument
78820>>>>>>>>>                Call_driver 0 sDrvrId Function FUNC_SQLGETPROCARG ;                            Callback Current_Object ;                            Passing sArgument sEmpty 0 ;                            Result iVoid
78825>>>>>>>>>            End
78825>>>>>>>>>>
78825>>>>>>>>>        End
78825>>>>>>>>>>
78825>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetArgument"
78827>>>>>>>>>
78827>>>>>>>>>        Function_Return sArgument
78828>>>>>>>>>    End_Function // SQLGetArgument
78829>>>>>>>>>
78829>>>>>>>>>
78829>>>>>>>>>
78829>>>>>>>>>    //***
78829>>>>>>>>>    //*** Function: SQLReturnValue
78829>>>>>>>>>    //*** Purpose : Get the reutn value of a stored function
78829>>>>>>>>>    //***
78829>>>>>>>>>
78829>>>>>>>>>    Function SQLReturnValue Returns String
78831>>>>>>>>>        Local Integer ihdbc
78831>>>>>>>>>        Local Integer ihstmt
78831>>>>>>>>>        Local String  sDrvrId
78831>>>>>>>>>        Local Integer iVoid
78831>>>>>>>>>        Local String  sEmpty
78831>>>>>>>>>        Local String  sRetval
78831>>>>>>>>>        Local Integer iLen
78831>>>>>>>>>
78831>>>>>>>>>        //*** Initialize
78831>>>>>>>>>        Move "" To sEmpty
78832>>>>>>>>>        Move "" To sRetval
78833>>>>>>>>>
78833>>>>>>>>>        //*** Get the cli handle to the connection
78833>>>>>>>>>        Get phCLIHandle       To ihstmt
78834>>>>>>>>>        Get psDriverId        To sDrvrId
78835>>>>>>>>>        Get phStmtConnection  To ihdbc
78836>>>>>>>>>
78836>>>>>>>>>        //*** Call the procedure
78836>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
78838>>>>>>>>>            //*** Get the length
78838>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLGETPROCRETVALLEN ;                        Callback Current_Object ;                        Passing ihdbc sEmpty ihstmt  ;                        Result iLen
78843>>>>>>>>>
78843>>>>>>>>>            If (iLen) Begin
78845>>>>>>>>>                //*** Allocate
78845>>>>>>>>>                Move (Repeat(' ', iLen)) To sRetval
78846>>>>>>>>>
78846>>>>>>>>>                //*** Pass the argument
78846>>>>>>>>>                Call_driver 0 sDrvrId Function FUNC_SQLGETPROCRETVAL ;                            Callback Current_Object ;                            Passing ihdbc sRetval ihstmt ;                            Result iVoid
78851>>>>>>>>>            End
78851>>>>>>>>>>
78851>>>>>>>>>        End
78851>>>>>>>>>>
78851>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLReturnValue"
78853>>>>>>>>>
78853>>>>>>>>>        Function_Return sRetval
78854>>>>>>>>>    End_Function // SQLReturnValue
78855>>>>>>>>>
78855>>>>>>>>>
78855>>>>>>>>>
78855>>>>>>>>>    //***
78855>>>>>>>>>    //*** Function: SQLNextResultSet
78855>>>>>>>>>    //*** Purpose : Switch to the next set
78855>>>>>>>>>    //*** Returns : 0   = No more result sets
78855>>>>>>>>>    //***           <>0 = Switched to next set
78855>>>>>>>>>    //***
78855>>>>>>>>>
78855>>>>>>>>>    Function SQLNextResultSet Returns Integer
78857>>>>>>>>>        Local Integer ihdbc
78857>>>>>>>>>        Local Integer ihstmt
78857>>>>>>>>>        Local String  sDrvrId
78857>>>>>>>>>        Local String  sEmpty
78857>>>>>>>>>        Local Integer iResult
78857>>>>>>>>>
78857>>>>>>>>>        //*** Initialize
78857>>>>>>>>>        Move "" To sEmpty
78858>>>>>>>>>        Move 0  To iResult
78859>>>>>>>>>
78859>>>>>>>>>        //*** Get the cli handle to the connection
78859>>>>>>>>>        Get phCLIHandle       To ihstmt
78860>>>>>>>>>        Get psDriverId        To sDrvrId
78861>>>>>>>>>        Get phStmtConnection  To ihdbc
78862>>>>>>>>>
78862>>>>>>>>>        //*** Call the procedure
78862>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
78864>>>>>>>>>            //*** Get the length
78864>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLNEXTRESULTSET ;                        Callback Current_Object ;                        Passing ihdbc sEmpty ihstmt  ;                        Result iResult
78869>>>>>>>>>
78869>>>>>>>>>            Set piLastArgument To 0
78870>>>>>>>>>        End
78870>>>>>>>>>>
78870>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLNextResultSet"
78872>>>>>>>>>
78872>>>>>>>>>        Function_Return iResult
78873>>>>>>>>>    End_Function // SQLNextResultSet
78874>>>>>>>>>
78874>>>>>>>>>
78874>>>>>>>>>
78874>>>>>>>>>    //***
78874>>>>>>>>>    //*** Procedure: SQLFetchActivatesBuffer
78874>>>>>>>>>    //*** Purpose  : Setup a file that will be acivated after a succesfull
78874>>>>>>>>>    //***            fetch on the statement
78874>>>>>>>>>    //***
78874>>>>>>>>>
78874>>>>>>>>>    Procedure SQLFetchActivatesBuffer Integer iFileNum Integer bState
78876>>>>>>>>>        Local Integer ihdbc
78876>>>>>>>>>        Local Integer ihstmt
78876>>>>>>>>>        Local String  sDrvrId
78876>>>>>>>>>        Local Integer iResult
78876>>>>>>>>>        Local Integer bIsOpen
78876>>>>>>>>>        Local Integer iVoid
78876>>>>>>>>>        Local String  sFileType
78876>>>>>>>>>
78876>>>>>>>>>        //*** Check if file is open
78876>>>>>>>>>        Get_attribute DF_FILE_OPENED Of iFileNum To bIsOpen
78879>>>>>>>>>        If (bIsOpen) Begin
78881>>>>>>>>>            //*** Get the cli handle to the connection
78881>>>>>>>>>            Get phCLIHandle       To ihstmt
78882>>>>>>>>>            Get psDriverId        To sDrvrId
78883>>>>>>>>>            Get phStmtConnection  To ihdbc
78884>>>>>>>>>
78884>>>>>>>>>            //*** Call the procedure
78884>>>>>>>>>            If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
78886>>>>>>>>>                //*** Check if the file has the correct type
78886>>>>>>>>>                Get_attribute DF_FILE_DRIVER Of iFileNum To sFileType
78889>>>>>>>>>                If (sFileType = sDrvrId) Begin
78891>>>>>>>>>                    //*** Setup the buffer
78891>>>>>>>>>                    Call_driver iFileNum sDrvrId Function FUNC_SQLBUFFERSTATUS ;                                Callback Current_Object ;                                Passing ihdbc bState ihstmt  ;                                Result iVoid
78896>>>>>>>>>                End
78896>>>>>>>>>>
78896>>>>>>>>>                Else ;                    Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File" * String(iFileNum) * "type incompatible with statement ("  + sFileType + ")") "SQLBindFile"
78898>>>>>>>>>            End
78898>>>>>>>>>>
78898>>>>>>>>>            Else ;                Send HandleError ihstmt ihdbc sDrvrId "SQLFetchActivatesBuffer"
78900>>>>>>>>>        End
78900>>>>>>>>>>
78900>>>>>>>>>        Else ;            Send StmtError CLIERR_SQLINVALID_BUFFER ("File not open (number =" * String(iFileNum) + ")") "SQLFetchActivatesBuffer"
78902>>>>>>>>>    End_Procedure // SQLFetchActivatesBuffer
78903>>>>>>>>>
78903>>>>>>>>>End_Class // cSQLStatement
78904>>>>>>>>>
78904>>>>>>>>>
78904>>>>>>>>>//*****************************************************************************
78904>>>>>>>>>//*** Class  : cSQLConnection                                               ***
78904>>>>>>>>>//*** Purpose: Connection object for embedded SQL                           ***
78904>>>>>>>>>//***                                                                       ***
78904>>>>>>>>>//*** Description:                                                          ***
78904>>>>>>>>>//***   This provides the ability to create a connection for a driver.      ***
78904>>>>>>>>>//***   It will contain child statement objects                             ***
78904>>>>>>>>>//*****************************************************************************
78904>>>>>>>>>
78904>>>>>>>>>Class cSQLConnection is an Array
78905>>>>>>>>>
78905>>>>>>>>>    Procedure Construct_object Integer Image
78907>>>>>>>>>        Forward Send Construct_object Image
78909>>>>>>>>>
78909>>>>>>>>>        Property Integer phCLIHandle      Public 0
78910>>>>>>>>>        Property String  psDriverID       Public ""
78911>>>>>>>>>        Property Integer piBindFile       Public 0
78912>>>>>>>>>
78912>>>>>>>>>        Set Delegation_mode to NO_Delegation
78913>>>>>>>>>    End_procedure // COnstruct_object
78914>>>>>>>>>
78914>>>>>>>>>
78914>>>>>>>>>
78914>>>>>>>>>    //***
78914>>>>>>>>>    //*** Procedure: StoreHandleInfo
78914>>>>>>>>>    //*** Purpose  : Store basic information about the statement handle.
78914>>>>>>>>>    //***
78914>>>>>>>>>
78914>>>>>>>>>    Procedure StoreHandleInfo Integer iCLIHandle String sDrvrId Integer iParentHandle
78916>>>>>>>>>        Set phCLIHandle      To iCLIHandle
78917>>>>>>>>>        Set psDriverID       To sDrvrId
78918>>>>>>>>>    End_Procedure // StoreHandleInfo
78919>>>>>>>>>
78919>>>>>>>>>
78919>>>>>>>>>
78919>>>>>>>>>    //***
78919>>>>>>>>>    //*** Procedure: FreeHandle
78919>>>>>>>>>    //*** Purpose : Destroys handle object and all child statement objects
78919>>>>>>>>>    //***
78919>>>>>>>>>    Procedure FreeHandle
78921>>>>>>>>>        Send Destroy_Object
78922>>>>>>>>>    End_Procedure // FreeHandle
78923>>>>>>>>>
78923>>>>>>>>>
78923>>>>>>>>>
78923>>>>>>>>>    //***
78923>>>>>>>>>    //*** Function: SQLConnect
78923>>>>>>>>>    //*** Purpose : Make a connectin to an embedded SQL server
78923>>>>>>>>>    //*** Returns : The DataFlex handle to the connection
78923>>>>>>>>>    //***
78923>>>>>>>>>
78923>>>>>>>>>    Function SQLConnect string sDrvrID String sConnect Returns Integer
78925>>>>>>>>>        Local Integer ihdbc
78925>>>>>>>>>        Local String  sEmpty
78925>>>>>>>>>
78925>>>>>>>>>        //*** Initialize
78925>>>>>>>>>        Move "" To sEmpty
78926>>>>>>>>>        Move 0  To ihdbc
78927>>>>>>>>>
78927>>>>>>>>>        Indicate Err False
78928>>>>>>>>>
78928>>>>>>>>>        //*** Call the driver function to connect
78928>>>>>>>>>        Call_driver 0 sDrvrId Function FUNC_SQLCONNECT ;                    Callback current_object ;                    Passing sConnect sEmpty 0 ;                    Result ihdbc
78933>>>>>>>>>
78933>>>>>>>>>        //*** If there was an error, make result invalid
78933>>>>>>>>>        If (Err) ;            Move 0 To ihdbc
78936>>>>>>>>>
78936>>>>>>>>>        //*** Check result and store it
78936>>>>>>>>>        If (ihdbc <> 0) ;            Send StoreHandleInfo ihdbc sDrvrId 0
78939>>>>>>>>>
78939>>>>>>>>>        //*** Return success status
78939>>>>>>>>>        Function_Return (ihdbc <> 0)
78940>>>>>>>>>    End_function // SQLConnect
78941>>>>>>>>>
78941>>>>>>>>>
78941>>>>>>>>>
78941>>>>>>>>>    //***
78941>>>>>>>>>    //*** Function: SQLFileConnect
78941>>>>>>>>>    //*** Purpose : Use a connection of an already open file
78941>>>>>>>>>    //***
78941>>>>>>>>>
78941>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
78943>>>>>>>>>        Local Integer ihdbc
78943>>>>>>>>>        Local Integer bIsOpen
78943>>>>>>>>>        Local String  sDrvrId
78943>>>>>>>>>        Local String  sEmpty
78943>>>>>>>>>
78943>>>>>>>>>        //*** Initialize
78943>>>>>>>>>        Move "" To sEmpty
78944>>>>>>>>>        Move 0  To ihdbc
78945>>>>>>>>>
78945>>>>>>>>>        //*** Check if file is open
78945>>>>>>>>>        Get_attribute DF_FILE_OPENED Of iFileNum To bIsOpen
78948>>>>>>>>>        If (bIsOpen) Begin
78950>>>>>>>>>            //*** Fill the driver id, assume longest is 255 characters
78950>>>>>>>>>            Move (Repeat(' ', 255)) To sDrvrId
78951>>>>>>>>>            Get_attribute DF_FILE_DRIVER Of iFileNum To sDrvrId
78954>>>>>>>>>
78954>>>>>>>>>            Indicate Err False
78955>>>>>>>>>
78955>>>>>>>>>            //*** Call the driver function to connect
78955>>>>>>>>>            Call_driver iFileNum sDrvrId Function FUNC_SQLFILECONNECT ;                        Callback current_object ;                        Passing sEmpty sEmpty 0 ;                        Result ihdbc
78960>>>>>>>>>
78960>>>>>>>>>            //*** If there was an error, make result invalid
78960>>>>>>>>>            If (Err) ;                Move 0 To ihdbc
78963>>>>>>>>>
78963>>>>>>>>>            //*** Check result and store it
78963>>>>>>>>>            If (ihdbc <> 0) Begin
78965>>>>>>>>>                //*** Somehow Call_driver overwrites the sDrvrId variable, restore it here
78965>>>>>>>>>                Get_attribute DF_FILE_DRIVER Of iFileNum To sDrvrId
78968>>>>>>>>>                Send StoreHandleInfo ihdbc sDrvrId 0
78969>>>>>>>>>
78969>>>>>>>>>                //*** Set filenum so it can be used for fetching
78969>>>>>>>>>                Set piBindFile To iFileNum
78970>>>>>>>>>            End
78970>>>>>>>>>>
78970>>>>>>>>>        End
78970>>>>>>>>>>
78970>>>>>>>>>
78970>>>>>>>>>        //*** Return success status
78970>>>>>>>>>        Function_Return (ihdbc <> 0)
78971>>>>>>>>>    End_Function // SQLFileConnect
78972>>>>>>>>>
78972>>>>>>>>>
78972>>>>>>>>>
78972>>>>>>>>>    //***
78972>>>>>>>>>    //*** Procedure: SQLDisconnect
78972>>>>>>>>>    //*** Purpose  : Disconnect from an embedded SQL server and free allocated
78972>>>>>>>>>    //***            resources
78972>>>>>>>>>    //***
78972>>>>>>>>>
78972>>>>>>>>>    Procedure SQLDisconnect
78974>>>>>>>>>        Local Integer ihdbc
78974>>>>>>>>>        Local Integer iVoid
78974>>>>>>>>>        Local String  sDrvrId
78974>>>>>>>>>        Local String  sEmpty
78974>>>>>>>>>
78974>>>>>>>>>        //*** Initialize
78974>>>>>>>>>        Move "" To sEmpty
78975>>>>>>>>>
78975>>>>>>>>>        //*** Get the cli handle
78975>>>>>>>>>        Get phCLIHandle To ihdbc
78976>>>>>>>>>        Get psDriverId To sDrvrId
78977>>>>>>>>>
78977>>>>>>>>>        //*** Free the CLI handle
78977>>>>>>>>>        If (ihdbc <> 0) Begin
78979>>>>>>>>>            //*** Call the driver function to disconnect
78979>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLDISCONNECT ;                        Callback Current_object ;                        Passing sEmpty sEmpty ihdbc ;                        Result iVoid
78984>>>>>>>>>
78984>>>>>>>>>            //*** Free the DataFlex handle
78984>>>>>>>>>            Send FreeHandle
78985>>>>>>>>>        End
78985>>>>>>>>>>
78985>>>>>>>>>    End_Procedure // SQLDisconnect
78986>>>>>>>>>
78986>>>>>>>>>
78986>>>>>>>>>
78986>>>>>>>>>    //***
78986>>>>>>>>>    //*** Function: CreateHandle
78986>>>>>>>>>    //*** Purpose : Creates a child statement handle
78986>>>>>>>>>    //***
78986>>>>>>>>>
78986>>>>>>>>>    Function CreateHandle Returns Integer
78988>>>>>>>>>        Local Integer hSQL
78988>>>>>>>>>
78988>>>>>>>>>        Object oSQLStatement Is A cSQLStatement
78990>>>>>>>>>            Move current_object To hSQL
78991>>>>>>>>>        End_Object // oSQLStatement
78992>>>>>>>>>
78992>>>>>>>>>        //*** If the connection has a default Bind File, assign it to the
78992>>>>>>>>>        //*** statement object. The default is set when you open a file with a
78992>>>>>>>>>        //*** SetFileConnection command.
78992>>>>>>>>>        Set piBindFile Of hSQL To (piBindFile(Current_object))
78993>>>>>>>>>
78993>>>>>>>>>        Function_Return hSQL
78994>>>>>>>>>    End_Function // CreateHandle
78995>>>>>>>>>
78995>>>>>>>>>
78995>>>>>>>>>
78995>>>>>>>>>    //***
78995>>>>>>>>>    //*** Function: SQLOpen
78995>>>>>>>>>    //*** Prupose : Open a statement for use
78995>>>>>>>>>    //***
78995>>>>>>>>>
78995>>>>>>>>>    Function SQLOpen Returns Integer
78997>>>>>>>>>        Local Integer hDFHandle
78997>>>>>>>>>        Local Integer ihdbc
78997>>>>>>>>>        Local Integer ihstmt
78997>>>>>>>>>        Local Integer iVoid
78997>>>>>>>>>        Local String  sDrvrId
78997>>>>>>>>>        Local String  sEmpty
78997>>>>>>>>>
78997>>>>>>>>>        //*** Initialize
78997>>>>>>>>>        Move "" To sEmpty
78998>>>>>>>>>
78998>>>>>>>>>        //*** Get the cli handle to the connection
78998>>>>>>>>>        Get phCLIHandle To ihdbc
78999>>>>>>>>>        Get psDriverId  To sDrvrId
79000>>>>>>>>>
79000>>>>>>>>>        //*** Allocate a new handle and populate it
79000>>>>>>>>>        If (ihdbc <> 0) Begin
79002>>>>>>>>>            //**** Create a new DataFlex handle
79002>>>>>>>>>            Get CreateHandle To hDFHandle
79003>>>>>>>>>
79003>>>>>>>>>            //*** Call the driver function to allocate a statement handle
79003>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLOPEN ;                        Callback Current_object ;                        Passing hDFHandle sEmpty ihdbc ;                        Result ihstmt
79008>>>>>>>>>
79008>>>>>>>>>            //*** If unsuccessful destroy DF side info
79008>>>>>>>>>            If (ihstmt = 0) Begin
79010>>>>>>>>>                Send FreeHandle to hDFHandle
79011>>>>>>>>>                Move 0 to hDFHandle
79012>>>>>>>>>            End
79012>>>>>>>>>>
79012>>>>>>>>>            Else ;                Send StoreHandleInfo to hDFHandle ihstmt sDrvrId ihdbc
79014>>>>>>>>>        End
79014>>>>>>>>>>
79014>>>>>>>>>
79014>>>>>>>>>        Function_return hDFHandle
79015>>>>>>>>>    End_function // SQLOpen
79016>>>>>>>>>
79016>>>>>>>>>End_Class // cSQLConnection
79017>>>>>>>>>
79017>>>>>>>>>
79017>>>>>>>>>
79017>>>>>>>>>//*****************************************************************************
79017>>>>>>>>>//*** Class  : cSQLHandlemanager                                            ***
79017>>>>>>>>>//*** Purpose: Manager for embedded SQL handles.                            ***
79017>>>>>>>>>//***                                                                       ***
79017>>>>>>>>>//*** Description:                                                          ***
79017>>>>>>>>>//***   We want to be able to use multiple drivers and multiple             ***
79017>>>>>>>>>//***   connections within a driver and multiple statements within a        ***
79017>>>>>>>>>//***   connection. To allow this we have palced our own handle logic on    ***
79017>>>>>>>>>//***   top of the driver handle logic. This way we can handle the          ***
79017>>>>>>>>>//***   situation where two driver handles may be equal.                    ***
79017>>>>>>>>>//*****************************************************************************
79017>>>>>>>>>
79017>>>>>>>>>Class cSQLHandleManager Is A Array
79018>>>>>>>>>
79018>>>>>>>>>    Procedure Construct_object Integer Image
79020>>>>>>>>>        Forward Send Construct_object Image
79022>>>>>>>>>
79022>>>>>>>>>        Property String  psDefaultDriver     Public ""
79023>>>>>>>>>        Property String  psDefaultConnection Public ""
79024>>>>>>>>>
79024>>>>>>>>>        Set Delegation_mode to NO_Delegation
79025>>>>>>>>>    End_procedure // COnstruct_object
79026>>>>>>>>>
79026>>>>>>>>>
79026>>>>>>>>>
79026>>>>>>>>>    //***
79026>>>>>>>>>    //*** Function: CreateHandle
79026>>>>>>>>>    //*** Purpose : Allocate memory for the desired type of handle
79026>>>>>>>>>    //***
79026>>>>>>>>>
79026>>>>>>>>>    Function CreateHandle Returns Integer
79028>>>>>>>>>        Local Integer hSQL
79028>>>>>>>>>
79028>>>>>>>>>        //*** Create a connection object
79028>>>>>>>>>        Object oSQLConnection Is A cSQLConnection
79030>>>>>>>>>            Move current_object To hSQL
79031>>>>>>>>>        End_Object // oSQLConnection
79032>>>>>>>>>
79032>>>>>>>>>        Function_Return hSQL
79033>>>>>>>>>    End_Function // CreateHandle
79034>>>>>>>>>
79034>>>>>>>>>
79034>>>>>>>>>
79034>>>>>>>>>    //***
79034>>>>>>>>>    //*** Procedure: SQLSetConnect
79034>>>>>>>>>    //*** Purpose  : Store default connection information
79034>>>>>>>>>    //***
79034>>>>>>>>>
79034>>>>>>>>>    Procedure SQLSetConnect String sDriver String sConnect
79036>>>>>>>>>        Set psDefaultDriver      To sDriver
79037>>>>>>>>>        Set psDefaultConnection  To sConnect
79038>>>>>>>>>    End_Procedure // SQLSetConnect
79039>>>>>>>>>
79039>>>>>>>>>
79039>>>>>>>>>
79039>>>>>>>>>    //***
79039>>>>>>>>>    //*** Function: SQLConnect
79039>>>>>>>>>    //*** Purpose : Make a connectin to an embedded SQL server
79039>>>>>>>>>    //*** Returns : The DataFlex handle to the connection
79039>>>>>>>>>    //***
79039>>>>>>>>>
79039>>>>>>>>>    Function SQLConnect String sDrvrID String sConnect Returns integer
79041>>>>>>>>>        Local Integer hDFHandle
79041>>>>>>>>>        Local Integer bOK
79041>>>>>>>>>
79041>>>>>>>>>        //*** Check arguments
79041>>>>>>>>>        If (sDrvrID = "" And sConnect = "") Begin
79043>>>>>>>>>            Get psDefaultDriver      To sDrvrId
79044>>>>>>>>>            Get psDefaultConnection  To sConnect
79045>>>>>>>>>        End
79045>>>>>>>>>>
79045>>>>>>>>>
79045>>>>>>>>>        //*** Allocate a new handle
79045>>>>>>>>>        Get CreateHandle To hDFHandle
79046>>>>>>>>>        Get SQLConnect of hDFHandle sDrvrID sConnect To bOK
79047>>>>>>>>>
79047>>>>>>>>>        //*** If failure, kill the handle and return a 0 handle
79047>>>>>>>>>        If (Not(bOK)) Begin
79049>>>>>>>>>            Send FreeHandle to hDFHandle
79050>>>>>>>>>            Move 0 to hDFHandle
79051>>>>>>>>>        End
79051>>>>>>>>>>
79051>>>>>>>>>
79051>>>>>>>>>        Function_return hDFHandle
79052>>>>>>>>>    End_function // SQLConnect
79053>>>>>>>>>
79053>>>>>>>>>
79053>>>>>>>>>
79053>>>>>>>>>    //***
79053>>>>>>>>>    //*** Function: SQLFileConnect
79053>>>>>>>>>    //*** Purpose : Make an existing connection available for use with Embedded
79053>>>>>>>>>    //***           SQL. The connection is identified by the number opf a file
79053>>>>>>>>>    //***           that is open for that connection.
79053>>>>>>>>>    //***
79053>>>>>>>>>
79053>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
79055>>>>>>>>>        Local Integer hDFHandle
79055>>>>>>>>>        Local Integer bOK
79055>>>>>>>>>
79055>>>>>>>>>        //*** Allocate a new handle
79055>>>>>>>>>        Get CreateHandle To hDFHandle
79056>>>>>>>>>        Get SQLFileConnect of hDFHandle iFileNum To bOK
79057>>>>>>>>>
79057>>>>>>>>>        //*** If failure, kill the handle and return a 0 handle
79057>>>>>>>>>        If (Not(bOK)) Begin
79059>>>>>>>>>            Send FreeHandle to hDFHandle
79060>>>>>>>>>            Move 0 to hDFHandle
79061>>>>>>>>>        End
79061>>>>>>>>>>
79061>>>>>>>>>
79061>>>>>>>>>        Function_return hDFHandle
79062>>>>>>>>>    End_Function // SQLFileConnect
79063>>>>>>>>>
79063>>>>>>>>>End_Class // cSQLHandleManager
79064>>>>>>>>>
79064>>>>>>>>>
79064>>>>>>>>>
79064>>>>>>>>>//***
79064>>>>>>>>>//*** Function: CreateSQLManager
79064>>>>>>>>>//*** Purpose : Create the embedded SQL manager, this is an internal function!
79064>>>>>>>>>//***
79064>>>>>>>>>
79064>>>>>>>>>Function CreateSQLmanager For Desktop Returns Integer
79066>>>>>>>>>    Local Integer hoSQlMngr
79066>>>>>>>>>
79066>>>>>>>>>    Object oSQLHandleManager Is A cSQLHandleManager
79068>>>>>>>>>        MOve Current_object To hoSQLMngr
79069>>>>>>>>>    End_Object // oSQLHandleManager
79070>>>>>>>>>
79070>>>>>>>>>    Function_Return hoSQLMngr
79071>>>>>>>>>End_Function // CreateSQLMngr
79072>>>>>>>>>
79072>>>>>>>>>//*** Make sure the object is global by creating it under DESKTOP
79072>>>>>>>>>Get CreateSQLManager Of Desktop To _embsqlghoSQLHandleMngr
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>//*** Command: SQLSetConnect                                                ***
79073>>>>>>>>>//*** Purpose: Setup default connection information for embedded SQL.       ***
79073>>>>>>>>>//***                                                                       ***
79073>>>>>>>>>//*** Syntax : SQLSetConnect sSDriverId sConnectString                      ***
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>//*** Command: SQLConnect                                                   ***
79073>>>>>>>>>//*** Purpose: Connect to a server for embedded SQL usage.                  ***
79073>>>>>>>>>//***                                                                       ***
79073>>>>>>>>>//*** Syntax : SQLConnect To hdbc                                           ***
79073>>>>>>>>>//***          SQLConnect [sDriverId sConnectString] To hdbc                ***
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>//*** Command: SQLFileConnect                                               ***
79073>>>>>>>>>//*** Purpsoe: Return the handle to a connection of an open file. This      ***
79073>>>>>>>>>//***          connection is (obviously) already opened. We are just using  ***
79073>>>>>>>>>//***          the same connection for Embedded SQL. This allows the        ***
79073>>>>>>>>>//***          programmer not to know connection details.                   ***
79073>>>>>>>>>//***                                                                       ***
79073>>>>>>>>>//*** Syntax : SQLFileConnect Filex To hdbc                                 ***
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>//*** Command: SQLDisconnect                                                ***
79073>>>>>>>>>//*** Purpose: Connect to a server for embedded SQL usage.                  ***
79073>>>>>>>>>//***                                                                       ***
79073>>>>>>>>>//*** Syntax : SQLDisConnect hdbc                                           ***
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>//*** Command: SQLOpen                                                      ***
79073>>>>>>>>>//*** Purpose: Allocate the memory to stroe statement information.          ***
79073>>>>>>>>>//***                                                                       ***
79073>>>>>>>>>//*** Syntax : SQLOpen hdbc To hstmt                                        ***
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>//*** Command: SQLClose                                                     ***
79073>>>>>>>>>//*** Purpose: Close a statement and free all associated memory.            ***
79073>>>>>>>>>//***                                                                       ***
79073>>>>>>>>>//*** Syntax : SQLClose hstmt                                               ***
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>//*** Command: SQLPrepare                                                   ***
79073>>>>>>>>>//*** Purpose: Prepare a statement for execution.                           ***
79073>>>>>>>>>//***                                                                       ***
79073>>>>>>>>>//*** Syntax : SQLPrepare hstmt sStatement                                  ***
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>//*** Command: SQLExecute                                                   ***
79073>>>>>>>>>//*** Purpose: Execute a prepared statement                                 ***
79073>>>>>>>>>//***                                                                       ***
79073>>>>>>>>>//*** Syntax : SQLExecute hstmt                                             ***
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>//*** Command: SQLExecDirect                                                ***
79073>>>>>>>>>//*** Purpose: Prepare and execute a statement.                             ***
79073>>>>>>>>>//***                                                                       ***
79073>>>>>>>>>//*** Syntax : SQLExecDirect hstmt sStatement                               ***
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>//*** Command: SQLFileFetch                                                 ***
79073>>>>>>>>>//*** Purpose: Get a row from a statement result set.                       ***
79073>>>>>>>>>//***                                                                       ***
79073>>>>>>>>>//*** Syntax : SQLFileFetch hstmt [To File1 [File2 ...]]                    ***
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>//*** Command: SQLBindFetchFile                                             ***
79073>>>>>>>>>//*** Purpose: Binds a file number to a statement so it can be used for     ***
79073>>>>>>>>>//***          fetching data. Only needed in non fileconnect. Note that     ***
79073>>>>>>>>>//***          can be assigned to the connection or the statement handle    ***
79073>>>>>>>>>//***                                                                       ***
79073>>>>>>>>>//*** Syntax : SQLBindFileForFetch hstmt|hdbc FileName|FileNumber           ***
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>//*** Command: SQLFetch                                                     ***
79073>>>>>>>>>//*** Purpose: Get a row from a statement result set.                       ***
79073>>>>>>>>>//***                                                                       ***
79073>>>>>>>>>//*** Syntax : SQLFetch hstmt [To Var1 [Var2 ...]]                          ***
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>//*** Command: SQLGetData                                                   ***
79073>>>>>>>>>//*** Purpose: Get a column's data.                                         ***
79073>>>>>>>>>//***                                                                       ***
79073>>>>>>>>>//*** Syntax : SQLGetData hstmt iColumnNUmber [Length iLen] To Var          ***
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>//*** Command: SQLColumnMap                                                 ***
79073>>>>>>>>>//*** Purpose: Determine the column number based on the column name.        ***
79073>>>>>>>>>//***                                                                       ***
79073>>>>>>>>>//*** Syntax : SQLColumnMap hstmt sColName To iColNumber                    ***
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>//*** Command: SQLColAttribute                                              ***
79073>>>>>>>>>//*** Purpose: Get an attribute of a column in a statements result set.     ***
79073>>>>>>>>>//***                                                                       ***
79073>>>>>>>>>//*** Syntax : SQLColAttribute hstmt iCol iAttrId To sAttrib                ***
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>//*** Command: SQLStmtAttribute                                             ***
79073>>>>>>>>>//*** Purpose: Get an atribute of a statement.                              ***
79073>>>>>>>>>//***                                                                       ***
79073>>>>>>>>>//*** Syntax : SQLStmtAttribute hstmt iAttribId To sAttrib                  ***
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>//*** Command: SQLCall                                                      ***
79073>>>>>>>>>//*** Purpose: Call a stored procedure.                                     ***
79073>>>>>>>>>//***                                                                       ***
79073>>>>>>>>>//*** Syntax : SQLCall hstmt ProcedureName [Arg1 ...] [To Var]              ***
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>//*** Command: SQLGetArguments                                              ***
79073>>>>>>>>>//*** Purpsoe: Get the arguments of a stored procedure. This command should ***
79073>>>>>>>>>//***          be used when a procedure has multiple result sets. Some      ***
79073>>>>>>>>>//***          backends (SQL SErver for example) will return these as the   ***
79073>>>>>>>>>//***          last result set. This emans you first process all other      ***
79073>>>>>>>>>//***          result sets and then get the arguments and return value.     ***
79073>>>>>>>>>//***                                                                       ***
79073>>>>>>>>>//*** Syntax : SQLGetArguments hstmt [Arg1...] [To Var]                     ***
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>//*** Command: SQLNextResultSet                                             ***
79073>>>>>>>>>//*** Purpose: Go the the next result set. This command should be used when ***
79073>>>>>>>>>//***          a procedure call results in multiple result sets. Processing ***
79073>>>>>>>>>//***          such procedures can be done by loping through the result     ***
79073>>>>>>>>>//***          sets.                                                        ***
79073>>>>>>>>>//***                                                                       ***
79073>>>>>>>>>//*** Syntax : SQLNextResultSet hstmt                                       ***
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>//*** Command: SQLFetchActivatesBuffer                                      ***
79073>>>>>>>>>//*** Purpose: Setup fetch behavior for a file. When set to true a          ***
79073>>>>>>>>>//***          succesfull fetch of the statement resutl set will            ***
79073>>>>>>>>>//***          automatically set the status of the file's bufer to          ***
79073>>>>>>>>>//***          DF_FILE_ACTIVE.                                              ***
79073>>>>>>>>>//***                                                                       ***
79073>>>>>>>>>//*** Syntax : SQLFetchActivatesBuffer hstmt FileNUmber|FileName sState     ***
79073>>>>>>>>>//*****************************************************************************
79073>>>>>>>>>
79073>>>>>>>>>//Doc/ Ignore=False
79073>>>>>>>
79073>>>>>>>// defines interface for cWindowMesageHook - currently a private runtime class
79073>>>>>>>Define     U_DFWINDOWSMESSAGEHOOK  for |CI0106
79073>>>>>>>Define     GET_ENABLEWINDOWSHOOK   for |CI$0542
79073>>>>>>>Define     MSG_DISABLEWINDOWSHOOK  for |CI$0543
79073>>>>>>>Define     GET_ONWINDOWSHOOK       for |CI$0544
79073>>>>>>>Define     WH_MOUSE for 7
79073>>>>>>>Define     WH_KEYBOARD for 2
79073>>>>>>>
79073>>>>>>>
79073>>>>>>>// suggestion lists use a global timer and a global suggestion list
79073>>>>>>>Global_Variable Handle ghoSuggestionList 
79073>>>>>>>Move 0 to ghoSuggestionList
79074>>>>>>>
79074>>>>>>>Global_Variable Handle ghoSuggestionTimer
79074>>>>>>>Move 0 to ghoSuggestionTimer
79075>>>>>>>
79075>>>>>>>// this will get created the first time it is needed. 
79075>>>>>>>Class cSuggestionTimer is a cTimer
79076>>>>>>>
79076>>>>>>>    Procedure Construct_Object
79078>>>>>>>        Forward Send Construct_Object
79080>>>>>>>        Property Handle phoTimerOwner 0
79081>>>>>>>        Set piTimeout to 50
79082>>>>>>>    End_Procedure
79083>>>>>>>  
79083>>>>>>>    Procedure OnTimer 
79085>>>>>>>        Handle hoOwner
79085>>>>>>>        Get phoTimerOwner to hoOwner
79086>>>>>>>        // do this in case progam close destroys owner before timer
79086>>>>>>>        Get Object_Id of hoOwner to hoOwner
79087>>>>>>>        If hoOwner Begin
79089>>>>>>>            Send OnSuggestionTimer to hoOwner
79090>>>>>>>        End
79090>>>>>>>>
79090>>>>>>>        Else Begin
79091>>>>>>>            // something wrong, shut off timer
79091>>>>>>>            Set pbEnabled to False   
79092>>>>>>>        End                                
79092>>>>>>>>
79092>>>>>>>    End_Procedure
79093>>>>>>>    
79093>>>>>>>End_Class
79094>>>>>>>
79094>>>>>>>Class cSuggestionHookMouse is a DFWindowsMessageHook
79095>>>>>>>    
79095>>>>>>>    // If mouse not in suggestion list or form, close suggestionlist
79095>>>>>>>    Function OnWindowsHook Integer i1 Integer i2 Integer i3 Returns Integer
79097>>>>>>>        tWinMouseHookStruct MouseHook
79097>>>>>>>        tWinMouseHookStruct MouseHook
79097>>>>>>>        Integer ivoid hObj
79097>>>>>>>        Handle hoOwner hoParent
79097>>>>>>>        If (i1=0 and (i2=WM_LBUTTONDOWN or i2=WM_RBUTTONDOWN or i2=WM_MBUTTONDOWN or ;                      i2=WM_NCLBUTTONDOWN or i2=WM_NCRBUTTONDOWN or i2=WM_NCMBUTTONDOWN)) Begin
79099>>>>>>>            Move (CopyMemory(AddressOf(MouseHook), i3, SizeOfType(tWinMouseHookStruct))) to iVoid
79100>>>>>>>            GET_OBJECT_FROM_WINDOW MouseHook.hwnd to hObj
79101>>>>>>>            Get Parent to hoParent
79102>>>>>>>            Get phoOwner of hoParent to hoOwner
79103>>>>>>>            If (not(hObj) or (hObj<>hoParent and hObj<>hoOwner)) Begin
79105>>>>>>>                Send DisableWindowsHook
79106>>>>>>>                Send DeActivateSuggestionList of hoOwner
79107>>>>>>>            End
79107>>>>>>>>
79107>>>>>>>        End
79107>>>>>>>>
79107>>>>>>>    End_Function
79108>>>>>>>
79108>>>>>>>    Procedure End_Construct_Object
79110>>>>>>>        Boolean bOk
79110>>>>>>>        Forward Send End_Construct_Object
79112>>>>>>>        Get EnableWindowsHook WH_MOUSE to bOk 
79113>>>>>>>    End_Procedure
79114>>>>>>>
79114>>>>>>>End_Class
79115>>>>>>>
79115>>>>>>>Class cSuggestionHookKbd is a DFWindowsMessageHook
79116>>>>>>>    
79116>>>>>>>    // If menu key, close suggestionlist
79116>>>>>>>    Function OnWindowsHook Integer i1 Integer i2 Integer i3 Returns Integer
79118>>>>>>>        Handle hoOwner
79118>>>>>>>        If (i1=0 and i2=VK_MENU) Begin
79120>>>>>>>            Delegate Get phoOwner to hoOwner
79122>>>>>>>            Send DisableWindowsHook
79123>>>>>>>            Send DeActivateSuggestionList of hoOwner
79124>>>>>>>        End
79124>>>>>>>>
79124>>>>>>>    End_Function
79125>>>>>>>    
79125>>>>>>>    Procedure End_Construct_Object
79127>>>>>>>        Boolean bOk
79127>>>>>>>        Forward Send End_Construct_Object
79129>>>>>>>        Get EnableWindowsHook WH_KEYBOARD  to bOk  
79130>>>>>>>    End_Procedure
79131>>>>>>>
79131>>>>>>>End_Class
79132>>>>>>>
79132>>>>>>>Class cSuggestionList is a cRichEdit
79133>>>>>>>    
79133>>>>>>>    Procedure Construct_Object
79135>>>>>>>        Handle hoObj
79135>>>>>>>        Forward Send Construct_Object
79137>>>>>>>        Property Handle phoOwner
79138>>>>>>>        Set Focus_Mode to NonFocusable
79139>>>>>>>        Set Attach_Parent_State to True
79140>>>>>>>        Set pbWrap to False
79141>>>>>>>        If (ghoSuggestionList) Begin
79143>>>>>>>            Send Destroy of ghoSuggestionList
79144>>>>>>>        End
79144>>>>>>>>
79144>>>>>>>        Get CreateNamed (RefClass(cSuggestionHookMouse)) "oMouseHook" to hoObj
79145>>>>>>>        Get CreateNamed (RefClass(cSuggestionHookKbd))"oKbdHook" to hoObj
79146>>>>>>>    End_Procedure
79147>>>>>>>    
79147>>>>>>>    Procedure Destroy_Object
79149>>>>>>>        Forward Send Destroy_Object
79151>>>>>>>        Move 0 to ghoSuggestionList
79152>>>>>>>    End_Procedure
79153>>>>>>>    
79153>>>>>>>    Procedure DeactivateList
79155>>>>>>>        Set pbEnabled of ghoSuggestionTimer to False
79156>>>>>>>        Send Deactivate
79157>>>>>>>        Send Destroy
79158>>>>>>>    End_Procedure
79159>>>>>>>    
79159>>>>>>>    Procedure InitList Handle hoForm
79161>>>>>>>        Integer iSize iLoc iLoc2
79161>>>>>>>        Get GuiSize of hoForm to iSize
79162>>>>>>>        Set GuiSize to (Hi(iSize)) (1000)
79163>>>>>>>        Get Absolute_GUIOrigin of hoForm to iLoc
79164>>>>>>>        Delegate Get Absolute_GUIOrigin to iLoc2
79166>>>>>>>        Set GuiLocation to (Hi(iLoc)-Hi(iLoc2)+Hi(iSize)+2) (Low(iLoc)+2-Low(iLoc2))
79167>>>>>>>        Set Visible_State to False
79168>>>>>>>    End_Procedure
79169>>>>>>>    
79169>>>>>>>    // scroll up one line
79169>>>>>>>    Procedure ScrollUp
79171>>>>>>>        Integer iLine
79171>>>>>>>        Get SelectedRow to iLine
79172>>>>>>>        If (iLine) Begin
79174>>>>>>>            Send SelectRow (iLine-1)
79175>>>>>>>        End
79175>>>>>>>>
79175>>>>>>>    End_Procedure
79176>>>>>>>    
79176>>>>>>>    // scroll down one line
79176>>>>>>>    Procedure ScrollDown
79178>>>>>>>        Integer iLine iLines
79178>>>>>>>        Get Line_Count to iLines
79179>>>>>>>        Get SelectedRow to iLine
79180>>>>>>>        // there can be an extra line at the end
79180>>>>>>>        If (iLine<iLines-1) Begin
79182>>>>>>>            Send SelectRow (iLine+1)
79183>>>>>>>        End
79183>>>>>>>>
79183>>>>>>>    End_Procedure
79184>>>>>>>    
79184>>>>>>>    // sets the current line to iLine and highlights it
79184>>>>>>>    Procedure SelectRow Integer iLine
79186>>>>>>>        Integer iPos iLen
79186>>>>>>>        Get FirstCharInLinePos iLine to iPos
79187>>>>>>>        Get LineLength iLine to iLen
79188>>>>>>>        Send SetSel iPos (iPos+iLen)
79189>>>>>>>    End_Procedure
79190>>>>>>>    
79190>>>>>>>    // get the current selected Line
79190>>>>>>>    Function SelectedRow Returns Integer
79192>>>>>>>        Integer iLine
79192>>>>>>>        Get LineFromChar -1 to iLine
79193>>>>>>>        Function_Return iLine
79194>>>>>>>    End_Function
79195>>>>>>>
79195>>>>>>>    // select the current row 
79195>>>>>>>    Procedure Mouse_Up Integer hCell Integer iPos
79197>>>>>>>        Handle hoObj
79197>>>>>>>        Get phoOwner to hoObj
79198>>>>>>>        Send Activate of hoObj // move focus to owner, which will close the list
79199>>>>>>>        Send SelectSuggestion of hoObj
79200>>>>>>>    End_Procedure // Mouse_Up
79201>>>>>>>      
79201>>>>>>>End_Class
79202>>>>>>>
79202>>>>>>>// This contains mixin support for suggestion logic and contains the interface that
79202>>>>>>>// is accessed publicly. This should be mixed into the form or column DEO object
79202>>>>>>>Class cSuggestion_mixin is a Mixin
79203>>>>>>>    
79203>>>>>>>    Procedure Define_cSuggestion_mixin
79205>>>>>>>        
79205>>>>>>>        Property Integer peSuggestionMode smFind
79206>>>>>>>        Property Boolean pbFullText False
79207>>>>>>>        Property Boolean pbCaseSensitive False
79208>>>>>>>        Property Integer piMaxResults 15
79209>>>>>>>        Property Integer piStartAtChar 2
79210>>>>>>>        Property Boolean pbFullWidth True
79211>>>>>>>        Property Integer piFindIndex 0
79212>>>>>>>        Property Boolean pbFindOnSelect True
79213>>>>>>>        Property Integer piPopupTimeout 50
79214>>>>>>>        
79214>>>>>>>        Property tSuggestion[] pSearchResults
79215>>>>>>>
79215>>>>>>>        Property Handle phcSuggestionListClass (RefClass(cSuggestionList))
79216>>>>>>>        
79216>>>>>>>    End_Procedure
79217>>>>>>>    
79217>>>>>>>    // Display one Suggestion Line in Suggestion List. Good for augmentation although
79217>>>>>>>    // this must be done carefully as you must know the suggestionlist interface, which
79217>>>>>>>    // if private
79217>>>>>>>    Procedure ShowSuggestion tSuggestion SuggestionData String sSearch
79219>>>>>>>        Integer i iCols iPos
79219>>>>>>>        String sValue
79219>>>>>>>        Integer eSuggestionMode
79219>>>>>>>        Boolean bFullText
79219>>>>>>>        
79219>>>>>>>        Get peSuggestionMode to eSuggestionMode
79220>>>>>>>        Get pbFullText to bFullText
79221>>>>>>>        
79221>>>>>>>        Move SuggestionData.aValues[0] to sValue
79222>>>>>>>        If (not(bFullText)) Begin
79224>>>>>>>            Set pbBold of ghoSuggestionList to True
79225>>>>>>>            Send AppendText of ghoSuggestionList (Left(sValue,Length(sSearch))) 
79226>>>>>>>            Set pbBold of ghoSuggestionList to False
79227>>>>>>>            Send AppendText of ghoSuggestionList (Mid(sValue,255,Length(sSearch)+1)) 
79228>>>>>>>        End
79228>>>>>>>>
79228>>>>>>>        Else Begin
79229>>>>>>>            Set pbBold of ghoSuggestionList to False
79230>>>>>>>            Move (Pos(Uppercase(sSearch),Uppercase(sValue))) to iPos
79231>>>>>>>            If (iPos) Begin
79233>>>>>>>                Send AppendText of ghoSuggestionList (Left(sValue,iPos-1)) 
79234>>>>>>>                Set pbBold of ghoSuggestionList to True
79235>>>>>>>                Send AppendText of ghoSuggestionList (Mid(sValue,Length(sSearch),iPos)) 
79236>>>>>>>                Set pbBold of ghoSuggestionList to False
79237>>>>>>>            End
79237>>>>>>>>
79237>>>>>>>            Send AppendText of ghoSuggestionList (Mid(sValue,255,iPos+Length(sSearch))) 
79238>>>>>>>        End
79238>>>>>>>>
79238>>>>>>>        
79238>>>>>>>        // if addiitonal columns (usually validation) we assume the first value is the one that is
79238>>>>>>>        // matched and we display all other values (usually just one) to the
79238>>>>>>>        // right of it. 
79238>>>>>>>        Move (SizeOfArray(SuggestionData.aValues)) to iCols
79239>>>>>>>        If (iCols>1) Begin
79241>>>>>>>            Move "" to sValue
79242>>>>>>>            For i from 1 to (iCols-1)
79248>>>>>>>>
79248>>>>>>>                Move (sValue + If(i=1," - ","  ") + SuggestionData.aValues[i]) to sValue
79249>>>>>>>            Loop
79250>>>>>>>>
79250>>>>>>>            Send AppendText of ghoSuggestionList sValue
79251>>>>>>>        End
79251>>>>>>>>
79251>>>>>>>    End_Procedure
79252>>>>>>>    
79252>>>>>>>    // used to catch a set_field_value_Error
79252>>>>>>>    Procedure Error_Report Integer iError Integer iLine String sErr
79254>>>>>>>    End_Procedure
79255>>>>>>>    
79255>>>>>>>    // does a Set_Field_Value with error testing around it.
79255>>>>>>>    Function SafeSetFieldValue Integer iFile Integer iField String sValue Returns Boolean
79257>>>>>>>        Handle hoOldError
79257>>>>>>>        Boolean bErr
79257>>>>>>>        Move Error_Object_Id to hoOldError
79258>>>>>>>        Move Self to Error_Object_Id
79259>>>>>>>        Move False to Err 
79260>>>>>>>        Set_Field_Value iFile iField to sValue
79263>>>>>>>        Move Err to bErr
79264>>>>>>>        Move hoOldError to Error_Object_Id
79265>>>>>>>        Function_Return bErr        
79266>>>>>>>    End_Function
79267>>>>>>>
79267>>>>>>>
79267>>>>>>>    Procedure SuggestionsFindIncremental String sSearch tSuggestion[] ByRef aSuggestions
79269>>>>>>>        Integer iFile iField iIndex iLen iRow iMax eType iLength iDec
79269>>>>>>>        Handle hoServer
79269>>>>>>>        Boolean bContinue bCase bOldRelate bNeedsRelate bInvalid
79269>>>>>>>        String sVal sLowSearch
79269>>>>>>>        RowID riTest
79269>>>>>>>        
79269>>>>>>>        Get Server to hoServer
79270>>>>>>>        Get Data_File  to iFile
79271>>>>>>>        Get Data_Field to iField       
79272>>>>>>>        
79272>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
79274>>>>>>>            Get piFindIndex to iIndex
79275>>>>>>>            Get piMaxResults to iMax
79276>>>>>>>            Get pbCaseSensitive to bCase
79277>>>>>>>            
79277>>>>>>>            Get_Attribute DF_FIELD_TYPE of iFile iField to eType
79280>>>>>>>            Get_Attribute DF_FIELD_LENGTH of iFile iField to iLength
79283>>>>>>>            Get_Attribute DF_FIELD_PRECISION of iFile iField to iDec
79286>>>>>>>            
79286>>>>>>>            Move (iLength - iDec) to iLength
79287>>>>>>>            
79287>>>>>>>            If (iIndex <= 0) Begin
79289>>>>>>>                Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
79292>>>>>>>            End
79292>>>>>>>>
79292>>>>>>>            
79292>>>>>>>            
79292>>>>>>>            
79292>>>>>>>            If (iIndex > 0) Begin
79294>>>>>>>                Get No_Relate_State of hoServer to bOldRelate
79295>>>>>>>                Get DDOConstraintNeedsRelate of hoServer iIndex to bNeedsRelate
79296>>>>>>>                Set No_Relate_State of hoServer to (not(bNeedsRelate))
79297>>>>>>>                                
79297>>>>>>>                Move True to bContinue
79298>>>>>>>                Move (Length(sSearch)) to iLen
79299>>>>>>>                Move (Lowercase(sSearch)) to sLowSearch
79300>>>>>>>                Move 0 to iRow
79301>>>>>>>                
79301>>>>>>>                //  Find first record
79301>>>>>>>                Send Request_Read of hoServer FIRST_RECORD iFile iIndex
79302>>>>>>>                Get SafeSetFieldValue iFile iField sSearch to bInvalid
79303>>>>>>>                If bInvalid Begin
79305>>>>>>>                    Move False to bContinue
79306>>>>>>>                End
79306>>>>>>>>
79306>>>>>>>                
79306>>>>>>>                If (bContinue) Begin
79308>>>>>>>                    Send Request_Read of hoServer GE iFile iIndex
79309>>>>>>>                End
79309>>>>>>>>
79309>>>>>>>                
79309>>>>>>>                While (Found and bContinue)
79313>>>>>>>                    Get_Field_Value iFile iField to sVal
79316>>>>>>>                    
79316>>>>>>>                    If ((not(bCase) and Lowercase(Left(sVal, iLen)) = sLowSearch) or (bCase and Left(sVal, iLen) = sSearch)) Begin
79318>>>>>>>
79318>>>>>>>                        Move (SerializeRowID(GetRowID(iFile)))  to aSuggestions[iRow].sRowId
79319>>>>>>>                        Move (Trim(sVal))                       to aSuggestions[iRow].aValues[0]
79320>>>>>>>                        Increment iRow
79321>>>>>>>                        
79321>>>>>>>                        Move (iRow < iMax) to bContinue
79322>>>>>>>                       
79322>>>>>>>                        Send Request_Read of hoServer GT iFile iIndex  
79323>>>>>>>                    End
79323>>>>>>>>
79323>>>>>>>                    Else Begin
79324>>>>>>>                        If (eType = DF_BCD and Length(sSearch) < iLength) Begin
79326>>>>>>>                            //  For numeric fields we'll jump in the index to the next possible value (for example from 40 to 400)
79326>>>>>>>                            
79326>>>>>>>                            Move (GetRowID(iFile)) to riTest
79327>>>>>>>                            
79327>>>>>>>                            Move (sSearch * 10) to sSearch
79328>>>>>>>                            
79328>>>>>>>                            Get SafeSetFieldValue iFile iField sSearch to bInvalid
79329>>>>>>>                            If bInvalid Begin
79331>>>>>>>                                Move False to bContinue
79332>>>>>>>                            End
79332>>>>>>>>
79332>>>>>>>                            Else Begin
79333>>>>>>>                                Send Request_Read of hoServer GE iFile iIndex
79334>>>>>>>                                Move (not(IsSameRowID(riTest, GetRowID(iFile)))) to bContinue
79335>>>>>>>                            End 
79335>>>>>>>>
79335>>>>>>>                        End
79335>>>>>>>>
79335>>>>>>>                        Else Begin
79336>>>>>>>                            Move False to bContinue
79337>>>>>>>                        End
79337>>>>>>>>
79337>>>>>>>                    End
79337>>>>>>>>
79337>>>>>>>                    
79337>>>>>>>                Loop
79338>>>>>>>>
79338>>>>>>>                Set No_Relate_State of hoServer to bOldRelate
79339>>>>>>>            End
79339>>>>>>>>
79339>>>>>>>        End
79339>>>>>>>>
79339>>>>>>>    End_Procedure
79340>>>>>>>    
79340>>>>>>>    Procedure SuggestionsFindFullText String sSearch tSuggestion[] ByRef aSuggestions
79342>>>>>>>        Integer iFile iField iIndex iRow iMax
79342>>>>>>>        Handle hoServer
79342>>>>>>>        Boolean bContinue bCase  bOldRelate bNeedsRelate
79342>>>>>>>        String sVal sLowSearch
79342>>>>>>>        
79342>>>>>>>        Get Server to hoServer
79343>>>>>>>        Get Data_File  to iFile
79344>>>>>>>        Get Data_Field to iField       
79345>>>>>>>        
79345>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
79347>>>>>>>            Get piMaxResults to iMax
79348>>>>>>>            Get pbCaseSensitive to bCase
79349>>>>>>>            
79349>>>>>>>            Get piFindIndex to iIndex
79350>>>>>>>            If (iIndex <= 0) Begin
79352>>>>>>>                Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
79355>>>>>>>            End
79355>>>>>>>>
79355>>>>>>>            
79355>>>>>>>            Get No_Relate_State of hoServer to bOldRelate
79356>>>>>>>            Get DDOConstraintNeedsRelate of hoServer iIndex to bNeedsRelate
79357>>>>>>>            Set No_Relate_State of hoServer to (not(bNeedsRelate))
79358>>>>>>>            
79358>>>>>>>            
79358>>>>>>>            Move (Lowercase(sSearch)) to sLowSearch
79359>>>>>>>            Move True to bContinue
79360>>>>>>>            Move 0 to iRow
79361>>>>>>>                
79361>>>>>>>            //  Find first record
79361>>>>>>>            Send Request_Read of hoServer FIRST_RECORD iFile iIndex
79362>>>>>>>            
79362>>>>>>>            While (Found and (iRow < iMax))
79366>>>>>>>                Get_Field_Value iFile iField to sVal
79369>>>>>>>                
79369>>>>>>>                If ((bCase and sVal contains sSearch) or (not(bCase) and Lowercase(sVal) contains sLowSearch)) Begin
79371>>>>>>>                    Move (SerializeRowID(GetRowID(iFile)))  to aSuggestions[iRow].sRowId
79372>>>>>>>                    Move (Trim(sVal))                       to aSuggestions[iRow].aValues[0]
79373>>>>>>>                    Increment iRow
79374>>>>>>>                End
79374>>>>>>>>
79374>>>>>>>                
79374>>>>>>>                Send Request_Read of hoServer GT iFile iIndex 
79375>>>>>>>            Loop
79376>>>>>>>>
79376>>>>>>>            Set No_Relate_State of hoServer to bOldRelate
79377>>>>>>>        End
79377>>>>>>>>
79377>>>>>>>    End_Procedure
79378>>>>>>>    
79378>>>>>>>    Procedure SuggestionsSQLFullText String sSearch tSuggestion[] ByRef aSuggestions
79380>>>>>>>        Integer iFile iField iIndex iRow iMax
79380>>>>>>>        Handle hoServer
79380>>>>>>>        Boolean bContinue bOrigActive  bOldRelate bNeedsRelate
79380>>>>>>>        String sVal sOrigFilter sFilter sFile sField
79380>>>>>>>        
79380>>>>>>>        Get Server to hoServer
79381>>>>>>>        Get Data_File  to iFile
79382>>>>>>>        Get Data_Field to iField       
79383>>>>>>>        
79383>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
79385>>>>>>>            
79385>>>>>>>            // make sure we send DD messages to owner DDO
79385>>>>>>>            Get Which_Data_Set of hoServer iFile to hoServer
79386>>>>>>>            If (hoServer=0) Begin
79388>>>>>>>                Procedure_Return
79389>>>>>>>            End
79389>>>>>>>>
79389>>>>>>>            
79389>>>>>>>            Get piMaxResults to iMax
79390>>>>>>>            Get piFindIndex to iIndex
79391>>>>>>>            If (iIndex <= 0) Begin
79393>>>>>>>                Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
79396>>>>>>>            End
79396>>>>>>>>
79396>>>>>>>            
79396>>>>>>>            //  Determine current filter settings
79396>>>>>>>            Get psSQLFilter of hoServer to sOrigFilter
79397>>>>>>>            Get pbUseDDSqlFilters of hoServer to bOrigActive
79398>>>>>>>            
79398>>>>>>>            // generate the Like filter string
79398>>>>>>>            Get SQLStrLike of hoServer iField sSearch to sFilter
79399>>>>>>>            // If filtering was active append this to what's there
79399>>>>>>>            If (bOrigActive) Begin
79401>>>>>>>                Get SQLStrAppend of hoServer sOrigFilter sFilter to sFilter
79402>>>>>>>            End
79402>>>>>>>>
79402>>>>>>>            
79402>>>>>>>            //  Set filter
79402>>>>>>>            Set psSQLFilter of hoServer to sFilter
79403>>>>>>>            Set pbUseDDSqlFilters of hoServer to True
79404>>>>>>>            
79404>>>>>>>            
79404>>>>>>>            // this will optimize No_relate. If your DF constraint does not
79404>>>>>>>            // need a post-relate test, we will disabled relates for this
79404>>>>>>>            Get No_Relate_State of hoServer to bOldRelate
79405>>>>>>>            Get DDOConstraintNeedsRelate of hoServer iIndex to bNeedsRelate
79406>>>>>>>            Set No_Relate_State of hoServer to (not(bNeedsRelate))
79407>>>>>>>
79407>>>>>>>            //  Find records
79407>>>>>>>            Move True to bContinue
79408>>>>>>>            Move 0 to iRow
79409>>>>>>>            
79409>>>>>>>            Send Request_Read of hoServer FIRST_RECORD iFile iIndex
79410>>>>>>>            
79410>>>>>>>            While (bContinue)
79414>>>>>>>                Get_Field_Value iFile iField to sVal
79417>>>>>>>                
79417>>>>>>>                If (Found) Begin // and ((bCase and sVal contains sSearch) or (not(bCase) and Lowercase(sVal) contains sLowSearch))) Begin
79419>>>>>>>                    Move (SerializeRowID(GetRowID(iFile)))  to aSuggestions[iRow].sRowId
79420>>>>>>>                    Move (Trim(sVal))                       to aSuggestions[iRow].aValues[0]
79421>>>>>>>                    Increment iRow
79422>>>>>>>                    
79422>>>>>>>                    Move (iRow < iMax) to bContinue
79423>>>>>>>                   
79423>>>>>>>                    Send Request_Read of hoServer GT iFile iIndex 
79424>>>>>>>                End
79424>>>>>>>>
79424>>>>>>>                Else Begin
79425>>>>>>>                    Move False to bContinue
79426>>>>>>>                End
79426>>>>>>>>
79426>>>>>>>                
79426>>>>>>>            Loop
79427>>>>>>>>
79427>>>>>>>            
79427>>>>>>>            //  Restore filters
79427>>>>>>>            Set psSQLFilter of hoServer to sOrigFilter
79428>>>>>>>            Set pbUseDDSqlFilters of hoServer to bOrigActive
79429>>>>>>>            Set No_Relate_State of hoServer to bOldRelate
79430>>>>>>>        End
79430>>>>>>>>
79430>>>>>>>    End_Procedure
79431>>>>>>>    
79431>>>>>>>    Procedure SuggestionsValidation String sSearch tSuggestion[] ByRef aSuggestions Boolean bFullText
79433>>>>>>>        Handle hoServer hoTable
79433>>>>>>>        Integer iFile iField iRow iCount iFound iMax iLen
79433>>>>>>>        Variant[][] aData
79434>>>>>>>        Boolean bCaseSensitive bContinue
79434>>>>>>>        String sDescr sVal
79434>>>>>>>        
79434>>>>>>>        Get Server to hoServer
79435>>>>>>>        Get Data_File  to iFile
79436>>>>>>>        Get Data_Field to iField       
79437>>>>>>>        
79437>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
79439>>>>>>>            Get File_Field_Table_Object of hoServer iFile iField to hoTable
79440>>>>>>>            If (hoTable <> 0) Begin
79442>>>>>>>                Get tabledata of hoTable to aData
79443>>>>>>>        
79443>>>>>>>                Get piMaxResults to iMax
79444>>>>>>>                Get pbCaseSensitive to bCaseSensitive  
79445>>>>>>>            
79445>>>>>>>                If (not(bCaseSensitive)) Begin
79447>>>>>>>                    Move (Lowercase(sSearch)) to sSearch
79448>>>>>>>                End
79448>>>>>>>>
79448>>>>>>>                
79448>>>>>>>                
79448>>>>>>>                Move (SizeOfArray(aData)) to iCount
79449>>>>>>>                Move 0 to iRow
79450>>>>>>>                Move (Length(sSearch)) to iLen
79451>>>>>>>                Move True to bContinue
79452>>>>>>>                
79452>>>>>>>            
79452>>>>>>>                While (iFound < iMax and iRow < iCount and bContinue)
79456>>>>>>>                    If (not(bCaseSensitive)) Begin
79458>>>>>>>                        Move (Lowercase(aData[iRow][0])) to sVal
79459>>>>>>>                        Move (Lowercase(aData[iRow][1])) to sDescr
79460>>>>>>>                    End
79460>>>>>>>>
79460>>>>>>>                    Else Begin
79461>>>>>>>                        Move aData[iRow][0] to sVal
79462>>>>>>>                        Move aData[iRow][1] to sDescr
79463>>>>>>>                    End
79463>>>>>>>>
79463>>>>>>>                    
79463>>>>>>>                    If ((bFullText and (sVal contains sSearch)) or (not(bFullText) and (Left(sVal, iLen) = sSearch))) Begin
79465>>>>>>>                        Move aData[iRow][0] to aSuggestions[iFound].sRowId
79466>>>>>>>                        Move aData[iRow][0] to aSuggestions[iFound].aValues[0]
79467>>>>>>>                        Move aData[iRow][1] to aSuggestions[iFound].aValues[1]
79468>>>>>>>                        Increment iFound
79469>>>>>>>                    End
79469>>>>>>>>
79469>>>>>>>                    Else Begin
79470>>>>>>>                        Move (bFullText or iFound = 0) to bContinue
79471>>>>>>>                    End
79471>>>>>>>>
79471>>>>>>>                    
79471>>>>>>>                    Increment iRow
79472>>>>>>>                Loop
79473>>>>>>>>
79473>>>>>>>            End
79473>>>>>>>>
79473>>>>>>>        End
79473>>>>>>>>
79473>>>>>>>         
79473>>>>>>>    End_Procedure
79474>>>>>>>    
79474>>>>>>>    
79474>>>>>>>    Procedure OnFindSuggestions String sSearch tSuggestion[] ByRef aSuggestions
79476>>>>>>>        Integer iMode iFile
79476>>>>>>>        Boolean bFullText bResult bSupportsSQL
79476>>>>>>>        Handle hoServer
79476>>>>>>>        
79476>>>>>>>        Get Server to hoServer
79477>>>>>>>        Get Data_File  to iFile
79478>>>>>>>        
79478>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
79480>>>>>>>            
79480>>>>>>>            Get peSuggestionMode to iMode
79481>>>>>>>            Get pbFullText to bFullText
79482>>>>>>>            
79482>>>>>>>            If (iMode = smFind) Begin
79484>>>>>>>                If (not(bFullText)) Begin
79486>>>>>>>                    Send SuggestionsFindIncremental sSearch (&aSuggestions)
79487>>>>>>>                End
79487>>>>>>>>
79487>>>>>>>                Else Begin
79488>>>>>>>                    Get SupportsSQLFilters of hoServer to bSupportsSQL
79489>>>>>>>                    If (bSupportsSQL) Begin
79491>>>>>>>                        Send SuggestionsSQLFullText sSearch (&aSuggestions)
79492>>>>>>>                    End
79492>>>>>>>>
79492>>>>>>>                    Else Begin
79493>>>>>>>                        Send SuggestionsFindFullText sSearch (&aSuggestions)
79494>>>>>>>                    End
79494>>>>>>>>
79494>>>>>>>                End
79494>>>>>>>>
79494>>>>>>>            End
79494>>>>>>>>
79494>>>>>>>            Else If (iMode = smValidationTable) Begin
79497>>>>>>>                Send SuggestionsValidation sSearch (&aSuggestions) bFullText
79498>>>>>>>            End
79498>>>>>>>>
79498>>>>>>>        End
79498>>>>>>>>
79498>>>>>>>    End_Procedure
79499>>>>>>>    
79499>>>>>>>    Procedure OnSelectSuggestion String sSearch tSuggestion Suggestion
79501>>>>>>>        Handle hoServer
79501>>>>>>>        Integer iFile iField iMode
79501>>>>>>>        Boolean bFind
79501>>>>>>>        RowID rRowId
79501>>>>>>>        
79501>>>>>>>        Get Server to hoServer
79502>>>>>>>        Get Data_File  to iFile
79503>>>>>>>        Get Data_Field to iField       
79504>>>>>>>        
79504>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
79506>>>>>>>            Get peSuggestionMode to iMode
79507>>>>>>>            
79507>>>>>>>            If (iMode = smFind) Begin
79509>>>>>>>                Get pbFindOnSelect to bFind
79510>>>>>>>                If (bFind) Begin
79512>>>>>>>                    Move (DeserializeRowID(Suggestion.sRowId)) to rRowId    
79513>>>>>>>                    
79513>>>>>>>                    If (not(IsNullRowID(rRowId))) Begin
79515>>>>>>>                        Send FindByRowId of hoServer iFile rRowId
79516>>>>>>>                    End
79516>>>>>>>>
79516>>>>>>>                End
79516>>>>>>>>
79516>>>>>>>                Else Begin
79517>>>>>>>                    Set Value to Suggestion.aValues[0]
79518>>>>>>>                    Set Item_Changed_State to True
79519>>>>>>>                End
79519>>>>>>>>
79519>>>>>>>            End
79519>>>>>>>>
79519>>>>>>>            Else If (imode = smValidationTable) Begin
79522>>>>>>>                Set Value to Suggestion.sRowId
79523>>>>>>>                Set Item_Changed_State to True
79524>>>>>>>            End
79524>>>>>>>>
79524>>>>>>>            
79524>>>>>>>        End
79524>>>>>>>>
79524>>>>>>>    End_Procedure
79525>>>>>>>    
79525>>>>>>>    // Return true if Suggestion should be invoked. Can be augmented
79525>>>>>>>    Function ShouldSuggestion String sValue Boolean bChanged Returns Boolean
79527>>>>>>>        Integer iStartAtChar
79527>>>>>>>        Get piStartAtChar to iStartAtChar
79528>>>>>>>        Function_Return (bChanged and Length(sValue)>=iStartAtChar)
79529>>>>>>>    End_Function
79530>>>>>>>    
79530>>>>>>>    
79530>>>>>>>End_Class
79531>>>>>>>
79531>>>>>>>
79531>>>>>>>// This contains logic that deals with the Windows object. It relies on the interface in 
79531>>>>>>>// sSuggestion_mixin, which means it must be mixed in as a sibling of this object (as is done
79531>>>>>>>// in dbSuggestionForm or as a child of this object (as is done in cDbCJGridColumnSuggestion), which
79531>>>>>>>// means messages are resolved via delegation. sSuggestion_mixin does not send messages to this class.
79531>>>>>>>// Note that cSuggestion_mixin and cSuggestionControl_mixin are designed so they can be mixed in at
79531>>>>>>>// the same level or mixed in such that cSuggestionControl_mixin is in the child object and cSuggestion_mixin
79531>>>>>>>// is in the parent
79531>>>>>>> 
79531>>>>>>>Class cSuggestionControl_mixin is a Mixin
79532>>>>>>>    
79532>>>>>>>    Procedure Define_cSuggestionControl_mixin
79534>>>>>>>        
79534>>>>>>>        Property Integer piTimeOutTicks 0
79535>>>>>>>        
79535>>>>>>>        On_Key kEnter Send SelectSuggestion
79536>>>>>>>        On_Key Key_Escape Send DeActivateSuggestionList
79537>>>>>>>        On_Key Key_Up_Arrow Send Up
79538>>>>>>>        On_Key Key_Down_Arrow Send Down
79539>>>>>>>
79539>>>>>>>    End_Procedure
79540>>>>>>>
79540>>>>>>>    Procedure AdjustSuggestionListSize Integer iLines
79542>>>>>>>        Integer i  iX iMax iY
79542>>>>>>>        String sTxt
79542>>>>>>>        Boolean bFullWidth
79542>>>>>>>        For i from 0 to (iLines-1)
79548>>>>>>>>
79548>>>>>>>            Get Line of ghoSuggestionList i to sTxt
79549>>>>>>>            Get Text_Extent of ghoSuggestionList sTxt to iX
79550>>>>>>>            Move (Low(iX) max iMax) to iMax
79551>>>>>>>            Move (Hi(iX)) to iY
79552>>>>>>>        Loop
79553>>>>>>>>
79553>>>>>>>        Move (iMax + 20) to imax
79554>>>>>>>        Get pbFullWidth to bFullWidth
79555>>>>>>>        If bFullWidth Begin
79557>>>>>>>            Move (iMax max (Low(GuiSize(Self)))) to iMax
79558>>>>>>>        End
79558>>>>>>>>
79558>>>>>>>        If (iLines) Begin
79560>>>>>>>            Set GuiSize of ghoSuggestionList to (iY*(iLines)+8) iMax
79561>>>>>>>            Send SelectRow of ghoSuggestionList 0 // go to first line
79562>>>>>>>        End
79562>>>>>>>>
79562>>>>>>>        Else Begin
79563>>>>>>>            Set GuiSize of ghoSuggestionList to (Hi(GuiSize(Self))) (low(GuiSize(Self)))
79564>>>>>>>        End
79564>>>>>>>>
79564>>>>>>>    End_Procedure
79565>>>>>>>    
79565>>>>>>>    // show all suggestions
79565>>>>>>>    Procedure ShowSuggestions
79567>>>>>>>        tSuggestion[] aResults
79567>>>>>>>        tSuggestion[] aResults
79568>>>>>>>        Integer i iLines
79568>>>>>>>        String sSearch 
79568>>>>>>>        Get pSearchResults to aResults
79569>>>>>>>        Get Value to sSearch
79570>>>>>>>        Send Delete_Data of ghoSuggestionList
79571>>>>>>>        Move (SizeOfArray(aResults)) to iLines
79572>>>>>>>        For i from 0 to (iLines-1)
79578>>>>>>>>
79578>>>>>>>            Send ShowSuggestion aResults[i] sSearch
79579>>>>>>>            If ((iLines-1)<>i) Begin
79581>>>>>>>                Send AppendTextLn of ghoSuggestionList ""
79582>>>>>>>            End
79582>>>>>>>>
79582>>>>>>>        Loop
79583>>>>>>>>
79583>>>>>>>        Send AdjustSuggestionListSize iLines
79584>>>>>>>    End_Procedure
79585>>>>>>>
79585>>>>>>>    Procedure FindSuggestions 
79587>>>>>>>        String sSearch
79587>>>>>>>        tSuggestion[] aResults
79587>>>>>>>        tSuggestion[] aResults
79588>>>>>>>        String[] aParams
79589>>>>>>>        Get Value to sSearch
79590>>>>>>>        Send OnFindSuggestions sSearch (&aResults)
79591>>>>>>>        Set pSearchResults to aResults
79592>>>>>>>        // if an error was raised, the suggestion list will be gone
79592>>>>>>>        If (ghoSuggestionList) Begin
79594>>>>>>>            Send ShowSuggestions
79595>>>>>>>        End
79595>>>>>>>>
79595>>>>>>>    End_Procedure
79596>>>>>>>
79596>>>>>>>    Procedure SelectSuggestion 
79598>>>>>>>        String sSearch
79598>>>>>>>        tSuggestion[] aData
79598>>>>>>>        tSuggestion[] aData
79599>>>>>>>        Integer iSelRow
79599>>>>>>>        If ghoSuggestionList Begin
79601>>>>>>>            Get SelectedRow of ghoSuggestionList to iSelRow
79602>>>>>>>            Get Value to sSearch
79603>>>>>>>            Get pSearchResults to aData        
79604>>>>>>>            Send DeActivateSuggestionList
79605>>>>>>>            Send CancelEditIfGrid
79606>>>>>>>            If (iSelRow>=0 and SizeOfArray(aData)>iSelRow) Begin
79608>>>>>>>                Send OnSelectSuggestion sSearch aData[iSelRow] 
79609>>>>>>>            End
79609>>>>>>>>
79609>>>>>>>        End
79609>>>>>>>>
79609>>>>>>>        Else Begin
79610>>>>>>>            Send Default_Action
79611>>>>>>>        End
79611>>>>>>>>
79611>>>>>>>    End_Procedure
79612>>>>>>>    
79612>>>>>>>    Procedure CancelEditIfGrid
79614>>>>>>>        // do nothing with forms, remember
79614>>>>>>>        // to replace or augment with grid to
79614>>>>>>>        // cancel the edit control
79614>>>>>>>    End_Procedure
79615>>>>>>>
79615>>>>>>>    
79615>>>>>>>    Function ParentForSuggestion Returns Handle
79617>>>>>>>        Handle hoMain hoMainPanel
79617>>>>>>>
79617>>>>>>>        // we must have an application object and a main panel object
79617>>>>>>>        If ghoApplication Begin
79619>>>>>>>            Get phoMainPanel of ghoApplication to hoMainPanel
79620>>>>>>>        End
79620>>>>>>>>
79620>>>>>>>        If (hoMainPanel=0 or Self<=Desktop) Begin
79622>>>>>>>            Function_Return 0
79623>>>>>>>        End
79623>>>>>>>>
79623>>>>>>>
79623>>>>>>>        Move Self to hoMain
79624>>>>>>>        Repeat
79624>>>>>>>>
79624>>>>>>>            Get Parent of hoMain to hoMain
79625>>>>>>>        Until (hoMain=Desktop or Block_Mouse_State(hoMain) or hoMainPanel=hoMain)
79627>>>>>>>
79627>>>>>>>        Function_Return (If(hoMain>Desktop,hoMain,0))
79628>>>>>>>        
79628>>>>>>>    End_Function
79629>>>>>>>    
79629>>>>>>>    Procedure ActivateSuggestionList
79631>>>>>>>        Handle hoView hcSuggest
79631>>>>>>>        Get ParentForSuggestion to hoView
79632>>>>>>>        If hoView Begin
79634>>>>>>>            Get phcSuggestionListClass to hcSuggest
79635>>>>>>>            Get CreateNamed of hoView hcSuggest "oSuggestList" to ghoSuggestionList
79636>>>>>>>            Send InitList of ghoSuggestionList Self
79637>>>>>>>            Set Focus_Mode of ghoSuggestionList to Focusable
79638>>>>>>>            Set phoOwner of ghoSuggestionList to Self
79639>>>>>>>            Send Add_Focus of ghoSuggestionList hoView
79640>>>>>>>        End
79640>>>>>>>>
79640>>>>>>>    End_Procedure
79641>>>>>>>    
79641>>>>>>>    Procedure DeActivateSuggestionList
79643>>>>>>>        If ghoSuggestionList Begin
79645>>>>>>>            Send DeactivateList of ghoSuggestionList
79646>>>>>>>        End
79646>>>>>>>>
79646>>>>>>>    End_Procedure
79647>>>>>>>    
79647>>>>>>>    // augment to kill suggest list if focus is not moving to it  
79647>>>>>>>    // customized for grid
79647>>>>>>>    Procedure OnKillFocus
79649>>>>>>>        // note focus has already changed here
79649>>>>>>>        If (ghoSuggestionList) Begin
79651>>>>>>>            If (Focus(Self)<>ghoSuggestionList) Begin
79653>>>>>>>                Send DeActivateSuggestionList
79654>>>>>>>                Forward Send OnKillFocus
79656>>>>>>>            End
79656>>>>>>>>
79656>>>>>>>            Else Begin
79657>>>>>>>                // giving focus to the suggestion list here
79657>>>>>>>            End
79657>>>>>>>>
79657>>>>>>>        End
79657>>>>>>>>
79657>>>>>>>        Else Begin
79658>>>>>>>            Forward Send OnKillFocus
79660>>>>>>>        End
79660>>>>>>>>
79660>>>>>>>    End_Procedure
79661>>>>>>>    
79661>>>>>>>    Procedure Up
79663>>>>>>>        If (Focus(Desktop) = Self and ghoSuggestionList) Begin
79665>>>>>>>           Send ScrollUp of ghoSuggestionList
79666>>>>>>>        End
79666>>>>>>>>
79666>>>>>>>    End_Procedure
79667>>>>>>>
79667>>>>>>>    Procedure Down
79669>>>>>>>        If (Focus(Desktop) = Self and ghoSuggestionList) Begin
79671>>>>>>>           Send ScrollDown of ghoSuggestionList
79672>>>>>>>        End
79672>>>>>>>>
79672>>>>>>>    End_Procedure
79673>>>>>>>    
79673>>>>>>>
79673>>>>>>>    Procedure Key Integer iKey
79675>>>>>>>        Integer iEndTicks
79675>>>>>>>        
79675>>>>>>>        If (Focus(Desktop) <> Self) Begin
79677>>>>>>>          Forward Send Key iKey
79679>>>>>>>          Procedure_Return
79680>>>>>>>        End
79680>>>>>>>>
79680>>>>>>>        
79680>>>>>>>        Send DeActivateSuggestionList
79681>>>>>>>        Move (GetTickCount()) to iEndTicks
79682>>>>>>>        // record the time of key press
79682>>>>>>>        If (piTimeOutTicks(Self) = 0) Begin
79684>>>>>>>         
79684>>>>>>>            If (ghoSuggestionTimer=0) Begin
79686>>>>>>>               Send CreateSuggestionTimer
79687>>>>>>>            End
79687>>>>>>>>
79687>>>>>>>         
79687>>>>>>>            Set pbEnabled of ghoSuggestionTimer to True
79688>>>>>>>            Set phoTimerOwner of ghoSuggestionTimer to Self
79689>>>>>>>        End
79689>>>>>>>>
79689>>>>>>>        Set piTimeOutTicks to iEndTicks
79690>>>>>>>        
79690>>>>>>>        Forward Send Key iKey
79692>>>>>>>    End_Procedure
79693>>>>>>>    
79693>>>>>>>    Procedure CreateSuggestionTimer
79695>>>>>>>        Handle hoMainPanel
79695>>>>>>>        // we must have an application object and a main panel object
79695>>>>>>>        If ghoApplication Begin
79697>>>>>>>            Get phoMainPanel of ghoApplication to hoMainPanel
79698>>>>>>>        End
79698>>>>>>>>
79698>>>>>>>        If (hoMainPanel=0) Begin
79700>>>>>>>            Error DFERR_PROGRAM "Auto-suggest requires an application object and a main panel object"
79701>>>>>>>>
79701>>>>>>>            Procedure_Return
79702>>>>>>>        End
79702>>>>>>>>
79702>>>>>>>        Get CreateNamed of hoMainPanel (RefClass(cSuggestionTimer)) "oSuggestionTimer" to ghoSuggestionTimer
79703>>>>>>>    End_Procedure
79704>>>>>>>  
79704>>>>>>>    // sent by Auto Suggest Timer. Invoke suggestion list as needed
79704>>>>>>>    Procedure OnSuggestionTimer
79706>>>>>>>        Boolean bDoIt
79706>>>>>>>        Integer iEndTicks iStartTicks iTicks iTimeOut iChanged
79706>>>>>>>        String sValue
79706>>>>>>>        
79706>>>>>>>        If (Focus(Desktop) <> Self) Begin
79708>>>>>>>            // focus out of whack. Stop the timer
79708>>>>>>>            Set pbEnabled of ghoSuggestionTimer to False
79709>>>>>>>            Send DeActivateSuggestionList   
79710>>>>>>>            Procedure_Return
79711>>>>>>>        End                                
79711>>>>>>>>
79711>>>>>>>
79711>>>>>>>        Get piTimeOutTicks to iStartTicks
79712>>>>>>>        If (iStartTicks <> 0) Begin           
79714>>>>>>>            Move (GetTickCount()) to iEndTicks 
79715>>>>>>>            Move (iEndTicks - iStartTicks) to iTicks
79716>>>>>>>            // If tick count rolled over
79716>>>>>>>            If (iTicks < 0) Begin
79718>>>>>>>                Move (-iTicks) to iTicks 
79719>>>>>>>            End
79719>>>>>>>>
79719>>>>>>>        End
79719>>>>>>>>
79719>>>>>>>        Get piPopupTimeout to iTimeOut
79720>>>>>>>        If (iTicks >= iTimeOut) Begin
79722>>>>>>>            // If time delay has been met, launch autocomplete
79722>>>>>>>            Set pbEnabled  of ghoSuggestionTimer to False
79723>>>>>>>            Get Value to sValue
79724>>>>>>>            Get Item_Changed_State 0 to iChanged
79725>>>>>>>            Get ShouldSuggestion sValue iChanged to bDoIt
79726>>>>>>>            If bDoIt Begin
79728>>>>>>>                Send ActivateSuggestionList
79729>>>>>>>                Send FindSuggestions
79730>>>>>>>                Set Visible_State of ghoSuggestionList to True
79731>>>>>>>            End
79731>>>>>>>>
79731>>>>>>>            Set piTimeOutTicks to 0
79732>>>>>>>        End
79732>>>>>>>>
79732>>>>>>>    End_Procedure
79733>>>>>>>
79733>>>>>>>End_Class
79734>>>>>>>
79734>>>>>Use cDbCJGridColumn.pkg
79734>>>>>Use cDbCJGridColumnEdit.pkg
79734>>>>>
79734>>>>>// This is the edit control that gets embedded in cDbCJGridColumnSuggestion object.
79734>>>>>
79734>>>>>Class cDbCJGridColumnSuggestionEdit is a cDbCJGridColumnEdit
79735>>>>>
79735>>>>>    Import_Class_Protocol cSuggestionControl_mixin
79736>>>>>
79736>>>>>    Procedure Construct_Object
79738>>>>>        Forward Send Construct_Object
79740>>>>>        Send Define_cSuggestionControl_mixin
79741>>>>>    End_Procedure
79742>>>>>    
79742>>>>>    // Called when closing a suggestion form. With grids we must also make sure that the
79742>>>>>    // edit is canceled. 
79742>>>>>    Procedure CancelEditIfGrid
79744>>>>>        Send CancelEdit
79745>>>>>    End_Procedure
79746>>>>>    
79746>>>>>End_Class
79747>>>>>
79747>>>>>// A cDbCJGridColumnSuggestion would be dropped inside of cDbCJGrid.
79747>>>>>
79747>>>>>Class cDbCJGridColumnSuggestion is a cDbCJGridColumn
79748>>>>>    
79748>>>>>    Import_Class_Protocol cSuggestion_mixin            
79749>>>>>    
79749>>>>>    Procedure Construct_Object
79751>>>>>        Forward Send Construct_Object
79753>>>>>
79753>>>>>        Send Define_cSuggestion_mixin
79754>>>>>        Set phcEditClass to (RefClass(cDbCJGridColumnSuggestionEdit))
79755>>>>>    End_Procedure
79756>>>>>    
79756>>>>>End_Class
79757>>>Use dfSelLst.pkg
79757>>>
79757>>>Deferred_View Activate_RegistroEmpleado for ;Object RegistroEmpleado is a dbView
79782>>>    Object oNacionalidad_DD is a cNacionalidadDataDictionary
79784>>>    End_Object
79785>>>
79785>>>    Object oEmpleado_DD is a cEmpleadoDataDictionary
79787>>>        Set DDO_Server to oNacionalidad_DD
79788>>>    End_Object
79789>>>
79789>>>    Set Main_DD to oEmpleado_DD
79790>>>    Set Server to oEmpleado_DD
79791>>>
79791>>>    Set Border_Style to Border_Thick
79792>>>    Set Size to 164 422
79793>>>    Set Location to 2 2
79794>>>    Set Label to "Registro de Empleado"
79795>>>    Set piMaxSize to 164 450
79796>>>    Set piMinSize to 164 422
79797>>>
79797>>>    Object oDbGroup1 is a dbGroup
79799>>>        Set Size to 128 164
79800>>>        Set Location to 29 9
79801>>>        Set Label to "Datos Personales"
79802>>>        Set Color to clSilver
79803>>>
79803>>>        Object oEmpleado_Numero is a dbForm
79805>>>            Entry_Item Empleado.Numero
79806>>>            Set Location to 21 66
79807>>>            Set Size to 13 30
79808>>>            Set Label to "Numero:"
79809>>>            Set Prompt_Button_Mode to PB_PromptOn
79810>>>            Set Label_Color to clSilver
79811>>>        End_Object
79812>>>
79812>>>        Object oEmpleado_PrimerNombre is a dbForm
79814>>>            Entry_Item Empleado.PrimerNombre
79815>>>            Set Location to 36 66
79816>>>            Set Size to 13 87
79817>>>            Set Label to "PrimerNombre:"
79818>>>            Set Label_Color to clSilver
79819>>>        End_Object
79820>>>
79820>>>        Object oEmpleado_SegundoNombre is a dbForm
79822>>>            Entry_Item Empleado.SegundoNombre
79823>>>            Set Location to 51 66
79824>>>            Set Size to 13 87
79825>>>            Set Label to "SegundoNombre:"
79826>>>            Set Label_Color to clSilver
79827>>>        End_Object
79828>>>
79828>>>        Object oEmpleado_PrimerApellido is a dbForm
79830>>>            Entry_Item Empleado.PrimerApellido
79831>>>            Set Location to 66 66
79832>>>            Set Size to 13 87
79833>>>            Set Label to "PrimerApellido:"
79834>>>            Set Label_Color to clSilver
79835>>>        End_Object
79836>>>
79836>>>        Object oEmpleado_SegundoApellido is a dbForm
79838>>>            Entry_Item Empleado.SegundoApellido
79839>>>            Set Location to 82 66
79840>>>            Set Size to 13 87
79841>>>            Set Label to "SegundoApellido:"
79842>>>            Set Label_Color to clSilver
79843>>>        End_Object
79844>>>
79844>>>        Object oNacionalidad_Pais is a dbForm
79846>>>            Entry_Item Nacionalidad.Pais
79847>>>            Set Location to 98 92
79848>>>            Set Size to 13 61
79849>>>        End_Object
79850>>>
79850>>>        Object oEmpleado_Nacionalidad is a dbForm
79852>>>            Entry_Item Nacionalidad.Numero
79853>>>            Set Location to 98 66
79854>>>            Set Size to 13 22
79855>>>            Set Label to "Nacionalidad:"
79856>>>            Set Prompt_Button_Mode to PB_PromptOn
79857>>>            Set Prompt_Object to (ListaNacionalidad(Current_Object))
79858>>>          
79858>>>        End_Object
79859>>>    End_Object
79860>>>
79860>>>    Object oDbListEmpleado is a dbList
79862>>>        Set Size to 131 243
79863>>>        Set Location to 29 178
79864>>>        
79864>>>
79864>>>        Begin_Row
79867>>>            Entry_Item Empleado.Numero             
79868>>>            Entry_Item (Trim(Empleado.PrimerNombre) + ' ' + Trim( Empleado.SegundoNombre))
79869>>>            Entry_Item (Trim(Empleado.PrimerApellido) + ' ' + Trim( Empleado.SegundoApellido))
79870>>>            Entry_Item Nacionalidad.Pais
79871>>>        End_Row
79876>>>
79876>>>        Set Main_File to Empleado.File_Number
79877>>>
79877>>>        Set Form_Width 0 to 25
79878>>>        Set Header_Label 0 to "Num"
79879>>>        Set Form_Width 1 to 80
79880>>>        Set Header_Label 1 to "Nombres "
79881>>>        Set Form_Width 2 to 80
79882>>>        Set Header_Label 2 to "Apellidos"
79883>>>        Set Form_Width 3 to 50
79884>>>        Set Header_Label 3 to "Pais"
79885>>>    End_Object
79886>>>
79886>>>Cd_End_Object
79888>>>>
79888>        Use RegistroMarcajes.vw
Including file: RegistroMarcajes.vw    (C:\DataFlex Projects\Control Marcajes\AppSrc\RegistroMarcajes.vw)
79888>>>Use Windows.pkg
79888>>>Use DFClient.pkg
79888>>>Use cDbCJGrid.pkg
79888>>>Use cdbCJGridColumn.pkg
79888>>>Use cNacionalidadDataDictionary.dd
79888>>>Use cEmpleadoDataDictionary.dd
79888>>>Use cTipoMarcajeDataDictionary.dd
Including file: cTipoMarcajeDataDictionary.dd    (C:\DataFlex Projects\Control Marcajes\DDSrc\cTipoMarcajeDataDictionary.dd)
79888>>>>>Use DataDict.pkg
79888>>>>>
79888>>>>>Open TipoMarcaje
Including file: TipoMarcaje.fd    (C:\DataFlex Projects\Control Marcajes\DDSrc\TipoMarcaje.fd)
79890>>>>>Open Marcaje
79892>>>>>Open Autoincrementable
79894>>>>>
79894>>>>>Class cTipoMarcajeDataDictionary is a DataDictionary
79895>>>>>    
79895>>>>>    Procedure Construct_Object
79897>>>>>        Forward Send Construct_Object
79899>>>>>        Set Main_File to TipoMarcaje.File_Number
79900>>>>>
79900>>>>>        Set Add_System_File to Autoincrementable.File_Number DD_Lock_On_All
79901>>>>>
79901>>>>>        Set Add_Client_File to Marcaje.File_Number
79902>>>>>
79902>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_NOPUT to True
79903>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
79904>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
79905>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
79906>>>>>
79906>>>>>        Set Field_Option Field TipoMarcaje.Numero DD_AUTOFIND to True
79907>>>>>        Set Key_Field_State Field TipoMarcaje.Numero to True
79908>>>>>        Set Field_Auto_Increment Field TipoMarcaje.Numero to File_Field Autoincrementable.NumTipoMarcaje
79909>>>>>
79909>>>>>        Set Field_Option Field TipoMarcaje.TipoMarcaje DD_CAPSLOCK to True
79910>>>>>        Set Field_Option Field TipoMarcaje.TipoMarcaje DD_AUTOFIND to True
79911>>>>>        Set Field_Option Field TipoMarcaje.TipoMarcaje DD_REQUIRED to True
79912>>>>>
79912>>>>>    End_Procedure
79913>>>>>
79913>>>>>End_Class
79914>>>Use cMarcajeDataDictionary.dd
Including file: cMarcajeDataDictionary.dd    (C:\DataFlex Projects\Control Marcajes\DDSrc\cMarcajeDataDictionary.dd)
79914>>>>>Use DataDict.pkg
79914>>>>>
79914>>>>>Open Marcaje
79916>>>>>Open Empleado
79918>>>>>Open TipoMarcaje
79920>>>>>Open Autoincrementable
79922>>>>>
79922>>>>>Register_Object ListaTipoMarcaje
79922>>>>>Register_Object ListaEmpleado
79922>>>>>
79922>>>>>Class cMarcajeDataDictionary is a DataDictionary
79923>>>>>    
79923>>>>>    Procedure Construct_Object
79925>>>>>        Forward Send Construct_Object
79927>>>>>        Set Main_File to Marcaje.File_Number
79928>>>>>
79928>>>>>        Set Add_System_File to Autoincrementable.File_Number DD_Lock_On_All
79929>>>>>
79929>>>>>        Set Add_Server_File to Empleado.File_Number
79930>>>>>        Set Add_Server_File to TipoMarcaje.File_Number
79931>>>>>
79931>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_NOPUT to True
79932>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
79933>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
79934>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
79935>>>>>
79935>>>>>        Set Field_Option Field Marcaje.Numero DD_AUTOFIND to True
79936>>>>>        Set Field_Auto_Increment Field Marcaje.Numero to File_Field Autoincrementable.NumMarcaje
79937>>>>>        Set Key_Field_State Field Marcaje.Numero to True
79938>>>>>        Set Field_Option Field Marcaje.Numero DD_DISPLAYONLY to True
79939>>>>>
79939>>>>>        Set Field_Prompt_Object Field Marcaje.Empleado to ListaEmpleado
79940>>>>>        Set Field_Option Field Marcaje.Empleado DD_AUTOFIND to True
79941>>>>>        Set Field_Option Field Marcaje.Empleado DD_CAPSLOCK to True
79942>>>>>        Set Field_Option Field Marcaje.Empleado DD_REQUIRED to True
79943>>>>>
79943>>>>>        Set Field_Option Field Marcaje.FechaMarcaje DD_REQUIRED to True
79944>>>>>
79944>>>>>        Set Field_Option Field Marcaje.HoraMarcaje DD_REQUIRED to True
79945>>>>>
79945>>>>>        Set Field_Prompt_Object Field Marcaje.TipoMarcaje to ListaTipoMarcaje
79946>>>>>        Set Field_Option Field Marcaje.TipoMarcaje DD_AUTOFIND to True
79947>>>>>        Set Field_Option Field Marcaje.TipoMarcaje DD_REQUIRED to True
79948>>>>>
79948>>>>>    End_Procedure
79949>>>>>
79949>>>>>End_Class
79950>>>>>
79950>>>>>Use ListaEmpleado.sl
79950>>>>>Use ListaTipoMarcaje.sl
Including file: ListaTipoMarcaje.sl    (C:\DataFlex Projects\Control Marcajes\AppSrc\ListaTipoMarcaje.sl)
79950>>>>>>>//**************************************************************
79950>>>>>>>// TableLookup.tpl for Windows application for Spanish 
79950>>>>>>>// translated by Moose Software (www.moose-software.com) 
79950>>>>>>>// 13/07/2010 Revised for VDF 16.0 by Moose Software
79950>>>>>>>// 05/02/2012 Revised for VDF 17.0 by Moose Software
79950>>>>>>>// 13/06/2013 Revised for VDF 17.1 by Moose Software
79950>>>>>>>// 02/05/2014 Revised for VDF 18.0 by Moose Software
79950>>>>>>>//*************************************************************
79950>>>>>>>
79950>>>>>>>Use Windows.pkg
79950>>>>>>>Use DFClient.pkg
79950>>>>>>>use DFSellst.pkg
79950>>>>>>>Use cTipoMarcajeDataDictionary.dd
79950>>>>>>>
79950>>>>>>>Object ListaTipoMarcaje is a dbModalPanel
79952>>>>>>>    Object oTipoMarcaje_DD is a cTipoMarcajeDataDictionary
79954>>>>>>>    End_Object
79955>>>>>>>
79955>>>>>>>    Set Main_DD to oTipoMarcaje_DD
79956>>>>>>>    Set Server to oTipoMarcaje_DD
79957>>>>>>>
79957>>>>>>>    Set Size to 133 292
79958>>>>>>>    Set Location     to 4 5
79959>>>>>>>    Set Border_Style to Border_Thick
79960>>>>>>>    Set Label to "Tipo Marcaje"
79961>>>>>>>
79961>>>>>>>    Object oSelList is a dbList
79963>>>>>>>        Set peAnchors to anAll
79964>>>>>>>        Set Size      to 105 280
79965>>>>>>>        Set Location  to 6 6
79966>>>>>>>
79966>>>>>>>        Begin_Row
79969>>>>>>>            Entry_Item TipoMarcaje.Numero
79970>>>>>>>            Entry_Item TipoMarcaje.TipoMarcaje
79971>>>>>>>        End_Row
79976>>>>>>>
79976>>>>>>>        Set Main_File to TipoMarcaje.File_Number
79977>>>>>>>
79977>>>>>>>        Set Form_Width 0 to 48
79978>>>>>>>        Set Header_Label 0 to "Numero"
79979>>>>>>>        Set Form_Width 1 to 60
79980>>>>>>>        Set Header_Label 1 to "TipoMarcaje"
79981>>>>>>>    End_Object
79982>>>>>>>
79982>>>>>>>    Object oOK_bn is a Button
79984>>>>>>>        Set Label     to "&Aceptar"
79985>>>>>>>        Set Location  to 115 128
79986>>>>>>>        Set peAnchors to anBottomRight
79987>>>>>>>
79987>>>>>>>        Procedure OnClick
79990>>>>>>>            Send Ok of oSelList
79991>>>>>>>        End_Procedure
79992>>>>>>>
79992>>>>>>>    End_Object
79993>>>>>>>
79993>>>>>>>    Object oCancel_bn is a Button
79995>>>>>>>        Set Label     to "&Cancelar"
79996>>>>>>>        Set Location  to 115 182
79997>>>>>>>        Set peAnchors to anBottomRight
79998>>>>>>>
79998>>>>>>>        Procedure OnClick
80001>>>>>>>            Send Cancel of oSelList
80002>>>>>>>        End_Procedure
80003>>>>>>>
80003>>>>>>>    End_Object
80004>>>>>>>
80004>>>>>>>    Object oSearch_bn is a Button
80006>>>>>>>        Set Label     to "&Buscar..."
80007>>>>>>>        Set Location  to 115 236
80008>>>>>>>        Set peAnchors to anBottomRight
80009>>>>>>>
80009>>>>>>>        Procedure OnClick
80012>>>>>>>            Send Search of oSelList
80013>>>>>>>        End_Procedure
80014>>>>>>>
80014>>>>>>>    End_Object
80015>>>>>>>
80015>>>>>>>    On_Key Key_Alt+Key_A Send KeyAction of oOk_bn
80016>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_bn
80017>>>>>>>    On_Key Key_Alt+Key_B Send KeyAction of oSearch_bn
80018>>>>>>>
80018>>>>>>>End_Object
80019>>>>>>>
80019>>>>>>>//*********************************************** end of TableLookup.tpl for Spanish ****************
80019>>>>>>>
80019>>>Use cDbCJGridColumnSuggestion.pkg
80019>>>Use cCJGridColumn.pkg
80019>>>
80019>>>
80019>>>Activate_View Activate_RegistroMarcajes for RegistroMarcajes
80029>>>>
80029>>>Object RegistroMarcajes is a dbView
80031>>>    Object oTipoMarcaje_DD is a cTipoMarcajeDataDictionary
80033>>>    End_Object
80034>>>
80034>>>    Object oNacionalidad_DD is a cNacionalidadDataDictionary
80036>>>    End_Object
80037>>>
80037>>>    Object oEmpleado_DD is a cEmpleadoDataDictionary
80039>>>        Set DDO_Server to oNacionalidad_DD
80040>>>    End_Object
80041>>>
80041>>>    Object oMarcaje_DD is a cMarcajeDataDictionary
80043>>>        Set DDO_Server to oTipoMarcaje_DD
80044>>>        Set DDO_Server to oEmpleado_DD
80045>>>    End_Object
80046>>>
80046>>>    Set Main_DD to oMarcaje_DD
80047>>>    Set Server to oMarcaje_DD
80048>>>
80048>>>    Set Border_Style to Border_Thick
80049>>>    Set Size to 236 437
80050>>>    Set Location to 2 2
80051>>>    Set Label to "Registro de Marcajes"
80052>>>    Set Bitmap_Style to Bitmap_Center
80053>>>    Set Auto_Top_Panel_State to False
80054>>>    Set Auto_Top_Item_State to False
80055>>>    Set piMaxSize to 236 437
80056>>>    Set piMinSize to 236 437
80057>>>    
80057>>>    
80057>>>
80057>>>    Object oDbGroup1 is a dbGroup
80059>>>        Set Size to 218 462
80060>>>        Set Location to 13 11
80061>>>        Set Label to "Registro de Marcajes"
80062>>>
80062>>>        Object oDbCJGrid1 is a cDbCJGrid
80064>>>            Set Size to 198 402
80065>>>            Set Location to 11 5
80066>>>            Set pbAllowColumnRemove to False
80067>>>            Set pbAllowColumnResize to False
80068>>>            Set pbAllowColumnReorder to False
80069>>>
80069>>>            Object oMarcaje_Numero is a cDbCJGridColumn
80071>>>                Entry_Item Marcaje.Numero
80072>>>                Set piWidth to 50
80073>>>                Set psCaption to "Numero"
80074>>>                Set pbCapslock to True
80075>>>                Set peTextAlignment to xtpAlignmentCenter
80076>>>            End_Object
80077>>>            
80077>>>            
80077>>>
80077>>>            Object oMarcaje_Empleado is a cDbCJGridColumn
80079>>>                Entry_Item Empleado.Numero 
80080>>>                Set piWidth to 60
80081>>>                Set psCaption to "Empleado"
80082>>>                Set peTextAlignment to xtpAlignmentCenter
80083>>>                Set pbResizable to False
80084>>>            End_Object
80085>>>
80085>>>            Object oEmpleado_PrimerNombre is a cDbCJGridColumn
80087>>>                Entry_Item Empleado.PrimerNombre
80088>>>                Set piWidth to 62
80089>>>                Set psCaption to "Nombres"
80090>>>            End_Object
80091>>>
80091>>>            Object oEmpleado_SegundoNombre is a cDbCJGridColumn
80093>>>                Entry_Item Empleado.SegundoNombre
80094>>>                Set piWidth to 60
80095>>>            End_Object
80096>>>
80096>>>            Object oEmpleado_PrimerApellido is a cDbCJGridColumn
80098>>>                Entry_Item Empleado.PrimerApellido
80099>>>                Set piWidth to 60
80100>>>                Set psCaption to "Apellidos"
80101>>>            End_Object
80102>>>
80102>>>            Object oEmpleado_SegundoApellido is a cDbCJGridColumn
80104>>>                Entry_Item Empleado.SegundoApellido
80105>>>                Set piWidth to 60
80106>>>            End_Object
80107>>>
80107>>>            Object oMarcaje_FechaMarcaje is a cDbCJGridColumn
80109>>>                Entry_Item Marcaje.FechaMarcaje
80110>>>                Set piWidth to 60
80111>>>                Set psCaption to "Fecha"
80112>>>            End_Object
80113>>>
80113>>>            Object oMarcaje_HoraMarcaje is a cDbCJGridColumn
80115>>>                Entry_Item Marcaje.HoraMarcaje
80116>>>                Set piWidth to 60
80117>>>                Set psCaption to "Hora"
80118>>>            End_Object
80119>>>
80119>>>            Object oMarcaje_TipoMarcaje is a cDbCJGridColumn
80121>>>                Entry_Item TipoMarcaje.Numero
80122>>>                Set piWidth to 60
80123>>>                Set psCaption to "# Marcaje"
80124>>>                Set Prompt_Button_Mode to PB_PromptOn
80125>>>                Set Prompt_Object of oMarcaje_TipoMarcaje to (ListaTipoMarcaje(Current_Object))
80126>>>                
80126>>>            End_Object
80127>>>
80127>>>            Object oTipoMarcaje_TipoMarcaje is a cDbCJGridColumn
80129>>>                Entry_Item TipoMarcaje.TipoMarcaje
80130>>>                Set piWidth to 60
80131>>>                Set psCaption to "Marcaje"
80132>>>                
80132>>>            End_Object
80133>>>        End_Object
80134>>>    End_Object
80135>>>
80135>>>End_Object
80136>        Use Marcajes.rv
Including file: Marcajes.rv    (C:\DataFlex Projects\Control Marcajes\AppSrc\Marcajes.rv)
80136>>>Use Windows.pkg
80136>>>Use DFRptVw.pkg
80136>>>Use DFRpt.pkg
80136>>>Use File_Dlg.Pkg
80136>>>Use cNacionalidadDataDictionary.dd
80136>>>Use cEmpleadoDataDictionary.dd
80136>>>Use cTipoMarcajeDataDictionary.dd
80136>>>Use cMarcajeDataDictionary.dd
80136>>>Use DFEntry.pkg
80136>>>Use dfclient.pkg
80136>>>Use MonthCalendarPrompt.dg
80136>>>
80136>>>Activate_View Activate_Marcajes for Marcajes
80146>>>>
80146>>>Object Marcajes is a ReportView
80148>>>    Object oTipoMarcaje_DD is a cTipoMarcajeDataDictionary
80150>>>    End_Object
80151>>>
80151>>>    Object oNacionalidad_DD is a cNacionalidadDataDictionary
80153>>>    End_Object
80154>>>
80154>>>    Object oEmpleado_DD is a cEmpleadoDataDictionary
80156>>>        Set DDO_Server to oNacionalidad_DD
80157>>>    End_Object
80158>>>
80158>>>    Object oMarcaje_DD is a cMarcajeDataDictionary
80160>>>        Set DDO_Server to oTipoMarcaje_DD
80161>>>        Set DDO_Server to oEmpleado_DD
80162>>>    End_Object
80163>>>
80163>>>    Set Main_DD to oMarcaje_DD
80164>>>    Set Server to oMarcaje_DD
80165>>>
80165>>>    Set Location to 7 11
80166>>>    Set Size to 190 258
80167>>>    Set Label to "Marcajes"
80168>>>
80168>>>    Object oSaveAsDialog is a SaveAsDialog
80170>>>    End_Object
80171>>>
80171>>>    Procedure StartReport
80174>>>        Integer iOutputDevice 
80174>>>        Handle hoWorkspace
80174>>>        String sFileName sCurrentDirectory sDataPath
80174>>>    
80174>>>        Get Output_Device_Mode to iOutputDevice
80175>>>    
80175>>>        Case Begin
80175>>>            Case (iOutputDevice = PRINT_TO_WINDOW)
80177>>>                Get_Current_Directory to sCurrentDirectory
80178>>>                Get phoWorkspace Of ghoApplication to hoWorkspace
80179>>>                Get psDataPath Of hoWorkspace to sDataPath
80180>>>                Get PathAtIndex Of hoWorkspace sDataPath 1 to sDataPath
80181>>>                Set_Directory sDataPath
80182>>>                Make_Temp_File "TXT" sFileName
80183>>>                Set_Directory sCurrentDirectory
80184>>>                If (Right(sDataPath, 1) <> Sysconf(SYSCONF_DIR_SEPARATOR)) Begin
80186>>>                    Move (sDataPath - Sysconf(SYSCONF_DIR_SEPARATOR)) To sDataPath
80187>>>                End
80187>>>>
80187>>>                Move (sDataPath - sFileName) to sFileName
80188>>>                Set Output_Device_Name to sFileName
80189>>>                Case Break
80190>>>            
80190>>>        Case End
80190>>>    
80190>>>        Send Run_Report
80191>>>    
80191>>>        If (iOutputDevice = PRINT_TO_WINDOW) Begin
80193>>>            Runprogram Background "NotePad" sFileName
80194>>>            EraseFile sFileName
80195>>>>
80195>>>        End
80195>>>>
80195>>>    End_Procedure
80196>>>    
80196>>>    Object oBasicReport is a BasicReport
80198>>>        // Set Server To DDOName
80198>>>        
80198>>>        // Create a new file with the images for the report. Include this filename in the
80198>>>        // component with a USE statement. Replace the HeaderSection, BodySection, FooterSection
80198>>>        // with the imagenames you've created.
80198>>>        // NOTE: 
80198>>>        // - Image names must be unique throughout the program
80198>>>        // - Images start at the first column of the sourcecode in the format /ImageName
80198>>>        // - End of an image is the start of a new one or a /*
80198>>>
80198>>>        Function Starting_Main_Report Returns Integer
80201>>>            Integer iRetval
80201>>>            
80201>>>            Forward Get Starting_Main_Report to iRetval
80203>>>            
80203>>>            Function_Return iRetval
80204>>>        End_Function
80205>>>
80205>>>       
80205>>>
80205>>>    End_Object
80206>>>
80206>>>    Object GrupoRangoFechas is a Group
80208>>>        Set Size to 57 217
80209>>>        Set Location to 97 20
80210>>>        Set Label to "Rango de Fechas"
80211>>>
80211>>>        Object oGroup1 is a Group
80213>>>            Set Size to 29 95
80214>>>            Set Location to 19 6
80215>>>            Set Label to "Fecha Inicial   *"
80216>>>
80216>>>            Object TxtFechaInicial is a Form
80218>>>                Set Size to 13 81
80219>>>                Set Location to 10 7
80220>>>                Set Form_Datatype to Mask_Date_Window
80221>>>                Set Prompt_Object to oMonthCalendarPrompt
80222>>>                Set Prompt_Button_Mode to PB_PromptOn
80223>>>            
80223>>>                // OnChange is called on every changed character
80223>>>            //    Procedure OnChange
80223>>>            //        String sValue
80223>>>            //    
80223>>>            //        Get Value to sValue
80223>>>            //    End_Procedure
80223>>>            
80223>>>            End_Object
80224>>>        End_Object
80225>>>
80225>>>        Object oGroup1 is a Group
80227>>>            Set Size to 29 95
80228>>>            Set Location to 19 110
80229>>>            Set Label to "Fecha Final  *"
80230>>>
80230>>>            Object TxtFechaFinal is a Form
80232>>>                Set Size to 13 81
80233>>>                Set Location to 10 7
80234>>>                Set Form_Datatype to Mask_Date_Window
80235>>>                Set Prompt_Object to oMonthCalendarPrompt
80236>>>                Set Prompt_Button_Mode to PB_PromptOn
80237>>>            
80237>>>                // OnChange is called on every changed character
80237>>>            //    Procedure OnChange
80237>>>            //        String sValue
80237>>>            //    
80237>>>            //        Get Value to sValue
80237>>>            //    End_Procedure
80237>>>            
80237>>>            End_Object
80238>>>        End_Object
80239>>>    End_Object
80240>>>
80240>>>    Object oDbGroup1 is a dbGroup
80242>>>        Set Size to 80 216
80243>>>        Set Location to 13 20
80244>>>        Set Label to "Seleccionar filtros para el reporte"
80245>>>
80245>>>        Object TxtPais is a Form
80247>>>            Set Size to 13 40
80248>>>            Set Location to 22 55
80249>>>            Set Label to "Pais :"
80250>>>            Set Label_Col_Offset to 20
80251>>>            Set Prompt_Button_Mode to PB_PromptOn
80252>>>            Set Prompt_Object to (ListaNacionalidad(TxtPais))
80253>>>            Set Aux_Value to 0
80254>>>            //Set Form_Datatype to Mask_Numeric_Window
80254>>>            //Set Value to Default_Numeric_Mask
80254>>>           
80254>>>
80254>>>            Procedure OnChange
80257>>>                Forward Send OnChange
80259>>>                Set Label of EtiquetaPais to Nacionalidad.Pais
80260>>>                
80260>>>            
80260>>>                
80260>>>                
80260>>>            End_Procedure
80261>>>        
80261>>>            // OnChange is called on every changed character
80261>>>        //    Procedure OnChange
80261>>>        //        String sValue
80261>>>        //    
80261>>>        //        Get Value to sValue
80261>>>        //    End_Procedure
80261>>>        
80261>>>        End_Object
80262>>>
80262>>>        Object TxtEmpleado is a Form
80264>>>            Set Size to 13 40
80265>>>            Set Location to 44 55
80266>>>            Set Label to "Empleado :"
80267>>>            Set Label_Col_Offset to 38
80268>>>            Set Prompt_Button_Mode to PB_PromptOn
80269>>>            Set Prompt_Object to (ListaEmpleado(TxtEmpleado))            
80270>>>            Set Aux_Value to 0
80271>>>         
80271>>>
80271>>>            Procedure OnChange
80274>>>                Forward Send OnChange 
80276>>>                Set Label of EtiquetaEmpleado to (Trim(Empleado.PrimerNombre) + ' ' + Trim(Empleado.SegundoNombre) + ' ' + Trim(Empleado.PrimerApellido) + ' ' + Trim(Empleado.SegundoApellido))
80277>>>               
80277>>>            End_Procedure
80278>>>        
80278>>>            // OnChange is called on every changed character
80278>>>        //    Procedure OnChange
80278>>>        //        String sValue
80278>>>        //    
80278>>>        //        Get Value to sValue
80278>>>        //    End_Procedure
80278>>>        
80278>>>        End_Object
80279>>>
80279>>>        Object EtiquetaEmpleado is a TextBox
80281>>>            Set Size to 10 32
80282>>>            Set Location to 46 99
80283>>>            //Set Label to (Trim(Empleado.PrimerNombre) + ' ' + Trim(Empleado.PrimerNombre))
80283>>>        End_Object
80284>>>
80284>>>        Object EtiquetaPais is a TextBox
80286>>>            Set Size to 10 32
80287>>>            Set Location to 25 100
80288>>>            //Set Label to (Trim(Empleado.PrimerNombre) + ' ' + Trim(Empleado.PrimerNombre))
80288>>>        End_Object
80289>>>    End_Object
80290>>>
80290>>>    Object BtnGenerar is a Button  // ********Boton Generar
80292>>>        Set Size to 14 68
80293>>>        Set Location to 162 23
80294>>>        Set Label to "Generar"
80295>>>    
80295>>>        // fires when the button is clicked
80295>>>        Procedure OnClick
80298>>>            Forward Send OnClick False 
80300>>>             String Mensaje
80300>>>             Variant obtener
80300>>>             
80300>>>             Get Value of TxtPais to obtener
80301>>>            
80301>>>            If ( obtener = rdString) Begin           
80303>>>                 Send Info_Box "Solo se admiten valores Numericos"
80304>>>                 Procedure_Return
80305>>>            End 
80305>>>>
80305>>>            Else Begin
80306>>>                If (obtener = 0) Begin
80308>>>                     Move "Pais no Seleccionado" to Mensaje                     
80309>>>                End
80309>>>>
80309>>>                Else Begin
80310>>>                    Move obtener to Mensaje
80311>>>                   
80311>>>                End
80311>>>>
80311>>>            End
80311>>>>
80311>>>            
80311>>>            
80311>>>            
80311>>>            
80311>>>        End_Procedure
80312>>>    
80312>>>    End_Object
80313>>>
80313>>>    Object BtnNuevo is a Button
80315>>>        Set Size to 14 68
80316>>>        Set Location to 162 108
80317>>>        Set Label to "Nuevo"
80318>>>    
80318>>>        // fires when the button is clicked
80318>>>        Procedure OnClick
80321>>>             Number Dato 
80321>>>             String Mensaje
80321>>>            
80321>>>            Get Value of TxtPais to Dato
80322>>>            
80322>>>            If (Dato = 0) Begin
80324>>>                Move "Pais no Seleccionado" to Mensaje
80325>>>            End
80325>>>>
80325>>>            Else Begin
80326>>>               Get Label of EtiquetaPais to Mensaje
80327>>>            End
80327>>>>
80327>>>            
80327>>>        End_Procedure
80328>>>    
80328>>>    End_Object
80329>>>    
80329>>>    Procedure GenerarReporteMarcaje
80332>>>        
80332>>>        
80332>>>        
80332>>>    End_Procedure
80333>>>
80333>>>  
80333>>>    
80333>>>    
80333>>>End_Object
80334>
80334>        Procedure Activate_About
80337>            Send DoAbout "" "" "" "" ""
80338>        End_Procedure
80339>
80339>    End_Object
80340>
80340>End_Object
80341>
80341>Start_UI
80342>
80342>//************************** end of WindowsProject.tpl for Spanish **************
80342>
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 45610
Total Resources: 0
Total Commands : 80341
Total Windows  : 1
Total Pages    : 1
Static Data    : 492043
Message area   : 556794
Total Blocks   : 28811

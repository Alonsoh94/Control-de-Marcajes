Compiling Program: C:\DataFlex Projects\Control Marcajes\AppSrc\Control Marcajes.src
Memory Available: 2147483646
1>//**************************************************************
1>// WindowsProject.tpl for Spanish translated by Moose Software (www.moose-software.com) 
1>// 28/10/2008 revised for VDF 14.1 by Moose Software  
1>// 13/07/2010 Revised for VDF 16.0 by Moose Software
1>// 05/02/2012 Revised for VDF 17.0 by Moose Software
1>// 13/06/2013 Revised for VDF 17.1 by Moose Software
1>// 02/05/2014 Revised for VDF 18.0 by Moose Software
1>//*************************************************************************************
1>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.pkd    (C:\Program Files (x86)\DataFlex 18.2\Pkg\dfallent.pkd)
75339>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cCJStandardCommandBarSystem.pkg)
75339>>>// these are all the packages used in a standard MDI menubar/toolbar system
75339>>>
75339>>>Use cCJCommandBarSystem.pkg
75339>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cCJStandardMenuItemClasses.pkg)
75339>>>>>Use Dfpanel.pkg
75339>>>>>Use cCJCommandBarSystem.pkg
75339>>>>>Use LanguageText.pkg
75339>>>>>
75339>>>>>
75339>>>>>Class cCJUndoMenuItem is a cCJMenuItem
75340>>>>>    
75340>>>>>    Procedure Construct_Object
75342>>>>>        Forward Send Construct_Object
75344>>>>>        Set psCaption   to C_$CaptionUndo
75345>>>>>        Set psToolTip to C_$ToolTipUndo
75346>>>>>        Set psDescription to C_$DescUndo
75347>>>>>        Set psImage to "ActionUndo.ico"
75348>>>>>        Set pbActiveUpdate to True
75349>>>>>        Set psCategory to C_$CategoryEdit
75350>>>>>        Set psShortcut to C_$Key_Ctrl_Z
75351>>>>>    End_Procedure
75352>>>>>
75352>>>>>    Procedure OnExecute Variant vCommandBarControl
75354>>>>>        Send Undo of (focus(Self))
75355>>>>>    End_Procedure
75356>>>>>    
75356>>>>>    Function IsEnabled Returns Boolean
75358>>>>>        Boolean bEnabled
75358>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
75359>>>>>        Function_Return bEnabled
75360>>>>>    End_Function
75361>>>>>         
75361>>>>>End_Class
75362>>>>>
75362>>>>>
75362>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
75363>>>>>    
75363>>>>>    Procedure Construct_Object
75365>>>>>        Forward Send Construct_Object
75367>>>>>        Set psCaption   to C_$CaptionDelete
75368>>>>>        Set psToolTip to C_$ToolTipDelete
75369>>>>>        Set psDescription to C_$DescDelete
75370>>>>>        Set psImage to "actionDelete.ico"
75371>>>>>        Set psShortcut to C_$Key_Delete
75372>>>>>        Set pbActiveUpdate to True
75373>>>>>        Set psCategory to C_$CategoryEdit
75374>>>>>    End_Procedure
75375>>>>>
75375>>>>>
75375>>>>>    Procedure OnExecute Variant vCommandBarControl
75377>>>>>        Send Delete of (focus(Self))
75378>>>>>    End_Procedure
75379>>>>>    
75379>>>>>    Function IsEnabled Returns Boolean
75381>>>>>        Boolean bEnabled
75381>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
75382>>>>>        Function_Return bEnabled
75383>>>>>    End_Function
75384>>>>>         
75384>>>>>End_Class
75385>>>>>
75385>>>>>
75385>>>>>Class cCJCutMenuItem is a cCJMenuItem
75386>>>>>    
75386>>>>>    Procedure Construct_Object
75388>>>>>        Forward Send Construct_Object
75390>>>>>        Set psCaption   to C_$CaptionCut
75391>>>>>        Set psToolTip to C_$TooltipCut
75392>>>>>        Set psDescription to C_$DescCut
75393>>>>>        Set psImage to "actionCut.ico"
75394>>>>>        Set psShortcut to C_$Key_Ctrl_X
75395>>>>>        Set pbActiveUpdate to True
75396>>>>>        Set psCategory to C_$CategoryEdit
75397>>>>>    End_Procedure
75398>>>>>
75398>>>>>
75398>>>>>    Procedure OnExecute Variant vCommandBarControl
75400>>>>>        Send Cut of (focus(Self))
75401>>>>>    End_Procedure
75402>>>>>    
75402>>>>>    Function IsEnabled Returns Boolean
75404>>>>>        Boolean bEnabled
75404>>>>>        Get CanCut of (Focus(Self)) to bEnabled
75405>>>>>        Function_Return bEnabled
75406>>>>>    End_Function
75407>>>>>         
75407>>>>>End_Class
75408>>>>>
75408>>>>>
75408>>>>>Class cCJCopyMenuItem is a cCJMenuItem
75409>>>>>    
75409>>>>>    Procedure Construct_Object
75411>>>>>        Forward Send Construct_Object
75413>>>>>        Set psCaption   to C_$CaptionCopy
75414>>>>>        Set psToolTip to C_$ToolTipCopy
75415>>>>>        Set psDescription to C_$DescCopy
75416>>>>>        Set psImage to "actionCopy.ico"
75417>>>>>        Set psShortcut to C_$Key_Ctrl_C
75418>>>>>        Set pbActiveUpdate to True
75419>>>>>        Set psCategory to C_$CategoryEdit
75420>>>>>    End_Procedure
75421>>>>>
75421>>>>>
75421>>>>>    Procedure OnExecute Variant vCommandBarControl
75423>>>>>        Send Copy of (focus(Self))
75424>>>>>    End_Procedure
75425>>>>>    
75425>>>>>    Function IsEnabled Returns Boolean
75427>>>>>        Boolean bEnabled
75427>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
75428>>>>>        Function_Return bEnabled
75429>>>>>    End_Function
75430>>>>>         
75430>>>>>End_Class
75431>>>>>
75431>>>>>
75431>>>>>Class cCJPasteMenuItem is a cCJMenuItem
75432>>>>>    
75432>>>>>    Procedure Construct_Object
75434>>>>>        Forward Send Construct_Object
75436>>>>>        Set psCaption   to C_$CaptionPaste
75437>>>>>        Set psToolTip to C_$ToolTipPaste
75438>>>>>        Set psDescription to C_$DescPaste
75439>>>>>        Set psImage to "actionPaste.ico"
75440>>>>>        Set pbActiveUpdate to True
75441>>>>>        Set psShortcut to C_$Key_Ctrl_V
75442>>>>>        Set psCategory to C_$CategoryEdit
75443>>>>>    End_Procedure
75444>>>>>
75444>>>>>
75444>>>>>    Procedure OnExecute Variant vCommandBarControl
75446>>>>>        Send Paste of (focus(Self))
75447>>>>>    End_Procedure
75448>>>>>    
75448>>>>>    Function IsEnabled Returns Boolean
75450>>>>>        Boolean bEnabled
75450>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
75451>>>>>        Function_Return bEnabled
75452>>>>>    End_Function
75453>>>>>         
75453>>>>>End_Class
75454>>>>>
75454>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
75455>>>>>    
75455>>>>>    Procedure Construct_Object
75457>>>>>        Forward Send Construct_Object
75459>>>>>        Set psCaption   to C_$CaptionSelectAll
75460>>>>>        Set psToolTip to C_$ToolTipSelectAll
75461>>>>>        Set psDescription to C_$DescSelectAll
75462>>>>>        Set pbActiveUpdate to True
75463>>>>>        Set psShortcut to C_$Key_Ctrl_A
75464>>>>>        Set psCategory to C_$CategoryEdit
75465>>>>>    End_Procedure
75466>>>>>
75466>>>>>
75466>>>>>    Procedure OnExecute Variant vCommandBarControl
75468>>>>>        Send Select_All of (focus(Self))
75469>>>>>    End_Procedure
75470>>>>>    
75470>>>>>    Function IsEnabled Returns Boolean
75472>>>>>        Boolean bEnabled
75472>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
75473>>>>>        Function_Return bEnabled
75474>>>>>    End_Function
75475>>>>>         
75475>>>>>End_Class
75476>>>>>
75476>>>>> 
75476>>>>>Class cCJExitMenuItem is a cCJMenuItem
75477>>>>>
75477>>>>>    Procedure Construct_Object
75479>>>>>        Forward Send Construct_Object
75481>>>>>        Set psCaption to C_$CaptionExit
75482>>>>>        Set psToolTip to C_$ToolTipExit
75483>>>>>        Set psDescription to C_$ToolTipExit
75484>>>>>        Set psShortcut to C_$Key_Alt_F4
75485>>>>>        Set psCategory to C_$CategoryFile
75486>>>>>    End_Procedure
75487>>>>>
75487>>>>>    Procedure OnExecute Variant vCommandBarControl
75489>>>>>        Send Exit_Application of Desktop
75490>>>>>    End_Procedure
75491>>>>>
75491>>>>>End_Class           
75492>>>>>
75492>>>>>Class cCJHelpMenuItem is a cCJMenuItem    
75493>>>>>
75493>>>>>    Procedure Construct_Object
75495>>>>>        Forward Send Construct_Object
75497>>>>>        Set psCaption to C_$CaptionHelp
75498>>>>>        Set psDescription to C_$ToolTipHelp
75499>>>>>        Set psToolTip to C_$DescHelp
75500>>>>>        Set psImage to "ActionHelp.ico"
75501>>>>>        Set psShortcut to "F1"
75502>>>>>        Set psCategory to C_$CategoryHelp
75503>>>>>    End_Procedure
75504>>>>>    
75504>>>>>    Procedure OnExecute Variant vCommandBarControl
75506>>>>>        Send Help of (Focus(Self))
75507>>>>>    End_Procedure
75508>>>>>
75508>>>>>End_Class
75509>>>>>
75509>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
75510>>>>>
75510>>>>>    Procedure Construct_Object
75512>>>>>        Forward Send Construct_Object
75514>>>>>        Set psCaption to C_$CaptionAddStatusbar
75515>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
75516>>>>>        Set psDescription to  C_$DescAddStatusbar
75517>>>>>        Set psCategory to C_$CategoryWindow
75518>>>>>    End_Procedure
75519>>>>>
75519>>>>>    Procedure OnExecute Variant vCommandBarControl
75521>>>>>        Handle hoCommandBars hoClientArea
75521>>>>>        Get CommandBarSystemObject to hoCommandBars
75522>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
75523>>>>>        If hoClientArea Begin
75525>>>>>            // the clientarea's parent panel has message
75525>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
75526>>>>>        End
75526>>>>>>
75526>>>>>    End_Procedure
75527>>>>>
75527>>>>>     Function IsChecked Returns Boolean
75529>>>>>        Boolean bOn
75529>>>>>        Handle hoCommandBars hoClientArea
75529>>>>>        Get CommandBarSystemObject to hoCommandBars
75530>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
75531>>>>>        If hoClientArea Begin
75533>>>>>            // the clientarea's parent panel has message
75533>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
75534>>>>>        End
75534>>>>>>
75534>>>>>        Function_Return bOn
75535>>>>>     End_Function
75536>>>>>End_Class
75537>>>>>
75537>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
75538>>>>>
75538>>>>>    Procedure Construct_Object
75540>>>>>        Forward Send Construct_Object
75542>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
75543>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
75544>>>>>        Set psDescription to C_$DescAutoArrangeIcons
75545>>>>>        Set psCategory to C_$CategoryWindow
75546>>>>>    End_Procedure
75547>>>>>
75547>>>>>    Procedure OnExecute Variant vCommandBarControl
75549>>>>>        Handle hoCommandBars hoClientArea
75549>>>>>        Get CommandBarSystemObject to hoCommandBars
75550>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
75551>>>>>        If hoClientArea Begin
75553>>>>>            // the clientarea's parent panel has message
75553>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
75554>>>>>        End
75554>>>>>>
75554>>>>>    End_Procedure
75555>>>>>    
75555>>>>>     Function IsChecked Returns Boolean
75557>>>>>        Boolean bOn
75557>>>>>        Handle hoCommandBars hoClientArea
75557>>>>>        Get CommandBarSystemObject to hoCommandBars
75558>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
75559>>>>>        If hoClientArea Begin
75561>>>>>            // the clientarea's parent panel has message
75561>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
75562>>>>>        End
75562>>>>>>
75562>>>>>        Function_Return bOn
75563>>>>>     End_Function
75564>>>>>End_Class
75565>>>>>
75565>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
75566>>>>>
75566>>>>>    Procedure Construct_Object
75568>>>>>        Forward Send Construct_Object
75570>>>>>        Set psCaption to C_$CaptionRestoreMenus
75571>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
75572>>>>>        Set psDescription to C_$DescRestoreMenus
75573>>>>>        Set psCategory to C_$CategoryWindow
75574>>>>>    End_Procedure
75575>>>>>
75575>>>>>    Procedure OnExecute Variant vCommandBarControl
75577>>>>>        Handle hoCommandBars
75577>>>>>        Get CommandBarSystemObject to hoCommandBars
75578>>>>>        Send RestoreLayout of hoCommandBars
75579>>>>>    End_Procedure
75580>>>>>    
75580>>>>>End_Class
75581>>>>>
75581>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
75582>>>>>
75582>>>>>    Procedure Construct_Object
75584>>>>>        Forward Send Construct_Object
75586>>>>>        Set psCaption to C_$CaptionCascade
75587>>>>>        Set psToolTip to C_$ToolTipCascade
75588>>>>>        Set psDescription to  C_$DescCascade
75589>>>>>        Set psImage to "ActionCascade.ico"
75590>>>>>        Set psCategory to C_$CategoryWindow
75591>>>>>    End_Procedure
75592>>>>>    
75592>>>>>    Procedure OnExecute Variant vCommandBarControl
75594>>>>>        Handle hoCommandBars hoClientArea
75594>>>>>        Get CommandBarSystemObject to hoCommandBars
75595>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
75596>>>>>        If hoClientArea Begin
75598>>>>>            Send Cascade_Windows of hoClientArea
75599>>>>>        End
75599>>>>>>
75599>>>>>    End_Procedure
75600>>>>>End_Class
75601>>>>>
75601>>>>>Class cCJTileHorizontally is a cCJMenuItem
75602>>>>>
75602>>>>>    Procedure Construct_Object
75604>>>>>        Forward Send Construct_Object
75606>>>>>        Set psCaption to C_$CaptionTileHorizontally 
75607>>>>>        Set psToolTip to C_$ToolTipTileHorizontally  
75608>>>>>        Set psDescription to  C_$DescTileHorizontally
75609>>>>>        Set psImage to "ActionTileHorizontally.ico"
75610>>>>>        Set psCategory to C_$CategoryWindow
75611>>>>>    End_Procedure
75612>>>>>
75612>>>>>    Procedure OnExecute Variant vCommandBarControl
75614>>>>>        Handle hoCommandBars hoClientArea
75614>>>>>        Get CommandBarSystemObject to hoCommandBars
75615>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
75616>>>>>        If hoClientArea Begin
75618>>>>>            Send Tile_Windows_Horizontal of hoClientArea
75619>>>>>        End
75619>>>>>>
75619>>>>>    End_Procedure
75620>>>>>End_Class
75621>>>>>
75621>>>>>Class cCJTileVertically is a cCJMenuItem
75622>>>>>
75622>>>>>    Procedure Construct_Object
75624>>>>>        Forward Send Construct_Object
75626>>>>>        Set psCaption to C_$CaptionTileVertically  
75627>>>>>        Set psToolTip to C_$ToolTipTileVertically
75628>>>>>        Set psDescription to  C_$DescTileVertically
75629>>>>>        Set psImage to "ActionTileVertically.ico"
75630>>>>>        Set psCategory to C_$CategoryWindow
75631>>>>>    End_Procedure
75632>>>>>
75632>>>>>    Procedure OnExecute Variant vCommandBarControl
75634>>>>>        Handle hoCommandBars hoClientArea
75634>>>>>        Get CommandBarSystemObject to hoCommandBars
75635>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
75636>>>>>        If hoClientArea Begin
75638>>>>>            Send Tile_Windows_Vertical of hoClientArea
75639>>>>>        End
75639>>>>>>
75639>>>>>    End_Procedure
75640>>>>>End_Class
75641>>>>>
75641>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
75642>>>>>
75642>>>>>    Procedure Construct_Object
75644>>>>>        Forward Send Construct_Object
75646>>>>>        Set psCaption to C_$CaptionMinimizeWindows 
75647>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
75648>>>>>        Set psDescription to  C_$DescMinimizeWindows
75649>>>>>        Set psCategory to C_$CategoryWindow
75650>>>>>    End_Procedure
75651>>>>>
75651>>>>>    Procedure OnExecute Variant vCommandBarControl
75653>>>>>        Handle hoCommandBars hoClientArea
75653>>>>>        Get CommandBarSystemObject to hoCommandBars
75654>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
75655>>>>>        If hoClientArea Begin
75657>>>>>            // the clientarea's parent panel has message
75657>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
75658>>>>>        End
75658>>>>>>
75658>>>>>    End_Procedure
75659>>>>>End_Class
75660>>>>>
75660>>>>>
75660>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
75661>>>>>
75661>>>>>    Procedure Construct_Object
75663>>>>>        Forward Send Construct_Object
75665>>>>>        Set psCaption to C_$CaptionRestoreWindows
75666>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
75667>>>>>        Set psDescription to  C_$DescRestoreWindows
75668>>>>>        Set psCategory to C_$CategoryWindow
75669>>>>>    End_Procedure
75670>>>>>
75670>>>>>    Procedure OnExecute Variant vCommandBarControl
75672>>>>>        Handle hoCommandBars hoClientArea
75672>>>>>        Get CommandBarSystemObject to hoCommandBars
75673>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
75674>>>>>        If hoClientArea Begin
75676>>>>>            // the clientarea's parent panel has message
75676>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
75677>>>>>        End
75677>>>>>>
75677>>>>>    End_Procedure
75678>>>>>End_Class
75679>>>>>
75679>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
75680>>>>>
75680>>>>>    Procedure Construct_Object
75682>>>>>        Forward Send Construct_Object
75684>>>>>        Set psCaption to C_$CaptionArrangeIcons  
75685>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
75686>>>>>        Set psDescription to  C_$DescArrangeIcons
75687>>>>>        Set psCategory to C_$CategoryWindow
75688>>>>>    End_Procedure
75689>>>>>
75689>>>>>    Procedure OnExecute Variant vCommandBarControl
75691>>>>>        Handle hoCommandBars hoClientArea
75691>>>>>        Get CommandBarSystemObject to hoCommandBars
75692>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
75693>>>>>        If hoClientArea Begin
75695>>>>>            Send Arrange_Icons of hoClientArea
75696>>>>>        End
75696>>>>>>
75696>>>>>    End_Procedure
75697>>>>>
75697>>>>>End_Class
75698>>>>>    
75698>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cCJAboutMenuItem.pkg)
75698>>>>>Use cCJCommandBarSystem.pkg
75698>>>>>Use LanguageText.pkg
75698>>>>>
75698>>>>>// It is expected that if you use this class that you provide an about object that is
75698>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
75698>>>>>// because you may wish to create your own custom about package.
75698>>>>>
75698>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
75699>>>>>
75699>>>>>    Procedure Construct_Object
75701>>>>>        Forward Send Construct_Object
75703>>>>>        Set psCaption to C_$CaptionAbout
75704>>>>>        Set psDescription to C_$ToolTipAbout
75705>>>>>        Set psToolTip to C_$DescAbout
75706>>>>>        Set psImage to "ActionAbout.ico"
75707>>>>>        Set psCategory to C_$CategoryHelp
75708>>>>>    End_Procedure
75709>>>>>    
75709>>>>>    Procedure OnExecute Variant vCommandBarControl
75711>>>>>        Handle hoCommandBars hoClientArea
75711>>>>>        Get CommandBarSystemObject to hoCommandBars
75712>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
75713>>>>>        If hoClientArea Begin
75715>>>>>            Send Activate_About of hoClientArea
75716>>>>>        End
75716>>>>>>
75716>>>>>    End_Procedure
75717>>>>>
75717>>>>>End_Class
75718>>>>>
75718>>>>>
75718>>>Use cCJDeoMenuItemClasses.pkg
75718>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cCJMDIWindowsMenuItem.pkg)
75718>>>>>Use cCJCommandBarSystem.pkg
75718>>>>>
75718>>>>>Register_Function Client_ID Returns Integer
75718>>>>>
75718>>>>>// only used by cCJMDIWIndowsMenuItem
75718>>>>>Class cCJMDIWindowItem is a cCJMenuItem
75719>>>>>
75719>>>>>    Procedure Construct_Object
75721>>>>>        Forward Send Construct_Object
75723>>>>>        Property Handle phWindow 0 // object id of view
75724>>>>>        Set pbControlFlagNoMovable to True
75725>>>>>        Set pbActiveUpdate to True
75726>>>>>    End_Procedure
75727>>>>>    
75727>>>>>    Procedure OnExecute Variant vCommandBarControl
75729>>>>>        Handle hWindow
75729>>>>>        Get phWindow to hWindow
75730>>>>>        Send Activate_View of hWindow
75731>>>>>    End_Procedure
75732>>>>>    
75732>>>>>End_Class                
75733>>>>>
75733>>>>>
75733>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
75734>>>>>    
75734>>>>>    Procedure Construct_Object
75736>>>>>        Forward Send Construct_Object
75738>>>>>        Property Handle[] phArrayOfWindows
75739>>>>>        Set peControlType to xtpControlPopup
75740>>>>>        Set psCategory to C_$CategoryWindow
75741>>>>>    End_Procedure
75742>>>>>    
75742>>>>>     // This adds MDI windows to the existing menu items.
75742>>>>>     // This removes any existing windows menus and always adds a new set to the end
75742>>>>>
75742>>>>>     Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
75744>>>>>        Handle  hClientArea hView
75744>>>>>        String  sLabel
75744>>>>>        Integer i iWindows
75744>>>>>        Handle[] hArrayOfWindows
75745>>>>>        Variant vItem
75745>>>>>        
75745>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
75745>>>>>        // also assume that destroying an action removes all menu instances of that action
75745>>>>>        Get phArrayOfWindows to hArrayOfWindows
75746>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
75747>>>>>        For i from 0 to (iWindows-1)
75753>>>>>>
75753>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
75754>>>>>        Loop
75755>>>>>>
75755>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
75756>>>>>
75756>>>>>        // Add all views to this menu. Create the action and add the item
75756>>>>>        Move 0 to i
75757>>>>>        Get Client_Id to hClientArea // object id of client area
75758>>>>>        If (hClientArea > 0) Begin
75760>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
75761>>>>>            While (hView <> 0)
75765>>>>>                If (Active_State(hView)) Begin
75767>>>>>                    // create the action
75767>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
75768>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
75769>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
75770>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
75771>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
75773>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
75774>>>>>                    End
75774>>>>>>
75774>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
75775>>>>>                    If (i=0) Begin
75777>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
75778>>>>>                    End
75778>>>>>>
75778>>>>>                    // Create a menu item for this action
75778>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
75779>>>>>                    Increment i
75780>>>>>                End
75780>>>>>>
75780>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
75781>>>>>            Loop
75782>>>>>>
75782>>>>>        End
75782>>>>>>
75782>>>>>
75782>>>>>        Set phArrayOfWindows to hArrayOfWindows
75783>>>>>
75783>>>>>     End_Procedure
75784>>>>>     
75784>>>>>End_Class
75785>>>>>
75785>Use MonthCalendarPrompt.dg
Including file: MonthCalendarPrompt.dg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\MonthCalendarPrompt.dg)
75785>>>// Month Calendar Prompt dialog
75785>>>
75785>>>
75785>>>Use cMonthCalendarPrompt.pkg
Including file: cMonthCalendarPrompt.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cMonthCalendarPrompt.pkg)
75785>>>>>Use cMonthCalendar.pkg
Including file: cMonthCalendar.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cMonthCalendar.pkg)
75785>>>>>>>Use Windows.pkg
75785>>>>>>>Use Commctrl.pkg
75785>>>>>>>Use tWinStructs.pkg
75785>>>>>>>Use cWinControlEx.pkg
Including file: cWinControlEx.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cWinControlEx.pkg)
75785>>>>>>>>>Use cWinControl.pkg
75785>>>>>>>>>// This adds proper navigation and default button support for
75785>>>>>>>>>// external classes
75785>>>>>>>>>
75785>>>>>>>>>Class cWinControlEx is a cWinControl
75786>>>>>>>>>    Import_Class_Protocol Standard_Form_Mixin
75787>>>>>>>>>    Procedure Construct_Object
75789>>>>>>>>>        Forward Send Construct_Object
75791>>>>>>>>>        Send define_standard_Form_Mixin
75792>>>>>>>>>    End_Procedure
75793>>>>>>>>>    
75793>>>>>>>>>    Function item_count Integer iItem Returns Integer
75795>>>>>>>>>        Function_Return 1
75796>>>>>>>>>    End_Function
75797>>>>>>>>>    
75797>>>>>>>>>    Procedure External_SetFocus
75799>>>>>>>>>        Send notify_focus_change 1
75800>>>>>>>>>    End_Procedure
75801>>>>>>>>>
75801>>>>>>>>>    Procedure External_KillFocus
75803>>>>>>>>>        Send notify_focus_change 0
75804>>>>>>>>>    End_Procedure
75805>>>>>>>>>
75805>>>>>>>>>    Procedure End_Construct_Object
75807>>>>>>>>>        Forward Send End_Construct_Object
75809>>>>>>>>>        Set External_Message WM_SETFOCUS  to External_SetFocus
75810>>>>>>>>>        Set External_Message WM_KILLFOCUS to External_KillFocus
75811>>>>>>>>>    End_Procedure
75812>>>>>>>>>        
75812>>>>>>>>>End_Class
75813>>>>>>>>>
75813>>>>>>>
75813>>>>>>>Class cMonthCalendar is a cWinControlEx
75814>>>>>>>    Procedure Construct_Object
75816>>>>>>>        Integer iResult
75816>>>>>>>        tWinInitCommonControlsEX InitCC
75816>>>>>>>        tWinInitCommonControlsEX InitCC
75816>>>>>>>
75816>>>>>>>        Forward Send Construct_Object
75818>>>>>>>
75818>>>>>>>        Move (SizeOfType (tWinInitCommonControlsEX)) to InitCC.dwSize
75819>>>>>>>        Move ICC_DATE_CLASSES to InitCC.dwICC
75820>>>>>>>        Move (InitCommonControlsEx(AddressOf(InitCC))) to iResult
75821>>>>>>>        
75821>>>>>>>        Set External_Class_Name 'cMonthCalendar' to 'SysMonthCal32'
75822>>>>>>>        Set External_Message WM_LBUTTONDBLCLK to msg_OnLButtonDblClick
75823>>>>>>>        
75823>>>>>>>        Set Border_Style to Border_Normal
75824>>>>>>>        
75824>>>>>>>        Property Boolean pbNoToday False
75825>>>>>>>        Property Boolean pbNoTodayCircle False
75826>>>>>>>        Property Boolean pbMultiSelect False
75827>>>>>>>        Property Boolean pbWeekNumbers False
75828>>>>>>>        Property Integer piMaxSelectedCount 90
75829>>>>>>>        
75829>>>>>>>        // this is minimum Dialog units required for a single picker rectangle
75829>>>>>>>        Property Integer piMinWidth 0
75830>>>>>>>        Property Integer piMinHeight 0
75831>>>>>>>
75831>>>>>>>        // stores initial date before control is activated
75831>>>>>>>        Property Date pdPrivateDate 
75832>>>>>>>        // if multi-select, this is the end range
75832>>>>>>>        Property Date pdPrivateDate2 
75833>>>>>>>        
75833>>>>>>>    End_Procedure
75834>>>>>>>    
75834>>>>>>>    // returns control's value when single select
75834>>>>>>>    Function SelectedDate Returns Date
75836>>>>>>>        tWinSystemTime CurrentSystemTime
75836>>>>>>>        tWinSystemTime CurrentSystemTime
75836>>>>>>>        Integer iRetval
75836>>>>>>>        DateTime dtSel
75836>>>>>>>        Handle hWnd
75836>>>>>>>        Get Window_Handle to hWnd
75837>>>>>>>        If (hWnd) Begin
75839>>>>>>>            Move (Windows_Message (MCM_GETCURSEL, 0, AddressOf (CurrentSystemTime))) to iRetval
75840>>>>>>>            Move (DateSetDay(dtSel,CurrentSystemTime.wDay)) to dtSel
75841>>>>>>>            Move (DateSetMonth(dtSel,CurrentSystemTime.wMonth)) to dtSel
75842>>>>>>>            Move (DateSetYear(dtSel,CurrentSystemTime.wYear)) to dtSel
75843>>>>>>>        End
75843>>>>>>>>
75843>>>>>>>        Else Begin
75844>>>>>>>            Get pdPrivateDate to dtSel
75845>>>>>>>        End
75845>>>>>>>>
75845>>>>>>>        Function_Return (Date(dtSel))
75846>>>>>>>    End_Function
75847>>>>>>>
75847>>>>>>>    // returns control's values when multi select
75847>>>>>>>    Function SelectedDateRange Returns Date[]
75849>>>>>>>        tWinSystemTime[2] CurrentSystemTime
75849>>>>>>>        tWinSystemTime[2] CurrentSystemTime
75850>>>>>>>        Integer iRetval
75850>>>>>>>        DateTime dtSel1 dtsel2
75850>>>>>>>        Date[] dtSel
75851>>>>>>>        Handle hWnd
75851>>>>>>>        Get Window_Handle to hWnd
75852>>>>>>>        If (hWnd) Begin
75854>>>>>>>            Move (Windows_Message (MCM_GETSELRANGE, 0, AddressOf (CurrentSystemTime))) to iRetval
75855>>>>>>>            
75855>>>>>>>            Move (DateSetDay(dtSel1,CurrentSystemTime[0].wDay)) to dtSel1
75856>>>>>>>            Move (DateSetMonth(dtSel1,CurrentSystemTime[0].wMonth)) to dtSel1
75857>>>>>>>            Move (DateSetYear(dtSel1,CurrentSystemTime[0].wYear)) to dtSel1
75858>>>>>>>            
75858>>>>>>>            Move (DateSetDay(dtSel2,CurrentSystemTime[1].wDay)) to dtSel2
75859>>>>>>>            Move (DateSetMonth(dtSel2,CurrentSystemTime[1].wMonth)) to dtSel2
75860>>>>>>>            Move (DateSetYear(dtSel2,CurrentSystemTime[1].wYear)) to dtSel2
75861>>>>>>>            
75861>>>>>>>            Move dtSel1 to dtSel[0]
75862>>>>>>>            Move dtsel2 to dtSel[1]
75863>>>>>>>        End
75863>>>>>>>>
75863>>>>>>>        Else Begin
75864>>>>>>>            Get pdPrivateDate to dtSel[0]
75865>>>>>>>            Get pdPrivateDate2 to dtSel[1]
75866>>>>>>>        End
75866>>>>>>>>
75866>>>>>>>        Function_Return dtSel
75867>>>>>>>    End_Function
75868>>>>>>>
75868>>>>>>>    // Set control's value when single select
75868>>>>>>>    Procedure SetSelectedDate Date dDate
75870>>>>>>>        tWinSystemTime CurrentSystemTime
75870>>>>>>>        tWinSystemTime CurrentSystemTime
75870>>>>>>>        Integer iRetval
75870>>>>>>>        Handle hWnd
75870>>>>>>>        
75870>>>>>>>        Get Window_Handle to hWnd
75871>>>>>>>        Set pdPrivateDate to dDate
75872>>>>>>>        If (hWnd) Begin
75874>>>>>>>            Move (DateGetDay(dDate)) to CurrentSystemTime.wDay
75875>>>>>>>            Move (DateGetMonth(dDate)) to CurrentSystemTime.wMonth
75876>>>>>>>            Move (DateGetYear(dDate)) to CurrentSystemTime.wYear
75877>>>>>>>    
75877>>>>>>>           Move (Windows_Message (MCM_SETCURSEL, 0, AddressOf (CurrentSystemTime))) to iRetval        
75878>>>>>>>        End
75878>>>>>>>>
75878>>>>>>>    End_Procedure
75879>>>>>>>
75879>>>>>>>    // Set control's values when multi select
75879>>>>>>>    Procedure SetSelectedDateRange Date dDate Date dDate2
75881>>>>>>>        tWinSystemTime[] CurrentSystemTime
75881>>>>>>>        tWinSystemTime[] CurrentSystemTime
75882>>>>>>>        Integer iRetval
75882>>>>>>>        Handle hWnd
75882>>>>>>>
75882>>>>>>>        Get Window_Handle to hWnd
75883>>>>>>>        Set pdPrivateDate to dDate
75884>>>>>>>        Set pdPrivateDate2 to dDate2
75885>>>>>>>        If (hWnd) Begin
75887>>>>>>>            Move (DateGetDay(dDate)) to CurrentSystemTime[0].wDay
75888>>>>>>>            Move (DateGetMonth(dDate)) to CurrentSystemTime[0].wMonth
75889>>>>>>>            Move (DateGetYear(dDate)) to CurrentSystemTime[0].wYear
75890>>>>>>>
75890>>>>>>>            Move (DateGetDay(dDate2)) to CurrentSystemTime[1].wDay
75891>>>>>>>            Move (DateGetMonth(dDate2)) to CurrentSystemTime[1].wMonth
75892>>>>>>>            Move (DateGetYear(dDate2)) to CurrentSystemTime[1].wYear
75893>>>>>>>    
75893>>>>>>>            Move (Windows_Message (MCM_SETSELRANGE, 0, AddressOf (CurrentSystemTime))) to iRetval        
75894>>>>>>>        End
75894>>>>>>>>
75894>>>>>>>    End_Procedure
75895>>>>>>>    
75895>>>>>>>    // augment to set dates from control, so they can be accessed after the control is closed
75895>>>>>>>    Procedure Remove_Object
75897>>>>>>>        Date[] SelDate 
75898>>>>>>>        If (pbMultiSelect(Self)) Begin
75900>>>>>>>            Get SelectedDateRange to SelDate
75901>>>>>>>            Set pdPrivateDate2 to SelDate[1]
75902>>>>>>>        End
75902>>>>>>>>
75902>>>>>>>        Else Begin
75903>>>>>>>            Get SelectedDate to SelDate[0]
75904>>>>>>>        End
75904>>>>>>>>
75904>>>>>>>        Set pdPrivateDate to SelDate[0]
75905>>>>>>>        Forward Send Remove_Object
75907>>>>>>>    End_Procedure
75908>>>>>>>
75908>>>>>>>    Procedure Page Integer iState
75910>>>>>>>        Integer iRetval iSize iHeight iWidth
75910>>>>>>>        tWinRect WindowRect
75910>>>>>>>        tWinRect WindowRect
75910>>>>>>>        Date dDate dDate2
75910>>>>>>>        Handle hWnd
75910>>>>>>>        Integer  iMaxSelectedCount
75910>>>>>>>        Boolean bNoToday bWeekNumbers bMultiSelect bNoTodayCircle
75910>>>>>>>        
75910>>>>>>>        If (iState<>1) Begin
75912>>>>>>>            Forward Send Page iState
75914>>>>>>>            Procedure_Return
75915>>>>>>>        End
75915>>>>>>>>
75915>>>>>>>        
75915>>>>>>>        Set Icon to 'ActionCalendar.ico'
75916>>>>>>>
75916>>>>>>>        Get pbNoToday to bNoToday
75917>>>>>>>        Get pbNoTodayCircle to bNoTodayCircle
75918>>>>>>>        Get pbMultiSelect to bMultiSelect
75919>>>>>>>        Get pbWeekNumbers to bWeekNumbers
75920>>>>>>>        Get piMaxSelectedCount to iMaxSelectedCount
75921>>>>>>>
75921>>>>>>>        Set Window_Style MCS_MULTISELECT to bMultiSelect
75922>>>>>>>        Set Window_Style MCS_NOTODAY to bNoToday
75923>>>>>>>        Set Window_Style MCS_NOTODAYCIRCLE to bNoTodayCircle
75924>>>>>>>        Set Window_Style MCS_WEEKNUMBERS to bWeekNumbers
75925>>>>>>>        Forward Send Page iState
75927>>>>>>>
75927>>>>>>>        Get Window_Handle to hWnd
75928>>>>>>>        // support double click
75928>>>>>>>        Move (SetClassLong(hWnd,GCL_STYLE,CS_DBLCLKS ior CS_GLOBALCLASS)) to iRetval
75929>>>>>>>        // set range when multi select
75929>>>>>>>        Move (Windows_Message(MCM_SETMAXSELCOUNT,iMaxSelectedCount,0)) to iRetval
75930>>>>>>>        
75930>>>>>>>        // store minimum size for calendar control and set the size to this by default
75930>>>>>>>        Move (Windows_Message (MCM_GETMINREQRECT, 0, AddressOf(WindowRect))) to iRetval
75931>>>>>>>        Get GuiToDialog WindowRect.bottom WindowRect.right to iSize
75932>>>>>>>        Move (Hi(iSize)) to iHeight
75933>>>>>>>        Move (Low(iSize)) to iWidth
75934>>>>>>>        Set piMinWidth to iWidth
75935>>>>>>>        Set piMinHeight to iHeight
75936>>>>>>>        Set Size to iHeight iWidth
75937>>>>>>>        
75937>>>>>>>        // now that we are activated set starting date or date range
75937>>>>>>>        Get pdPrivateDate to dDate
75938>>>>>>>        If (pbMultiSelect(Self)) Begin
75940>>>>>>>            Get pdPrivateDate2 to dDate2
75941>>>>>>>            Send SetSelectedDateRange dDate dDate2
75942>>>>>>>        End
75942>>>>>>>>
75942>>>>>>>        Else Begin
75943>>>>>>>            Send SetSelectedDate dDate
75944>>>>>>>        End
75944>>>>>>>>
75944>>>>>>>    End_Procedure
75945>>>>>>>
75945>>>>>>>    Procedure Notify Integer wParam Integer lParam
75947>>>>>>>        Integer iRetval
75947>>>>>>>        DateTime dtSel dtSel2
75947>>>>>>>        tWintagNMSelChange CalenderInfo
75947>>>>>>>        tWintagNMSelChange CalenderInfo
75947>>>>>>>        Boolean bMulti
75947>>>>>>>        
75947>>>>>>>        Move (MemCopy (AddressOf (CalenderInfo), lParam, SizeOfType (tWintagNMSelChange))) to iRetval
75948>>>>>>>        If (CalenderInfo.nmHdr.code = MCN_SELCHANGE) Begin
75950>>>>>>>            Get pbMultiSelect to bMulti
75951>>>>>>>            Move (DateSetDay(dtSel,CalenderInfo.stSelStart.wDay)) to dtSel
75952>>>>>>>            Move (DateSetMonth(dtSel,CalenderInfo.stSelStart.wMonth)) to dtSel
75953>>>>>>>            Move (DateSetYear(dtSel,CalenderInfo.stSelStart.wYear)) to dtSel
75954>>>>>>>            If bMulti Begin
75956>>>>>>>                Move (DateSetDay(dtSel,CalenderInfo.stSelEnd.wDay)) to dtSel2
75957>>>>>>>                Move (DateSetMonth(dtSel,CalenderInfo.stSelEnd.wMonth)) to dtSel2
75958>>>>>>>                Move (DateSetYear(dtSel,CalenderInfo.stSelEnd.wYear)) to dtSel2
75959>>>>>>>            End
75959>>>>>>>>
75959>>>>>>>            Send OnChange (Date(dtSel)) (Date(dtSel2))
75960>>>>>>>        End
75960>>>>>>>>
75960>>>>>>>    End_Procedure
75961>>>>>>>
75961>>>>>>>    // sent whenever there is a selection change within the calendar
75961>>>>>>>    Procedure OnChangeDate Date dDate Date dDate2
75963>>>>>>>    End_Procedure
75964>>>>>>>
75964>>>>>>>    // sent when a click occurs in the calendar 
75964>>>>>>>    Procedure OnClick
75966>>>>>>>    End_Procedure
75967>>>>>>>    
75967>>>>>>>    // sent when a double click occurs in the calendar 
75967>>>>>>>    Procedure OnDoubleClick
75969>>>>>>>    End_Procedure
75970>>>>>>>    
75970>>>>>>>    // sends OnClick if the double click is on a calendar day
75970>>>>>>>    Procedure OnLButtonDblClick Integer wParam Integer lParam
75972>>>>>>>        Boolean bDayHit
75972>>>>>>>        Get MonthDayHit to bDayHit
75973>>>>>>>        If bDayHit Begin
75975>>>>>>>            Send OnDoubleClick
75976>>>>>>>        End
75976>>>>>>>>
75976>>>>>>>    End_Procedure
75977>>>>>>>
75977>>>>>>>    // sends OnClick if the click is on a calendar day
75977>>>>>>>    Procedure OnWmLButtonUp Integer wParam Integer lParam
75979>>>>>>>        Boolean bDayHit
75979>>>>>>>        Get MonthDayHit to bDayHit
75980>>>>>>>        If bDayHit Begin
75982>>>>>>>            Send OnClick
75983>>>>>>>        End
75983>>>>>>>>
75983>>>>>>>    End_Procedure
75984>>>>>>>    
75984>>>>>>>    // returns true if the month calander is up and the mouse is over a day
75984>>>>>>>    Function MonthDayHit Returns Boolean
75986>>>>>>>        Integer iRet
75986>>>>>>>        Get Windows_Message MCM_GETCURRENTVIEW 0 0 to iRet
75987>>>>>>>        If (iRet=MCMV_MONTH) Begin
75989>>>>>>>            Get HitTest to iRet
75990>>>>>>>            Function_Return (iRet=MCHT_CALENDARDATE)
75991>>>>>>>        End
75991>>>>>>>>
75991>>>>>>>        Function_Return False
75992>>>>>>>    End_Function
75993>>>>>>>    
75993>>>>>>>    // return what was hit in the control
75993>>>>>>>    Function HitTest Returns Integer
75995>>>>>>>        tWinMCHitTestInfo HitInfo
75995>>>>>>>        tWinMCHitTestInfo HitInfo
75995>>>>>>>        Handle hWnd iRet
75995>>>>>>>        Integer iVoid
75995>>>>>>>        Pointer lpPt
75995>>>>>>>        tWinPoint Pt
75995>>>>>>>        tWinPoint Pt
75995>>>>>>>        Get Window_Handle to hWnd
75996>>>>>>>        Move (AddressOf(Pt)) to lpPt
75997>>>>>>>        Move (GetCursorPos(lpPt)) to iVoid
75998>>>>>>>        Move (ScreenToClient(hWnd, lpPt)) to iVoid
75999>>>>>>>        Move Pt to HitInfo.Pt
76000>>>>>>>        Move (SizeOfType(tWinMCHitTestInfo)) to HitInfo.cbSize
76001>>>>>>>        Get WindowsMessage MCM_HITTEST 0 (AddressOf(HitInfo)) to iRet
76002>>>>>>>        Function_Return HitInfo.uHit
76003>>>>>>>    End_Function
76004>>>>>>>    
76004>>>>>>>End_Class
76005>>>>>
76005>>>>>// peMouseSelectOk choices
76005>>>>>Enum_List
76005>>>>>    Define msoClick
76005>>>>>    Define msoDblClick
76005>>>>>    Define msoNone
76005>>>>>End_Enum_List
76005>>>>>
76005>>>>>// It is expected that this class will only be used inside of ModalPanel and
76005>>>>>// will be used as a prompt object component in a framework style application.
76005>>>>>// If you wish to Use a month calendar in some other non prompt situation, 
76005>>>>>// use cMonthCalendar
76005>>>>>
76005>>>>>Class cMonthCalendarPrompt is a cMonthCalendar
76006>>>>>
76006>>>>>    Procedure Construct_Object
76008>>>>>
76008>>>>>        Forward Send Construct_Object
76010>>>>>
76010>>>>>        Property Integer peUpdateMode umPromptValue
76011>>>>>
76011>>>>>        Property Integer peMouseSelectOk msoClick
76012>>>>>        
76012>>>>>        Property Date pdSeedValue
76013>>>>>
76013>>>>>        // if multi-select, this is the end range
76013>>>>>        Property Date pdSeedValue2
76014>>>>>
76014>>>>>        Property Handle phmPromptUpdateCallback 0
76015>>>>>
76015>>>>>        Property Integer phoInvokingObject
76016>>>>>        
76016>>>>>        Property Integer peStoredUpdateMode
76017>>>>>        Property Handle  phmStoredPromptUpdateCallback
76018>>>>>        Property Boolean pbStoredWeekNumbers
76019>>>>>        Property Boolean pbStoredNoToday
76020>>>>>        Property Boolean pbStoredNoTodayCircle
76021>>>>>        Property Boolean pbStoredMultiSelect
76022>>>>>        Property Integer piStoredMaxSelectedCount
76023>>>>>        Property Integer peStoredpeMouseSelectOk
76024>>>>>
76024>>>>>        // internally set by list
76024>>>>>        // these must be set upon closing the list and can be used for manual list updates
76024>>>>>        Property Boolean pbCanceled
76025>>>>>
76025>>>>>    End_Procedure
76026>>>>>        
76026>>>>>    Procedure OnStoreDefaults
76028>>>>>        Integer iVal
76028>>>>>        Boolean bVal
76028>>>>>
76028>>>>>        Get peUpdateMode to iVal
76029>>>>>        Set peStoredUpdateMode to iVal
76030>>>>>        
76030>>>>>        Get phmPromptUpdateCallback to iVal       
76031>>>>>        Set phmStoredPromptUpdateCallback to iVal       
76032>>>>>
76032>>>>>        Get pbMultiSelect to bVal       
76033>>>>>        Set pbStoredMultiSelect to bVal       
76034>>>>>
76034>>>>>        Get pbNoToday to bVal       
76035>>>>>        Set pbStoredNoToday to bVal       
76036>>>>>
76036>>>>>        Get pbNoTodayCircle to bVal       
76037>>>>>        Set pbStoredNoTodayCircle to bVal       
76038>>>>>
76038>>>>>        Get pbWeekNumbers to bVal       
76039>>>>>        Set pbStoredWeekNumbers to bVal       
76040>>>>>
76040>>>>>        Get piMaxSelectedCount to iVal       
76041>>>>>        Set piStoredMaxSelectedCount to iVal  
76042>>>>>        
76042>>>>>        Get peMouseSelectOk to iVal       
76043>>>>>        Set peStoredpeMouseSelectOk to iVal       
76044>>>>>        
76044>>>>>    End_Procedure
76045>>>>>
76045>>>>>    Procedure OnRestoreDefaults
76047>>>>>        Integer iVal
76047>>>>>        Boolean bVal
76047>>>>>
76047>>>>>        Get peStoredUpdateMode to iVal
76048>>>>>        Set peUpdateMode to iVal
76049>>>>>        
76049>>>>>        Get phmStoredPromptUpdateCallback to iVal       
76050>>>>>        Set phmPromptUpdateCallback to iVal       
76051>>>>>
76051>>>>>        Get pbStoredMultiSelect to bVal       
76052>>>>>        Set pbMultiSelect to bVal       
76053>>>>>
76053>>>>>        Get pbStoredNoToday to bVal       
76054>>>>>        Set pbNoToday to bVal       
76055>>>>>
76055>>>>>        Get pbStoredNoTodayCircle to bVal       
76056>>>>>        Set pbNoTodayCircle to bVal       
76057>>>>>
76057>>>>>        Get pbStoredWeekNumbers to bVal       
76058>>>>>        Set pbWeekNumbers to bVal       
76059>>>>>
76059>>>>>        Get piStoredMaxSelectedCount to iVal       
76060>>>>>        Set piMaxSelectedCount to iVal       
76061>>>>>
76061>>>>>        Get peStoredpeMouseSelectOk to iVal       
76062>>>>>        Set peMouseSelectOk to iVal       
76063>>>>>
76063>>>>>    End_Procedure
76064>>>>>
76064>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
76066>>>>>        Integer eMode
76066>>>>>        Set pbCanceled to True // assume cancel unless changed
76067>>>>>        Get peUpdateMode to eMode
76068>>>>>        If (eMode<>umPromptNonInvoking) Begin
76070>>>>>            Send OnStoreDefaults
76071>>>>>        End
76071>>>>>>
76071>>>>>        Send InitializePrompt
76072>>>>>        Forward Send Add_Focus hoParent
76074>>>>>    End_Procedure
76075>>>>>        
76075>>>>>    // augment to send OnRestoreDefaults.
76075>>>>>    Procedure Release_Focus
76077>>>>>        Integer eUpdateMode
76077>>>>>        Get peUpdateMode to eUpdateMode
76078>>>>>        Forward Send Release_Focus
76080>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
76082>>>>>            Send OnRestoreDefaults
76083>>>>>        End
76083>>>>>>
76083>>>>>    End_Procedure
76084>>>>>
76084>>>>>    // This is only called in a successful close
76084>>>>>    Procedure ClosePrompt
76086>>>>>        Handle hoInvokingObject
76086>>>>>        Handle hmCallBack
76086>>>>>        Integer eUpdateMode
76086>>>>>        Date[] dDates
76087>>>>>        
76087>>>>>        Set pbCanceled to False
76088>>>>>        
76088>>>>>        Get peUpdateMode to eUpdateMode
76089>>>>>        // if non-invoking there is by definition, no move value out
76089>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
76091>>>>>            
76091>>>>>            If (eUpdateMode=umPromptValue) Begin
76093>>>>>                Send OnMoveValueOutByValue
76094>>>>>            End
76094>>>>>>
76094>>>>>            Else If (eUpdateMode=umPromptCustom) Begin
76097>>>>>                Send OnMoveValueOutByCustom
76098>>>>>            End
76098>>>>>>
76098>>>>>            Get phmPromptUpdateCallback to hmCallBack
76099>>>>>            If hmCallBack Begin
76101>>>>>                Get phoInvokingObject to hoInvokingObject
76102>>>>>                If (pbMultiSelect(Self)) Begin
76104>>>>>                    Get SelectedDateRange to dDates
76105>>>>>                    Send hmCallBack of hoInvokingObject Self dDates[0] dDates[1]
76106>>>>>                    
76106>>>>>                End
76106>>>>>>
76106>>>>>                Else Begin
76107>>>>>                    Get SelectedDate to dDates[0]
76108>>>>>                    Send hmCallBack of hoInvokingObject Self dDates[0]
76109>>>>>                End
76109>>>>>>
76109>>>>>            End
76109>>>>>>
76109>>>>>        End
76109>>>>>>
76109>>>>>
76109>>>>>        Send Close_Panel
76110>>>>>    End_Procedure
76111>>>>>
76111>>>>>    Procedure OnMoveValueOutByValue
76113>>>>>        Handle hoInvokingObject
76113>>>>>        Date dSelDate
76113>>>>>        Boolean bMulti
76113>>>>>        // we can only do an automatic move value out with
76113>>>>>        // single select. If multi-select you will probably want to
76113>>>>>        // use a callback method (hmCallBack) to update the values. 
76113>>>>>        Get pbMultiSelect to bMulti
76114>>>>>        If (not(bMulti)) Begin
76116>>>>>            Get SelectedDate to dSelDate
76117>>>>>            Get phoInvokingObject to hoInvokingObject
76118>>>>>            Set Value of hoInvokingObject to dSelDate
76119>>>>>            Set Item_Changed_State of hoInvokingObject to True
76120>>>>>        End
76120>>>>>>
76120>>>>>    End_Procedure
76121>>>>>
76121>>>>>    Procedure OnMoveValueOutByCustom
76123>>>>>    End_Procedure
76124>>>>>        
76124>>>>>    // called before the list is activated. 
76124>>>>>    Procedure InitializePrompt
76126>>>>>        Handle hoInvokingObject
76126>>>>>        Integer eUpdateMode
76126>>>>>        Boolean bMulti 
76126>>>>>        Date dValue
76126>>>>>
76126>>>>>        Get peUpdateMode to eUpdateMode
76127>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
76129>>>>>
76129>>>>>            Get Focus of Desktop to hoInvokingObject
76130>>>>>            If (hoInvokingObject<=Desktop) Begin
76132>>>>>                Error DFERR_PROGRAM "Calendar Prompt has no invoking object"
76133>>>>>>
76133>>>>>                Procedure_Return
76134>>>>>            End
76134>>>>>>
76134>>>>>
76134>>>>>            Set phoInvokingObject to hoInvokingObject
76135>>>>>            Send Prompt_Callback to hoInvokingObject Self
76136>>>>>            Get peUpdateMode to eUpdateMode
76137>>>>>        End
76137>>>>>>
76137>>>>>
76137>>>>>        Get pdSeedValue to dValue
76138>>>>>        Get pbMultiSelect to bMulti
76139>>>>>        If (not(bMulti) and eUpdateMode=umPromptValue and dValue=0) Begin
76141>>>>>            Get Value of hoInvokingObject to dValue
76142>>>>>            Set pdSeedValue to dValue
76143>>>>>        End
76143>>>>>>
76143>>>>>        Send OnSeedData
76144>>>>>        Set pdSeedValue to 0
76145>>>>>        Set pdSeedValue2 to 0
76146>>>>>    End_Procedure
76147>>>>>    
76147>>>>>    Procedure OnSeedData 
76149>>>>>        Boolean bMulti
76149>>>>>        Date dValue dValue2
76149>>>>>        Integer iMax iRange
76149>>>>>        DateTime dt1 dt2
76149>>>>>        Get pbMultiSelect to bMulti
76150>>>>>        Get pdSeedValue to dValue
76151>>>>>        If (not(bMulti)) Begin
76153>>>>>            // if no date, use current date
76153>>>>>            If (dValue=0) Begin
76155>>>>>                Move (CurrentDateTime()) to dValue
76156>>>>>            End
76156>>>>>>
76156>>>>>            Send SetSelectedDate dValue    
76157>>>>>        End
76157>>>>>>
76157>>>>>        Else Begin
76158>>>>>            Get pdSeedValue2 to dValue2 
76159>>>>>            // if no dates, use current date
76159>>>>>            If (dValue=0 and dValue2=0) Begin
76161>>>>>                Move (CurrentDateTime()) to dValue
76162>>>>>            End
76162>>>>>>
76162>>>>>            // if only one date, make that the range
76162>>>>>            If (dValue=0) Begin
76164>>>>>                Move dValue2 to dValue
76165>>>>>            End
76165>>>>>>
76165>>>>>            Else If (dValue2=0) Begin
76168>>>>>                Move dValue to dValue2
76169>>>>>            End
76169>>>>>>
76169>>>>>            
76169>>>>>            // test for valid range
76169>>>>>            Get piMaxSelectedCount to iMax
76170>>>>>            Move dValue to dt1
76171>>>>>            Move dValue2 to dt2
76172>>>>>            Move (SpanTotalDays(dt1 - dt2)) to iRange
76173>>>>>            If (iRange>iMax) Begin
76175>>>>>                Error DFERR_OPERATOR (SFormat(C_$DateRangeExceeded,iMax))
76176>>>>>>
76176>>>>>                Move dValue to dValue2
76177>>>>>            End
76177>>>>>>
76177>>>>>            
76177>>>>>            Send SetSelectedDateRange dValue dValue2
76178>>>>>        End
76178>>>>>>
76178>>>>>    End_Procedure
76179>>>>>
76179>>>>>    Procedure OnDoubleClick
76181>>>>>        Integer eSelectOn
76181>>>>>        Get peMouseSelectOk to eSelectOn
76182>>>>>        If (eSelectOn=msoDblClick) Begin
76184>>>>>            Send Ok
76185>>>>>        End
76185>>>>>>
76185>>>>>    End_Procedure
76186>>>>>    
76186>>>>>    Procedure OnClick
76188>>>>>        Integer eSelectOn
76188>>>>>        Get peMouseSelectOk to eSelectOn
76189>>>>>        If (eSelectOn=msoClick) Begin
76191>>>>>            Send Ok
76192>>>>>        End
76192>>>>>>
76192>>>>>    End_Procedure
76193>>>>>
76193>>>>>    Procedure Ok Returns Integer
76195>>>>>        Send ClosePrompt
76196>>>>>    End_Procedure
76197>>>>>
76197>>>>>    Procedure Cancel Returns Integer
76199>>>>>        Send Close_Panel
76200>>>>>    End_Procedure
76201>>>>>        
76201>>>>>End_Class
76202>>>>>
76202>>>>>
76202>>>Use Dfclient.pkg
76202>>>
76202>>>Cd_Popup_Object oMonthCalendarPrompt is a ModalPanel
76220>>>>
76220>>>    Set Location to 10 10
76221>>>    Set Size to 145 145
76222>>>    // resizable
76222>>>    Set Border_Style to Border_Thick
76223>>>
76223>>>    Set Label to C_$DateSelector
76224>>>
76224>>>    Set piMinSize to 0 0 // set this dynamically // 145 145
76225>>>    Set piMaxSize to 310 460
76226>>>
76226>>>    // tells us if this been activated and sized yet
76226>>>    Property Boolean pbSizeInited False
76228>>>        
76228>>>    Object oCalendar is a cMonthCalendarPrompt
76230>>>        Set Size to 120 135 // not real size, will be assigned
76231>>>        Set Location to 5 5
76232>>>        Set Border_Style to Border_None
76233>>>    End_Object
76234>>>
76234>>>    Object oOKButton is a Button
76236>>>        Set Label to C_$OK
76237>>>        Set Default_State to True
76238>>>        Set Location to 129 34
76239>>>        Set peAnchors to anBottomRight
76240>>>        
76240>>>        Procedure OnClick
76243>>>            Send Ok of oCalendar
76244>>>        End_Procedure
76245>>>    End_Object
76246>>>
76246>>>    Object oCancelButton is a Button
76248>>>        Set Label to C_$Cancel
76249>>>        Set Location to 129 89
76250>>>        Set peAnchors to anBottomRight
76251>>>        
76251>>>        Procedure OnClick
76254>>>            Send Cancel of oCalendar
76255>>>        End_Procedure
76256>>>    End_Object
76257>>>
76257>>>    Procedure OnResize 
76260>>>        Integer iSize iHeight iWidth iMinSize
76260>>>        Boolean bInited
76260>>>
76260>>>        Get piMinHeight of oCalendar to iHeight
76261>>>        // when 0, the control has not yet been created. Nothing to do.
76261>>>        If (iHeight=0) Begin
76263>>>            Procedure_Return
76264>>>        End
76264>>>>
76264>>>
76264>>>        Get pbSizeInited to bInited
76265>>>        
76265>>>        Get piMinWidth of oCalendar to iWidth
76266>>>        Get piMinSize to iMinSize
76267>>>        // Minumum size of panel - add 1 to each to each for wiggle room
76267>>>        Move (iHeight+25+1) to iHeight
76268>>>        Move (iWidth+10+1) to iWidth
76269>>>         
76269>>>        Set piMinSize to iHeight iWidth
76270>>>
76270>>>        If (not(bInited))  Begin
76272>>>            Set Size to iHeight iWidth
76273>>>            Set pbSizeInited to True
76274>>>        End
76274>>>>
76274>>>        Else Begin
76275>>>            Send Adjust_Logicals
76276>>>            Get Size to iSize
76277>>>            If (Hi(iSize)<iHeight or Low(iSize)<iWidth) Begin
76279>>>                Set Size to (iHeight max Hi(iSize)) (iWidth max Low(iSize))
76280>>>                Get Size to iSize
76281>>>            End
76281>>>>
76281>>>            Set Size of oCalendar to (Hi(iSize) - 25) (Low(iSize) - 10)
76282>>>        End
76282>>>>
76282>>>        
76282>>>    End_Procedure
76283>>>    
76283>>>    Procedure Add_Focus Handle hoParent Returns Integer
76286>>>        Forward Send Add_Focus hoParent
76288>>>        Send OnResize
76289>>>    End_Procedure
76290>>>
76290>>>    On_Key kCancel Send KeyAction to oCancelButton
76291>>>
76291>>>Cd_End_Object
76293>>>>
76293>
76293>Object oHtmlHelp is a cHtmlHelp
76295>End_Object
76296>
76296>Object oApplication is a cApplication
76298>    Set peHelpType to htHtmlHelp
76299>End_Object
76300>
76300>Object oToolTipController is a cToolTipController
76302>    Move Self to ghoToolTipController
76303>End_Object
76304>
76304>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\oEditContextMenu.pkg)
76304>>>Use cCJStandardMenuItemClasses.pkg
76304>>>
76304>>>Object oEditContextMenu is a cCJContextMenu
76306>>>    
76306>>>    Move Self to Default_Form_Floating_Menu_ID
76307>>>    
76307>>>    Object oUndoMenuItem is a cCJUndoMenuItem
76309>>>    End_Object
76310>>>    
76310>>>    Object oCutMenuItem is a cCJCutMenuItem
76312>>>        Set pbControlBeginGroup to True
76313>>>    End_Object
76314>>>    
76314>>>    Object oCopyMenuItem is a cCJCopyMenuItem
76316>>>    End_Object
76317>>>
76317>>>    Object oPasteMenuItem is a cCJPasteMenuItem
76319>>>    End_Object
76320>>>
76320>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
76322>>>    End_Object
76323>>>
76323>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
76325>>>        Set pbControlBeginGroup to True
76326>>>    End_Object
76327>>>
76327>>>End_Object
76328>>>
76328>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\oDEOEditContextMenu17.pkg)
76328>>>Use Windows.pkg
76328>>>Use cCJStandardMenuItemClasses.pkg
76328>>>Use cCJDeoMenuItemClasses.pkg
76328>>>
76328>>>
76328>>>Object oDEOEditContextMenu17 is a cCJContextMenu
76330>>>    
76330>>>    Move Self to Default_dbFloating_Menu_ID
76331>>>    
76331>>>    Object oUndoMenuItem is a cCJUndoMenuItem
76333>>>    End_Object
76334>>>    
76334>>>    Object oCutMenuItem is a cCJCutMenuItem
76336>>>        Set pbControlBeginGroup to True
76337>>>    End_Object
76338>>>    
76338>>>    Object oCopyMenuItem is a cCJCopyMenuItem
76340>>>    End_Object
76341>>>
76341>>>    Object oPasteMenuItem is a cCJPasteMenuItem
76343>>>    End_Object
76344>>>
76344>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
76346>>>    End_Object
76347>>>
76347>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
76349>>>        Set pbControlBeginGroup to True
76350>>>    End_Object
76351>>>
76351>>>    Object oPromptMenuItem is a cCJPromptMenuItem
76353>>>        Set pbControlBeginGroup to True
76354>>>    End_Object
76355>>>
76355>>>    Object oFindNextMenu is a cCJFindNextMenuItem
76357>>>        Set pbControlBeginGroup to True
76358>>>    End_Object
76359>>>
76359>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
76361>>>    End_Object
76362>>>
76362>>>    Object oClearMenuItem is a cCJClearMenuItem
76364>>>        Set pbControlBeginGroup to True
76365>>>    End_Object
76366>>>
76366>>>    Object oClearAllMenu is a cCJClearAllMenuItem
76368>>>    End_Object
76369>>>
76369>>>    Object oSaveMenu is a cCJSaveMenuItem
76371>>>    End_Object
76372>>>    
76372>>>    Object oDeleteMenu is a cCJDeleteMenuItem
76374>>>    End_Object
76375>>>
76375>>>    Object oRememberitem is a cCJRememberFieldMenuItem
76377>>>        Set pbControlBeginGroup to True
76378>>>    End_Object
76379>>>
76379>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
76381>>>    End_Object
76382>>>
76382>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
76384>>>    End_Object
76385>>>
76385>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
76387>>>    End_Object
76388>>>
76388>>>End_Object
76389>
76389>Object oMain is a Panel
76391>    Set Label to "Mi Proyecto"
76392>    Set Location to 4 3
76393>    Set Size to 300 539
76394>
76394>    Object oCommandBarSystem is a cCJCommandBarSystem
76396>        Set pbTimerUpdate to True
76397>
76397>        Procedure OnCreateCommandBars
76400>            Handle hoOptions
76400>            Get OptionsObject to hoOptions
76401>            Forward Send OnCreateCommandBars
76403>        End_Procedure
76404>
76404>        Object oMenuBar is a cCJMenuBar
76406>
76406>            Object oFileMenu is a cCJMenuItem
76408>                Set peControlType to xtpControlPopup          
76409>                Set psCaption   to "Archivo"    // &F   <--------------------------
76410>                Set psDescription to "Buscar, Grabar, Borrar, limpiar informacin o salir de esta aplicacin."
76411>                Set psCategory to "Mens"
76412>
76412>                Object oClearMenuItem is a cCJClearMenuItem
76414>                    Set pbAddToDesignerMenu to True
76415>                End_Object
76416>
76416>                Object oClearAllMenu is a cCJClearAllMenuItem
76418>                    Set pbAddToDesignerMenu to True
76419>                End_Object
76420>
76420>                Object oPromptMenuItem is a cCJPromptMenuItem
76422>                    Set pbAddToDesignerMenu to True
76423>                    Set pbControlBeginGroup to True
76424>                End_Object
76425>
76425>                Object oFindMenuItem is a cCJFindMenuItem
76427>                    Set pbAddToDesignerMenu to True
76428>                    Set pbControlBeginGroup to True
76429>                End_Object
76430>
76430>                Object oFindNextMenu is a cCJFindNextMenuItem
76432>                    Set pbAddToDesignerMenu to True
76433>                End_Object
76434>
76434>                Object oFindPreviousMenu is a cCJFindPreviousMenuItem
76436>                    Set pbAddToDesignerMenu to True
76437>                End_Object
76438>
76438>                Object oFindFirstMenu is a cCJFindFirstMenuItem
76440>                    Set pbAddToDesignerMenu to True
76441>                End_Object
76442>
76442>                Object oFindLastMenu is a cCJFindLastMenuItem
76444>                    Set pbAddToDesignerMenu to True
76445>                End_Object
76446>
76446>                Object oSaveMenuItem is a cCJSaveMenuItem
76448>                    Set pbAddToDesignerMenu to True
76449>                    Set pbControlBeginGroup to True
76450>                End_Object
76451>
76451>                Object oDeleteMenuItem is a cCJDeleteMenuItem
76453>                    Set pbAddToDesignerMenu to True
76454>                End_Object
76455>
76455>                Object oExitMenu is a cCJExitMenuItem
76457>                    Set pbControlBeginGroup to True
76458>                End_Object
76459>
76459>            End_Object
76460>
76460>            Object oViewMenu is a cCJMenuItem
76462>                Set peControlType to xtpControlPopup
76463>                Set psCaption to "&Vistas"
76464>                Set psToolTip to "Vistas"
76465>               Set psDescription to "Vistas disponibles"
76466>
76466>               Object oRegistrodeEmpleadoMenuItem is a cCJMenuItem
76468>                   Set psCaption to "Registro de Empleado"
76469>                   Set psTooltip to "Registro de Empleado"
76470>               
76470>                   Procedure OnExecute Variant vCommandBarControl
76473>                       Handle hoClient
76473>                       Get Client_Id to hoClient
76474>                       Send Activate_RegistroEmpleado of hoClient
76475>                   End_Procedure
76476>               End_Object
76477>
76477>               Object oRegistrodeMarcajesMenuItem is a cCJMenuItem
76479>                   Set psCaption to "Registro de Marcajes"
76480>                   Set psTooltip to "Registro de Marcajes"
76481>               
76481>                   Procedure OnExecute Variant vCommandBarControl
76484>                       Handle hoClient
76484>                       Get Client_Id to hoClient
76485>                       Send Activate_RegistroMarcajes of hoClient
76486>                   End_Procedure
76487>               End_Object
76488>            End_Object
76489>            
76489>            Object oReportMenu is a cCJMenuItem
76491>                Set peControlType to xtpControlPopup
76492>                Set psCaption to "&Informes"
76493>                Set psToolTip to "Informes"
76494>                Set psDescription to "Informes disponibles"
76495>
76495>                Object oMarcajesMenuItem is a cCJMenuItem
76497>                    Set psCaption to "Marcajes"
76498>                    Set psTooltip to "Marcajes"
76499>                
76499>                    Procedure OnExecute Variant vCommandBarControl
76502>                        Handle hoClient
76502>                        Get Client_Id to hoClient
76503>                        Send Activate_Marcajes of hoClient
76504>                    End_Procedure
76505>                End_Object
76506>
76506>                Object oReportedeEmpleadoMenuItem is a cCJMenuItem
76508>                    Set psCaption to "Reporte de Empleado"
76509>                    Set psTooltip to "Reporte de Empleado"
76510>                
76510>                    Procedure OnExecute Variant vCommandBarControl
76513>                        Handle hoClient
76513>                        Get Client_Id to hoClient
76514>                        Send Activate_ReporteEmpleado of hoClient
76515>                    End_Procedure
76516>                End_Object
76517>            End_Object
76518>
76518>            Object oNavigateMenu is a cCJMenuItem
76520>                Set peControlType to xtpControlPopup      
76521>                Set psCaption to "&Navegar"    
76522>                Set psTooltip to "Navegar"    
76523>                Set psDescription to "Desplazarse a diferentes areas de la aplicacin"
76524>
76524>                Object oNextAreaMenu is a cCJNextAreaMenu
76526>                End_Object
76527>
76527>                Object oPriorAreaMenu is a cCJPriorAreaMenu
76529>                End_Object
76530>
76530>                Object oNextViewMenu is a cCJNextViewMenu
76532>                End_Object
76533>
76533>                Object oPriorViewMenu is a cCJPriorViewMenu
76535>                End_Object
76536>
76536>                Object oPromptMenu is a cCJPromptMenuItem
76538>                    Set pbControlBeginGroup to True
76539>                End_Object
76540>
76540>                Object oZoomMenu is a cCJZoomMenuItem
76542>                End_Object
76543>
76543>            End_Object
76544>
76544>            Object oWindowMenu is a cCJMDIWindowsMenuItem
76546>                Set peControlType to xtpControlPopup
76547>                Set psCaption to "Ventana"      // &W <---------------
76548>                Set psToolTip to "Ventana"
76549>                Set psDescription to "Muestre vistas actuales y fije otras opciones de visualizacin."
76550>
76550>                // These are the static windows items. More will be created in onInitPopup 
76550>                Object oDisplayOptionsMenu is a cCJMenuItem
76552>                    Set peControlType to xtpControlPopup          
76553>                    Set psCaption to "Opciones de visualizacin"  // &D <--------------
76554>                    Set psToolTip to "Opciones de visualizacin"
76555>                    Set psDescription to "Fije opciones de visualizacin"
76556>
76556>                    Object oStatusbarMenu is a cCJStatusbarMenuItem
76558>                    End_Object
76559>
76559>                    Object oAutoArrangeIconsMenu is a cCJAutoArrangeIconsMenuItem
76561>                    End_Object
76562>
76562>                    Object oRestoreMenusMenu is a cCJRestoreMenusMenuItem
76564>                        Set pbControlBeginGroup to True
76565>                    End_Object
76566>
76566>                End_Object
76567>
76567>                Object oCascadeMenu is a cCJCascadeMenuItem
76569>                    Set pbControlBeginGroup to True
76570>                End_Object
76571>
76571>                Object oHorizTile is a cCJTileHorizontally
76573>                End_Object
76574>
76574>                Object oVertTile is a cCJTileVertically
76576>                End_Object
76577>
76577>                Object oMinimizeMenuItem is a cCJMinimizeWindowsMenuItem
76579>                    Set pbControlBeginGroup to True
76580>                End_Object
76581>
76581>                Object oRestoreMenuItem is a cCJRestoreWindowsMenuItem
76583>                End_Object
76584>
76584>                Object oArrangeIconsMenuItem is a cCJAutoArrangeIconsMenuItem
76586>                    Set pbControlBeginGroup to True
76587>                End_Object
76588>
76588>            End_Object
76589>
76589>            Object oHelpMenu is a cCJMenuItem
76591>                Set peControlType to xtpControlPopup    
76592>                Set psCaption to "&Ayuda"   // &H    <----------------------
76593>                Set psDescription to "Informacin para aprender y para usar esta aplicacin VDF"
76594>                Set psToolTip to "Ayuda"
76595>
76595>                Object oHelpMenuItem is a cCJHelpMenuItem 
76597>                End_Object
76598>
76598>                Object oAboutMenuItem is a cCJAboutMenuItem
76600>                End_Object
76601>
76601>            End_Object
76602>
76602>        End_Object
76603>
76603>        Object oFindToolBar is a cCJToolbar
76605>            Set psTitle to "Barra de herramientas de bsqueda"
76606>
76606>            Object oFindFirstTool is a cCJFindFirstMenuItem
76608>            End_Object
76609>
76609>            Object oFindPreviousTool is a cCJFindPreviousMenuItem
76611>            End_Object
76612>
76612>            Object oFindMenuTool is a cCJFindMenuItem
76614>            End_Object
76615>
76615>            Object oFindNextTool is a cCJFindNextMenuItem
76617>            End_Object
76618>
76618>            Object oFindLastTool is a cCJFindLastMenuItem
76620>            End_Object
76621>
76621>            Object oPromptToolItem is a cCJPromptMenuItem
76623>                Set pbControlBeginGroup to True
76624>            End_Object
76625>
76625>        End_Object
76626>
76626>        Object oFileToolBar is a cCJToolbar
76628>            Set psTitle to "Barra de herramientas de introduccin de datos"
76629>
76629>            Object oClearToolItem is a cCJClearMenuItem
76631>                Set peControlStyle to xtpButtonIconAndCaption
76632>            End_Object
76633>
76633>            Object oClearAllToolItem2 is a cCJClearAllMenuItem
76635>                Set peControlStyle to xtpButtonIconAndCaption
76636>            End_Object
76637>
76637>            Object oSaveToolItem is a cCJSaveMenuItem
76639>                Set peControlStyle to xtpButtonIconAndCaption
76640>                Set pbControlBeginGroup to True
76641>            End_Object
76642>
76642>            Object oDeleteToolItem is a cCJDeleteMenuItem
76644>                Set peControlStyle to xtpButtonIconAndCaption
76645>            End_Object
76646>
76646>        End_Object
76647>
76647>        Object oEditToolBar is a cCJToolbar
76649>            Set psTitle to "Barra de herramientas de edicin"
76650>
76650>            Object oCutToolbarItem is a cCJCutMenuItem
76652>            End_Object
76653>
76653>            Object oCopyToolbarItem is a cCJCopyMenuItem
76655>            End_Object
76656>
76656>            Object oPasteToolbarItem is a cCJPasteMenuItem
76658>            End_Object
76659>
76659>            Object oDeleteEditToolbarItem is a cCJDeleteEditMenuItem
76661>                Set pbControlBeginGroup to True
76662>            End_Object
76663>
76663>        End_Object
76664>
76664>        Object oRememberToolbar is a cCJToolbar
76666>            Set psTitle to C_$Remember
76667>
76667>            Object oRememberItems is a cCJMenuItem
76669>
76669>                Set peControlType to xtpControlPopup
76670>                Set peControlStyle to xtpButtonCaption
76671>                Set psCaption to C_$Remember
76672>                
76672>                Object oMenuItem is a cCJRememberFieldMenuItem
76674>                    Set peControlStyle to xtpButtonIconAndCaption
76675>                End_Object
76676>                
76676>                Object oMenuItem is a cCJRememberLastFieldMenuItem
76678>                    Set peControlStyle to xtpButtonIconAndCaption
76679>                End_Object
76680>                
76680>                Object oMenuItem is a cCJUnRememberFieldMenuItem
76682>                    Set peControlStyle to xtpButtonIconAndCaption
76683>                End_Object
76684>                
76684>                Object oMenuItem is a cCJUnRememberFieldAllMenuItem
76686>                    Set peControlStyle to xtpButtonIconAndCaption
76687>                End_Object
76688>
76688>            End_Object
76689>            
76689>        End_Object
76690>        
76690>        Object oStatusBar is a cCJStatusBar
76692>
76692>            Object oStatusPane1 is a cCJStatusBarPane
76694>                Set piID to sbpIDIdlePane
76695>                Set pbStyleStretch to True
76696>            End_Object
76697>
76697>            Object oStatusPane2 is a cCJStatusBarPane
76699>                Set phoViewPane to Self
76700>                Set pbStyleStretch to True
76701>            End_Object
76702>
76702>        End_Object
76703>
76703>    End_Object
76704>
76704>    Object oClientArea is a ClientArea
76706>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\StdAbout.pkg)
76706>>>//************************************************************************
76706>>>// Confidential Trade Secret.
76706>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
76706>>>// as an unpublished work.  All rights reserved.
76706>>>// DataFlex is a registered trademark of Data Access Corporation.
76706>>>//
76706>>>//************************************************************************
76706>>>//************************************************************************
76706>>>//
76706>>>// $File name  : StdAbout.pkg
76706>>>// $File title : Standard about object package for VDF
76706>>>// Notice      :
76706>>>// $Author(s)  : John Tuohy
76706>>>//
76706>>>// $Rev History
76706>>>//
76706>>>// JT 06/27/97   File created
76706>>>//************************************************************************
76706>>>
76706>>>// This provides a quick and simple way to create an about package for a program.
76706>>>// You need to create a message inside you client area called Activate_About.
76706>>>// Within this message you should send the message DoAbout passing needed
76706>>>// string information.
76706>>>//
76706>>>//       Procedure Activate_About
76706>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
76706>>>//       End_Procedure
76706>>>//    where: sTitle =     Name of application. If none provided, uses caption
76706>>>//                        bar title
76706>>>//           sVersion   = Version Line. If none provided, will be blank
76706>>>//           sCopyRight = Copyright Line. If none provided, will be blank
76706>>>//           sAuthor    = Author name, blank if none provided
76706>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
76706>>>//                        is used.
76706>>>// It is expected that you will place this in your own object package. For
76706>>>// example an order about package may look like this:
76706>>>//
76706>>>//   // OrderAbout.pkg
76706>>>//   Use StdAbout.pkg
76706>>>//   Procedure Activate_About
76706>>>//      String sTitle sCopyright sVersion sAuthor
76706>>>//      Move "My Order Entry System" to sTitle
76706>>>//      Move "Version 2.1" to sVersion
76706>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
76706>>>//      Move "John Smith"  to sAuthor
76706>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
76706>>>//   end_procedure
76706>>>//   // end of file.
76706>>>
76706>>>Use DfAbout.pkg
Including file: Dfabout.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\Dfabout.pkg)
76706>>>>>//************************************************************************
76706>>>>>// Confidential Trade Secret.
76706>>>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
76706>>>>>// as an unpublished work.  All rights reserved.
76706>>>>>// DataFlex Is A registered trademark Of Data Access Corporation.
76706>>>>>//
76706>>>>>//************************************************************************
76706>>>>>//************************************************************************
76706>>>>>//
76706>>>>>// $File name  : DfAbout.pkg
76706>>>>>// $File title : About class support
76706>>>>>// Notice      :
76706>>>>>// $Author(s)  : Vincent Oorsprong, Ken Ross
76706>>>>>//
76706>>>>>// $Rev History
76706>>>>>//
76706>>>>>// VOO 02/22/2012 Replaced obsolete code, improved Network_User_Name by asking
76706>>>>>//                Windows for the size first. 
76706>>>>>// VOO 07/25/2003 Removed OnResize procedure for sysinfo dialog. Replaced logic
76706>>>>>//                with anchor technique. Removed unnessary property in the
76706>>>>>//                sysinfo dialog. Changed the size Of the about & sysinfo dialog
76706>>>>>//                object To better look in Windows XP. Repositioned the close
76706>>>>>//                button in the sysinfo dialog To line up with the display area
76706>>>>>//                Replaced obsolete code and techniques. Removed dead code.
76706>>>>>// JJT 10/23/2001 removed all ghoworkspace support. Uses app object or nothing
76706>>>>>// SWB 07/19/01   Added support Of the Application object in preference to
76706>>>>>//                the global Workspace object, if it is present
76706>>>>>// JJT 11/05/98   Added version information
76706>>>>>// VOO 29/10/98   Replaced the GetFreeSystemResources for the Win32 variant
76706>>>>>// JJT 7/31/97    Registered Enumerate Workspace so dfabout can exist without
76706>>>>>//                workspace package.
76706>>>>>// JJT 6/27/97    Turned the sysinfo objects into classes so the AboutDialog
76706>>>>>//                class can create this object.
76706>>>>>//                Cleaned up the interface (used correct classes and messages)
76706>>>>>//                Added workspace reporting support To sys-info.
76706>>>>>//                Turned off wrapping in the sys-info editor.
76706>>>>>// KR  ??/??/96   File created
76706>>>>>//************************************************************************
76706>>>>>Use LanguageText.pkg
76706>>>>>Use Windows.pkg
76706>>>>>Use DFbitmap.pkg
76706>>>>>Use GlobalFunctionsProcedures.pkg
76706>>>>>Use cTextEdit.pkg
76706>>>>>
76706>>>>>Use cli.pkg
Including file: cli.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cli.pkg)
76706>>>>>>>//*****************************************************************************
76706>>>>>>>//*** CLI.PKG                                                               ***
76706>>>>>>>//***                                                                       ***
76706>>>>>>>//*** Author: Ben Weijers                                                   ***
76706>>>>>>>//***         Data Access Nederland                                         ***
76706>>>>>>>//***         10 September 1998                                             ***
76706>>>>>>>//***                                                                       ***
76706>>>>>>>//*** Purpose:                                                              ***
76706>>>>>>>//***   CLI specific functionality. There are several connectivity kits     ***
76706>>>>>>>//***   based on  SQL/92 CLI. Those are:                                    ***
76706>>>>>>>//***    - ODBC_DRV  The Data Access CK for ODBC                            ***
76706>>>>>>>//***    - DB2_DRV   The Data Access CK for DB2                             ***
76706>>>>>>>//***    - MSSQLDRV  The Data Access CK for Microsoft SQL Server            ***
76706>>>>>>>//***                                                                       ***
76706>>>>>>>//***   This package defines the common functionality for all CLI based     ***
76706>>>>>>>//***   drivers.                                                            ***
76706>>>>>>>//***                                                                       ***
76706>>>>>>>//***   Updated:  May 23rd 2008 (Current CK build: 5.0.0.53 )               ***
76706>>>>>>>//***             Added NULLABLE and DEFAULT attributes for DATETIME type   ***
76706>>>>>>>//***   Updated:  Apr  6th 2009 (Current CK build: 5.0.0.61 )               ***
76706>>>>>>>//***             Added DF_DRIVER_MATCH_CLIENT_SERVER_VERSION attribute     ***
76706>>>>>>>//***                   DF_DRIVER_SQLSERVER_CLIENT_VERSION    attribute     ***
76706>>>>>>>//***   Updated:  Mar 30th 2012 (Current CK build: 5.1.0.93 )               ***
76706>>>>>>>//***             Added SQLSERVER2012CLIENT return value for                ***
76706>>>>>>>//***             DF_DRIVER_SQLSERVER_CLIENT_VERSION attribute              ***
76706>>>>>>>//***   Updated:  June 4th 2012 (Current CK build: 5.1.0.96)                ***
76706>>>>>>>//***             Moved SQL Server client constants from cli.pkg to         ***
76706>>>>>>>//***             mssqldrv.pkg                                              ***
76706>>>>>>>//***   Updated:  april 23, 2013 (Current CK build: 6.0.0.4)                ***
76706>>>>>>>//***             Added type mappings attributes                            ***
76706>>>>>>>//***   Updated:  october 11, 2013 (Current CK build: 6.0.0.18)             ***
76706>>>>>>>//***             Added DF_FILE_SQL_FILTER_EQ attribute                     ***
76706>>>>>>>//*****************************************************************************
76706>>>>>>>
76706>>>>>>>//*** We are not using ifndef below because that is not supported in Character Mode
76706>>>>>>>//*** Driver attributes
76706>>>>>>>
76706>>>>>>>
76706>>>>>>>
76706>>>>>>>
76706>>>>>>>
76706>>>>>>>
76706>>>>>>>
76706>>>>>>>
76706>>>>>>>
76706>>>>>>>//------------------------------------------------------------
76706>>>>>>>
76706>>>>>>>
76706>>>>>>>//-------------------------------------
76706>>>>>>>
76706>>>>>>>
76706>>>>>>>
76706>>>>>>>//*** Replacement for logical column number that indicates all columns
76706>>>>>>>
76706>>>>>>>//*** Possible DF_FILE_GENERATE_RECORD_ID_METHOD values
76706>>>>>>>
76706>>>>>>>//*** Possible DF_FIELD_READ_ONLY values
76706>>>>>>>
76706>>>>>>>
76706>>>>>>>//*** Possible DF_DRIVER_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA values
76706>>>>>>>// #Replace MAP_DF_TO_SQL_TYPE_CK5        1       
76706>>>>>>>// #Replace MAP_DF_TO_SQL_TYPE_CK6        2   
76706>>>>>>>
76706>>>>>>>
76706>>>>>>>// Moved to Mssqldrv.pkg
76706>>>>>>>//*** Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
76706>>>>>>>//#REPLACE SQLSERVERUNKNOWNCLIENT  0
76706>>>>>>>//#REPLACE SQLSERVER2000CLIENT     8          //   "SQL Server"
76706>>>>>>>//#REPLACE SQLSERVER2005CLIENT     9          //   "SQL Native Client"
76706>>>>>>>//#REPLACE SQLSERVER2008CLIENT    10          //   "SQL Server Native Client 10.0"
76706>>>>>>>//#Replace SQLSERVER2012CLIENT    11          //   "SQL Server Native Client 11.0"
76706>>>>>>>
76706>>>>>>>//*** Possible SQL Column type values
76706>>>>>>>Define SQL_UNKNOWN_TYPE   For    0
76706>>>>>>>Define SQL_CHAR           For    1
76706>>>>>>>Define SQL_NUMERIC        For    2
76706>>>>>>>Define SQL_DECIMAL        For    3
76706>>>>>>>Define SQL_INTEGER        For    4
76706>>>>>>>Define SQL_SMALLINT       For    5
76706>>>>>>>Define SQL_FLOAT          For    6
76706>>>>>>>Define SQL_REAL           For    7
76706>>>>>>>Define SQL_DOUBLE         For    8
76706>>>>>>>Define SQL_DATETIME       For    9
76706>>>>>>>Define SQL_VARCHAR        For   12
76706>>>>>>>Define SQL_TYPE_DATE      For   91
76706>>>>>>>Define SQL_TYPE_TIME      For   92
76706>>>>>>>Define SQL_TYPE_TIMESTAMP for   93
76706>>>>>>>// Moved to mssqldrv.pkg
76706>>>>>>>//Define SQL_TYPE_TIMESTAMP2 for   (-200) //SQL server datetime2 type */
76706>>>>>>>
76706>>>>>>>
76706>>>>>>>Define SQL_DATE           For    9
76706>>>>>>>Define SQL_INTERVAL       For   10
76706>>>>>>>Define SQL_TIME           For   10
76706>>>>>>>Define SQL_TIMESTAMP      For   11
76706>>>>>>>Define SQL_LONGVARCHAR    For  (-1)
76706>>>>>>>Define SQL_BINARY         For  (-2)
76706>>>>>>>Define SQL_VARBINARY      For  (-3)
76706>>>>>>>Define SQL_LONGVARBINARY  For  (-4)
76706>>>>>>>Define SQL_BIGINT         For  (-5)
76706>>>>>>>Define SQL_TINYINT        For  (-6)
76706>>>>>>>Define SQL_BIT            For  (-7)
76706>>>>>>>Define SQL_WCHAR          For  (-8)
76706>>>>>>>Define SQL_WVARCHAR       For  (-9)
76706>>>>>>>Define SQL_WLONGVARCHAR   For (-10)
76706>>>>>>>Define SQL_GUID           For (-11)
76706>>>>>>>
76706>>>>>>>//*** Driver level attributes
76706>>>>>>>
76706>>>>>>>
76706>>>>>>>//*** Error number constants
76706>>>>>>>
76706>>>>>>>
76706>>>>>>>//*** Call driver function identifiers
76706>>>>>>>
76706>>>>>>>
76706>>>>>>>//*** Init data source types
76706>>>>>>>
76706>>>>>>>
76706>>>>>>>//*** Dummy strings used in the commands
76706>>>>>>>    String  CLI$StrDummy 255
76706>>>>>>>    Integer CLI$IntDummy
76706>>>>>>>
76706>>>>>>>
76706>>>>>>>//*****************************************************************************
76706>>>>>>>//*** CLI_SetConstraint <FileNum> <NewState>                                ***
76706>>>>>>>//***                                                                       ***
76706>>>>>>>//***   Setup a constraint for a file.                                      ***
76706>>>>>>>//*****************************************************************************
76706>>>>>>>
76706>>>>>>>
76706>>>>>>>
76706>>>>>>>
76706>>>>>>>//*****************************************************************************
76706>>>>>>>//*** CLI_Set_Driver_Atrtribute / CLI_Get_Driver_Attribute                  ***
76706>>>>>>>//***                                                                       ***
76706>>>>>>>//*** Set or get an attribute at driver level. These attributes, when set,  ***
76706>>>>>>>//*** will be set for the remainder of the session or until set again. To   ***
76706>>>>>>>//*** permanently set driver level attributes change the driver             ***
76706>>>>>>>//*** configuration file.                                                   ***
76706>>>>>>>//*****************************************************************************
76706>>>>>>>
76706>>>>>>>
76706>>>>>>>
76706>>>>>>>
76706>>>>>>>
76706>>>>>>>
76706>>>>>>>
76706>>>>>>>//*****************************************************************************
76706>>>>>>>//*** Class  : cCLIHandler                                                  ***
76706>>>>>>>//*** Purpose: An instance of this class can be used as a broker object to  ***
76706>>>>>>>//***          call several CLI releated methods.                           ***
76706>>>>>>>//*****************************************************************************
76706>>>>>>>
76706>>>>>>>Class cCLIHandler Is An Array
76707>>>>>>>
76707>>>>>>>    Procedure Construct_Object Integer iImage
76709>>>>>>>        Forward Send Construct_object iImage
76711>>>>>>>
76711>>>>>>>        Property String  psDriverID       Public ""
76712>>>>>>>    End_Procedure // Construct_Object
76713>>>>>>>
76713>>>>>>>
76713>>>>>>>
76713>>>>>>>    //***
76713>>>>>>>    //*** Fucntion: CKRevsion
76713>>>>>>>    //*** Purpose : The revsion of a CLI Connectivity Kit
76713>>>>>>>    //***
76713>>>>>>>
76713>>>>>>>    Function CKRevision Returns String
76715>>>>>>>        Local String  sDriverID
76715>>>>>>>        Local String  sRevision
76715>>>>>>>        Local String  sVoid
76715>>>>>>>        Local Integer iRetval
76715>>>>>>>
76715>>>>>>>        Get psDriverID To sDriverID
76716>>>>>>>        If (sDRiverID <> "") Begin
76718>>>>>>>            Move (Repeat(" ", 255)) To sRevision
76719>>>>>>>            Call_Driver 0 sDRiverID Function CLI_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
76724>>>>>>>        End
76724>>>>>>>>
76724>>>>>>>
76724>>>>>>>        Function_Return sRevision
76725>>>>>>>    End_Function // CKRevision
76726>>>>>>>
76726>>>>>>>
76726>>>>>>>
76726>>>>>>>    //***
76726>>>>>>>    //*** Function: ExtractPartFromRevision
76726>>>>>>>    //*** Purpose : Extarct the Nth part of a a.b.c.d revsion string.
76726>>>>>>>    //***
76726>>>>>>>    //*** Returns : The part version number or -1 if there is no such part number.
76726>>>>>>>    //***
76726>>>>>>>
76726>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
76728>>>>>>>        Local Integer iPartRev
76728>>>>>>>        Local Integer iCurrentPart
76728>>>>>>>        Local Integer iSeparatorPos
76728>>>>>>>
76728>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
76731>>>>>>>
76731>>>>>>>        Move 0 To iCurrentPart
76732>>>>>>>        Repeat
76732>>>>>>>>
76732>>>>>>>            Move (Pos(".", sRevision)) To iSeparatorPos
76733>>>>>>>            If (iSeparatorPos > 0) Begin
76735>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) To iPartRev
76736>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) To sRevision
76737>>>>>>>                Increment iCurrentPart
76738>>>>>>>            End
76738>>>>>>>>
76738>>>>>>>            Else If (sRevision <> "") Begin
76741>>>>>>>                Move sRevision To iPartRev
76742>>>>>>>                Move "" To sRevision
76743>>>>>>>                Increment iCurrentPart
76744>>>>>>>            End
76744>>>>>>>>
76744>>>>>>>            Else ;                Move -1 To iPartRev
76746>>>>>>>        Until (iCurrentPart >= iPartNum Or iPartRev = -1)
76748>>>>>>>
76748>>>>>>>        Function_Return iPartRev
76749>>>>>>>    End_Function // EcxtractPartFromRevision
76750>>>>>>>
76750>>>>>>>
76750>>>>>>>
76750>>>>>>>    //***
76750>>>>>>>    //*** Function: CKMajorRevision
76750>>>>>>>    //*** Purpose : Returns the major revision of the CK
76750>>>>>>>    //***
76750>>>>>>>
76750>>>>>>>    Function CKMajorRevision Returns Integer
76752>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
76753>>>>>>>    End_Function // CKMajorRevision
76754>>>>>>>
76754>>>>>>>
76754>>>>>>>
76754>>>>>>>    //***
76754>>>>>>>    //*** Function: CKMinorRevision
76754>>>>>>>    //*** Purpose : Returns the minor revision of the CK
76754>>>>>>>    //***
76754>>>>>>>
76754>>>>>>>    Function CKMinorRevision Returns Integer
76756>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
76757>>>>>>>    End_Function // CKMinorRevision
76758>>>>>>>
76758>>>>>>>
76758>>>>>>>
76758>>>>>>>    //***
76758>>>>>>>    //*** Function: CKReleaseRevision
76758>>>>>>>    //*** Purpose : Returns the release revision of the CK
76758>>>>>>>    //***
76758>>>>>>>
76758>>>>>>>    Function CKReleaseRevision Returns Integer
76760>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
76761>>>>>>>    End_Function // CKReleaseRevision
76762>>>>>>>
76762>>>>>>>
76762>>>>>>>
76762>>>>>>>    //***
76762>>>>>>>    //*** Function: CKBuildRevision
76762>>>>>>>    //*** Purpose : Returns the major revision of the CK
76762>>>>>>>    //***
76762>>>>>>>
76762>>>>>>>    Function CKBuildRevision Returns Integer
76764>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
76765>>>>>>>    End_Function // CKBuildRevision
76766>>>>>>>
76766>>>>>>>
76766>>>>>>>
76766>>>>>>>    //***
76766>>>>>>>    //*** Function: IsMinimalRevision
76766>>>>>>>    //*** Purpose : Determines if the CK conforms to a passed minimal revsion.
76766>>>>>>>    //***
76766>>>>>>>
76766>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
76768>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_return (TRUE)
76771>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
76774>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_return (TRUE)
76777>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
76780>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_return (TRUE)
76783>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) And iBuild <= CKBuildRevision(Current_object)) ;                    Function_return (TRUE)
76787>>>>>>>            End
76787>>>>>>>>
76787>>>>>>>        End
76787>>>>>>>>
76787>>>>>>>
76787>>>>>>>        Function_Return (FALSE)
76788>>>>>>>    End_Function // IsMinimalRevision
76789>>>>>>>
76789>>>>>>>
76789>>>>>>>
76789>>>>>>>    //***
76789>>>>>>>    //*** Function: RegistrationName
76789>>>>>>>    //*** Purpose : Returns the Connectiivty Kit registration name.
76789>>>>>>>    //***
76789>>>>>>>
76789>>>>>>>    Function RegistrationName Returns String
76791>>>>>>>        Local String  sRegistration
76791>>>>>>>        Local String  sDRiverId
76791>>>>>>>        Local String  sVoid
76791>>>>>>>        Local Integer iRetval
76791>>>>>>>
76791>>>>>>>        Get psDriverID To sDriverID
76792>>>>>>>        If (sDRiverID <> "") Begin
76794>>>>>>>            Move (Repeat(" ", 255)) To sRegistration
76795>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETREGNAME Callback 0 Passing sRegistration sVoid 0 Result iRetval
76800>>>>>>>        End
76800>>>>>>>>
76800>>>>>>>
76800>>>>>>>        Function_Return sRegistration
76801>>>>>>>    End_Function // RegistrationName
76802>>>>>>>
76802>>>>>>>
76802>>>>>>>
76802>>>>>>>    //***
76802>>>>>>>    //*** Function: SerialNumber
76802>>>>>>>    //*** Purpose : Returns the Connectiivty Kit serial number.
76802>>>>>>>    //***
76802>>>>>>>
76802>>>>>>>    Function SerialNumber Returns Integer
76804>>>>>>>        Local String  sDRiverId
76804>>>>>>>        Local String  sVoid
76804>>>>>>>        Local Integer iRetval
76804>>>>>>>
76804>>>>>>>        Get psDriverID To sDriverID
76805>>>>>>>        If (sDRiverID <> "") Begin
76807>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETSERIALNUM Callback 0 Passing sVoid sVoid 0 Result iRetval
76812>>>>>>>        End
76812>>>>>>>>
76812>>>>>>>
76812>>>>>>>        Function_Return iRetval
76813>>>>>>>    End_Function // SerialNumber
76814>>>>>>>
76814>>>>>>>
76814>>>>>>>
76814>>>>>>>    //***
76814>>>>>>>    //*** Function: MaxUsers
76814>>>>>>>    //*** Purpose : Returns the Connectiivty Kit maximum number of users.
76814>>>>>>>    //***
76814>>>>>>>
76814>>>>>>>    Function MaxUsers Returns Integer
76816>>>>>>>        Local String  sDRiverId
76816>>>>>>>        Local String  sVoid
76816>>>>>>>        Local Integer iRetval
76816>>>>>>>
76816>>>>>>>        Get psDriverID To sDriverID
76817>>>>>>>        If (sDRiverID <> "") Begin
76819>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETMAXUSERS Callback 0 Passing sVoid sVoid 0 Result iRetval
76824>>>>>>>        End
76824>>>>>>>>
76824>>>>>>>
76824>>>>>>>        Function_Return iRetval
76825>>>>>>>    End_Function // MaxUsers
76826>>>>>>>
76826>>>>>>>
76826>>>>>>>
76826>>>>>>>    //***
76826>>>>>>>    //*** Procedure: DumpStatus
76826>>>>>>>    //*** Purpose  : Dump the current status of the drver in the passed disk file.
76826>>>>>>>    //***
76826>>>>>>>
76826>>>>>>>    Procedure DumpStatus String sFileName
76828>>>>>>>        Local String  sVoid
76828>>>>>>>        Local String  sDriverID
76828>>>>>>>        Local Integer iVoid
76828>>>>>>>
76828>>>>>>>        Get psDriverID To sDriverID
76829>>>>>>>        If (sDriverID <> "") ;            Call_driver 0 sDriverID Function CLI_DUMPSTATUS Callback 0 Passing sFileName sVoid iVoid Result iVoid
76836>>>>>>>    End_Procedure // DumpStatus
76837>>>>>>>
76837>>>>>>>
76837>>>>>>>
76837>>>>>>>    //***
76837>>>>>>>    //*** Procedure: ReadConfiguration
76837>>>>>>>    //*** Purpose  : Reset all driver level configurable attributes to the
76837>>>>>>>    //***            default value and then reread the configuration.
76837>>>>>>>    //***
76837>>>>>>>
76837>>>>>>>    Procedure ReadConfiguration
76839>>>>>>>        Local String  sVoid
76839>>>>>>>        Local String  sDriverID
76839>>>>>>>        Local Integer iVoid
76839>>>>>>>
76839>>>>>>>        Get psDriverID To sDriverID
76840>>>>>>>        If (sDriverID <> "") ;            Call_driver 0 sDriverID Function CLI_READCONFIGURATION Callback 0 Passing sVoid sVoid iVoid Result iVoid
76847>>>>>>>    End_Procedure // ReadConfiguration
76848>>>>>>>
76848>>>>>>>
76848>>>>>>>
76848>>>>>>>    //***
76848>>>>>>>    //*** Function: TextToRIMValue
76848>>>>>>>    //*** Purpose : Convert a text to the corresponding
76848>>>>>>>    //***           Generate_Record_ID_Method attribute value
76848>>>>>>>    //***
76848>>>>>>>
76848>>>>>>>    Function TextToRIMValue String sText Returns Integer
76850>>>>>>>        If (sText = "None") ;            Function_return RIM_NONE
76853>>>>>>>        Else If (sText = "Identity Column") ;            Function_return RIM_IDENTITY_COLUMN
76857>>>>>>>        Else If (sText = "Dispenser Table") ;            Function_return RIM_DISPENSER_TABLE
76861>>>>>>>        Else If (sText = "External") ;            Function_return RIM_EXTERNAL
76865>>>>>>>    End_Function // TextToRIMValue
76866>>>>>>>
76866>>>>>>>
76866>>>>>>>
76866>>>>>>>    //***
76866>>>>>>>    //*** Function: RIMValueTotext
76866>>>>>>>    //*** Purpose : Convert a Generate_Record_ID_Method attribute value to the
76866>>>>>>>    //***           corresponding text.
76866>>>>>>>    //***
76866>>>>>>>
76866>>>>>>>    Function RIMValueToText Integer iAttrValue Returns String
76868>>>>>>>        If (iAttrValue = RIM_NONE) ;            Function_return "None"
76871>>>>>>>        Else If (iAttrValue = RIM_IDENTITY_COLUMN) ;            Function_return "Identity Column"
76875>>>>>>>        Else If (iAttrValue = RIM_DISPENSER_TABLE) ;            Function_return "Dispenser Table"
76879>>>>>>>        Else If (iAttrValue = RIM_EXTERNAL) ;            Function_return "External"
76883>>>>>>>    End_Function // RIMValueToText
76884>>>>>>>
76884>>>>>>>
76884>>>>>>>
76884>>>>>>>    //***
76884>>>>>>>    //*** Function: TextToROValue
76884>>>>>>>    //*** Purpose : Convert a text to the corresponding
76884>>>>>>>    //***           Generate_Record_ID_Method attribute value
76884>>>>>>>    //***
76884>>>>>>>
76884>>>>>>>    Function TextToROValue String sText Returns Integer
76886>>>>>>>        If (sText = "No") ;            Function_return RO_NO
76889>>>>>>>        Else If (sText = "Ignore Change") ;            Function_return RO_IGNORECHANGE
76893>>>>>>>        Else If (sText = "Accept Change") ;            Function_return RO_ACCEPTCHANGE
76897>>>>>>>        Else If (sText = "Error On Change") ;            Function_return RO_ERRORONCHANGE
76901>>>>>>>    End_Function // TextToRIMValue
76902>>>>>>>
76902>>>>>>>
76902>>>>>>>
76902>>>>>>>    //***
76902>>>>>>>    //*** Function: ROValueTotext
76902>>>>>>>    //*** Purpose : Convert a Generate_Record_ID_Method attribute value to the
76902>>>>>>>    //***           corresponding text.
76902>>>>>>>    //***
76902>>>>>>>
76902>>>>>>>    Function ROValueToText Integer iAttrValue Returns String
76904>>>>>>>        If (iAttrValue = RO_NO) ;            Function_return "No"
76907>>>>>>>        Else If (iAttrValue = RO_IGNORECHANGE) ;            Function_return "Ignore Change"
76911>>>>>>>        Else If (iAttrValue = RO_ACCEPTCHANGE) ;            Function_return "Accept Change"
76915>>>>>>>        Else If (iAttrValue = RO_ERRORONCHANGE) ;            Function_return "Error On Change"
76919>>>>>>>    End_Function // RIMValueToText
76920>>>>>>>
76920>>>>>>>
76920>>>>>>>
76920>>>>>>>    //***
76920>>>>>>>    //*** Function: LastDriverError
76920>>>>>>>    //*** Purpose : Return the text f the last error geneated by the driver.
76920>>>>>>>    //***
76920>>>>>>>
76920>>>>>>>    Function LastDriverError Returns String
76922>>>>>>>        Local String  sDriverID
76922>>>>>>>        Local String  sLastError
76922>>>>>>>        Local String  sLastErrorLength
76922>>>>>>>        Local Integer iLastErrorLength
76922>>>>>>>        Local Integer iVoid
76922>>>>>>>
76922>>>>>>>        //*** Initialize
76922>>>>>>>        Move "" To sLastError
76923>>>>>>>
76923>>>>>>>        Get psDriverID To sDriverID
76924>>>>>>>        If (sDriverID <> "") Begin
76926>>>>>>>            //*** Get the text of the last error
76926>>>>>>>            Move (Repeat(Character(" "), 14)) To sLastErrorlength
76927>>>>>>>            Call_driver 0 sDriverID Function CLI_GETDRIVERATTRIBUTE Callback 0 Passing sLastErrorLength iVoid DRVR_LASTERRORTEXTLENGTH Result iVoid
76932>>>>>>>            Move (Left(sLastErrorLength, Pos(Character(0), sLastErrorLength) - 1)) To iLastErrorLength
76933>>>>>>>
76933>>>>>>>            If (iLastErrorLength > 0) Begin
76935>>>>>>>                Move (Repeat(Character(" "), iLastErrorLength + 1)) To sLastError
76936>>>>>>>                Call_driver 0 sDriverID Function CLI_GETDRIVERATTRIBUTE Callback 0 Passing sLastError iVoid DRVR_LASTERRORTEXT Result iVoid
76941>>>>>>>                Move (Left(sLastError, Pos(Character(0), sLastError) - 1)) To sLastError
76942>>>>>>>            End
76942>>>>>>>>
76942>>>>>>>        End
76942>>>>>>>>
76942>>>>>>>
76942>>>>>>>        Function_Return sLastError
76943>>>>>>>    End_Function // LastDriverError
76944>>>>>>>
76944>>>>>>>
76944>>>>>>>
76944>>>>>>>    //***
76944>>>>>>>    //*** Function: EnumerateTables
76944>>>>>>>    //*** Purpose : Enumerate the tables in a database
76944>>>>>>>    //***
76944>>>>>>>
76944>>>>>>>    Function EnumerateTables String sLogin Returns Integer
76946>>>>>>>        Local String  sDriver
76946>>>>>>>        Local String  sVoid
76946>>>>>>>        Local Integer iNumTables
76946>>>>>>>        Local Integer iVoid
76946>>>>>>>
76946>>>>>>>        Get psDriverID To sDriver
76947>>>>>>>        If (sDriver <> "") ;            Call_driver 0 sDriver Function CLI_ENUMERATE_TABLES Callback 0 Passing sLogin sVoid iVoid Result iNumTables
76954>>>>>>>
76954>>>>>>>        Function_Return iNumTables
76955>>>>>>>    End_Function // EnumerateTables
76956>>>>>>>
76956>>>>>>>
76956>>>>>>>
76956>>>>>>>    //***
76956>>>>>>>    //*** Function: TableName
76956>>>>>>>    //*** Purpose : Returns the name of the table enumerated at the given position
76956>>>>>>>    //***
76956>>>>>>>
76956>>>>>>>    Function TableName Integer iIndex Returns String
76958>>>>>>>        Local String  sDriver
76958>>>>>>>        Local String  sTableName
76958>>>>>>>        Local String  sVoid
76958>>>>>>>        Local Integer iVoid
76958>>>>>>>
76958>>>>>>>        Get psDriverID To sDriver
76959>>>>>>>        If (sDriver <> "") Begin
76961>>>>>>>            Move (Repeat(" ", 255)) To sTableName
76962>>>>>>>            Call_driver 0 sDriver Function CLI_TABLENAME Callback 0 Passing sTableName sVoid iIndex Result iVoid
76967>>>>>>>        End
76967>>>>>>>>
76967>>>>>>>
76967>>>>>>>        Function_Return sTableName
76968>>>>>>>    End_Function // TableName
76969>>>>>>>
76969>>>>>>>
76969>>>>>>>
76969>>>>>>>    //***
76969>>>>>>>    //*** Function: SchemaName
76969>>>>>>>    //*** Purpose : Returns the name of the schema of the table enumerated at the given position
76969>>>>>>>    //***
76969>>>>>>>
76969>>>>>>>    Function SchemaName Integer iIndex Returns String
76971>>>>>>>        Local String  sDriver
76971>>>>>>>        Local String  sSchemaName
76971>>>>>>>        Local String  sVoid
76971>>>>>>>        Local Integer iVoid
76971>>>>>>>
76971>>>>>>>        Get psDriverID To sDriver
76972>>>>>>>        If (sDriver <> "") Begin
76974>>>>>>>            Move (Repeat(" ", 255)) To sSchemaName
76975>>>>>>>            Call_driver 0 sDriver Function CLI_TABLESCHEMA Callback 0 Passing sSchemaName sVoid iIndex Result iVoid
76980>>>>>>>        End
76980>>>>>>>>
76980>>>>>>>
76980>>>>>>>        Function_Return sSchemaName
76981>>>>>>>    End_Function // SchemaName
76982>>>>>>>
76982>>>>>>>
76982>>>>>>>
76982>>>>>>>    //***
76982>>>>>>>    //*** Function: TableType
76982>>>>>>>    //*** Purpose : Returns the type of the table enumerated at the given position.
76982>>>>>>>    //***           Types can be "TABLE", "VIEW", "SYSTEM TABLE", "GLOBAL TEMPORARY",
76982>>>>>>>    //***           "LOCAL TEMPORARY", "ALIAS", "SYNONYM"
76982>>>>>>>    //***
76982>>>>>>>
76982>>>>>>>    Function TableType Integer iIndex Returns String
76984>>>>>>>        Local String  sDriver
76984>>>>>>>        Local String  sTableType
76984>>>>>>>        Local String  sVoid
76984>>>>>>>        Local Integer iVoid
76984>>>>>>>
76984>>>>>>>        Get psDriverID To sDriver
76985>>>>>>>        If (sDriver <> "") Begin
76987>>>>>>>            Move (Repeat(" ", 25)) To sTableType
76988>>>>>>>            Call_driver 0 sDriver Function CLI_TABLETYPE Callback 0 Passing sTableType sVoid iIndex Result iVoid
76993>>>>>>>        End
76993>>>>>>>>
76993>>>>>>>
76993>>>>>>>        Function_Return sTableType
76994>>>>>>>    End_Function // TableType
76995>>>>>>>
76995>>>>>>>
76995>>>>>>>
76995>>>>>>>    //***
76995>>>>>>>    //*** Function: TableComment
76995>>>>>>>    //*** Purpose : Returns the comment of the table enumerated at the given position
76995>>>>>>>    //***
76995>>>>>>>
76995>>>>>>>    Function TableComment Integer iIndex Returns String
76997>>>>>>>        Local String  sDriver
76997>>>>>>>        Local String  sTableComment
76997>>>>>>>        Local String  sVoid
76997>>>>>>>        Local Integer iVoid
76997>>>>>>>
76997>>>>>>>        Get psDriverID To sDriver
76998>>>>>>>        If (sDriver <> "") Begin
77000>>>>>>>            Move (Repeat(" ", 255)) To sTableComment
77001>>>>>>>            Call_driver 0 sDriver Function CLI_TABLECOMMENT Callback 0 Passing sTableComment sVoid iIndex Result iVoid
77006>>>>>>>        End
77006>>>>>>>>
77006>>>>>>>
77006>>>>>>>        Function_Return sTableComment
77007>>>>>>>    End_Function // TableComment
77008>>>>>>>
77008>>>>>>>
77008>>>>>>>
77008>>>>>>>    //***
77008>>>>>>>    //*** Function: EnumerateColumns
77008>>>>>>>    //*** Purpose : Enumerate the columns in a table
77008>>>>>>>    //***
77008>>>>>>>
77008>>>>>>>    Function EnumerateColumns String sLogin String sTableName Returns Integer
77010>>>>>>>        Local String  sDriver
77010>>>>>>>        Local Integer iNumColumns
77010>>>>>>>        Local Integer iVoid
77010>>>>>>>
77010>>>>>>>        Get psDriverID To sDriver
77011>>>>>>>        If (sDriver <> "") ;            Call_driver 0 sDriver Function CLI_ENUMERATE_COLUMNS Callback 0 Passing sLogin sTablename iVoid Result iNumColumns
77018>>>>>>>
77018>>>>>>>        Function_Return iNumColumns
77019>>>>>>>    End_Function // EnumerateColumns
77020>>>>>>>
77020>>>>>>>
77020>>>>>>>
77020>>>>>>>    //***
77020>>>>>>>    //*** Function: ColumnName
77020>>>>>>>    //*** Purpose : Returns the name of the column enumerated at the given position
77020>>>>>>>    //***
77020>>>>>>>
77020>>>>>>>    Function ColumnName Integer iIndex Returns String
77022>>>>>>>        Local String  sDriver
77022>>>>>>>        Local String  sColumnName
77022>>>>>>>        Local String  sVoid
77022>>>>>>>        Local Integer iVoid
77022>>>>>>>
77022>>>>>>>        Get psDriverID To sDriver
77023>>>>>>>        If (sDriver <> "") Begin
77025>>>>>>>            Move (Repeat(" ", 255)) To sColumnName
77026>>>>>>>            Call_driver 0 sDriver Function CLI_COLUMNNAME Callback 0 Passing sColumnName sVoid iIndex Result iVoid
77031>>>>>>>        End
77031>>>>>>>>
77031>>>>>>>
77031>>>>>>>        Function_Return sColumnName
77032>>>>>>>    End_Function // ColumnName
77033>>>>>>>
77033>>>>>>>
77033>>>>>>>
77033>>>>>>>    //***
77033>>>>>>>    //*** Function: CLIDFDateToSQLDate
77033>>>>>>>    //*** Purpose : Convert a DataFlex date to a SQL date using the dummy zero date value.
77033>>>>>>>    //***
77033>>>>>>>
77033>>>>>>>    Function CLIDFDateToSQLDate String sDRiver Date dDFDate Returns String
77035>>>>>>>        Local String sSQLDate
77035>>>>>>>        Local Integer iOrgDateFmt
77035>>>>>>>        Local Integer iOrgDateSep
77035>>>>>>>
77035>>>>>>>        //*** Change date format to military, SQL dates are military dates
77035>>>>>>>        Get_Attribute DF_DATE_FORMAT To iOrgDateFmt
77038>>>>>>>        Get_Attribute DF_DATE_SEPARATOR To iOrgDateSep
77041>>>>>>>        Set_Attribute DF_DATE_FORMAT To DF_DATE_MILITARY
77044>>>>>>>        Set_Attribute DF_DATE_SEPARATOR To (Ascii('-'))
77047>>>>>>>
77047>>>>>>>        //*** We only need to convert if the date is 0
77047>>>>>>>        If (Integer(dDFDate = 0)) ;            CLI_Get_Driver_Attribute sDRiver DRVR_DUMMY_ZERO_DATE_VALUE To sSQLDate
77056>>>>>>>        Else ;            Move dDFDate To sSQLDate
77058>>>>>>>
77058>>>>>>>        //*** Change date format back to original
77058>>>>>>>        Set_Attribute DF_DATE_FORMAT To iOrgDateFmt
77061>>>>>>>        Set_Attribute DF_DATE_SEPARATOR To iOrgDateSep
77064>>>>>>>
77064>>>>>>>        Function_Return sSQLDate
77065>>>>>>>    End_Function // CLIDFDateToSQLDate
77066>>>>>>>
77066>>>>>>>
77066>>>>>>>
77066>>>>>>>    //***
77066>>>>>>>    //*** Function: CLISQLDateToDFDate
77066>>>>>>>    //*** Purpose : Convert a SQL date to a DataFlex date using the dummy zero date value.
77066>>>>>>>    //***
77066>>>>>>>
77066>>>>>>>    Function CLISQLDateToDFDate String sDRiver String sSQLDate Returns Date
77068>>>>>>>        Local Date dDFDate
77068>>>>>>>        Local String sDummyDateValue
77068>>>>>>>        Local Integer iOrgDateFmt
77068>>>>>>>        Local Integer iOrgDateSep
77068>>>>>>>
77068>>>>>>>        //*** Change date format to military, SQL dates are military dates
77068>>>>>>>        Get_Attribute DF_DATE_FORMAT To iOrgDateFmt
77071>>>>>>>        Get_Attribute DF_DATE_SEPARATOR To iOrgDateSep
77074>>>>>>>        Set_Attribute DF_DATE_FORMAT To DF_DATE_MILITARY
77077>>>>>>>        Set_Attribute DF_DATE_SEPARATOR To (Ascii('-'))
77080>>>>>>>
77080>>>>>>>        //*** We only need to convert if the date is the dummy zero date value
77080>>>>>>>        CLI_Get_Driver_Attribute sDRiver DRVR_DUMMY_ZERO_DATE_VALUE To sDummyDateValue
77087>>>>>>>        If (sDummyDateValue = sSQLDate) ;            Move 0 To dDFDate
77090>>>>>>>        Else ;            Move sSQLDate To dDFDate
77092>>>>>>>
77092>>>>>>>        //*** Change date format back to original
77092>>>>>>>        Set_Attribute DF_DATE_FORMAT To iOrgDateFmt
77095>>>>>>>        Set_Attribute DF_DATE_SEPARATOR To iOrgDateSep
77098>>>>>>>
77098>>>>>>>        Function_Return dDFDate
77099>>>>>>>    End_Function // CLISQLDateToDFDate
77100>>>>>>>
77100>>>>>>>
77100>>>>>>>
77100>>>>>>>    //***
77100>>>>>>>    //*** Function: RedirectConnection
77100>>>>>>>    //*** Purpose : Redirect an exisitng connection. The existing connection
77100>>>>>>>    //***           will point to another database but all tables will stay
77100>>>>>>>    //***           open!
77100>>>>>>>    //***
77100>>>>>>>
77100>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
77102>>>>>>>        Local String  sDriver
77102>>>>>>>        Local String  sVoid
77102>>>>>>>        Local Integer iResult
77102>>>>>>>        Local Integer iVoid
77102>>>>>>>
77102>>>>>>>        Get psDriverID To sDriver
77103>>>>>>>        If (sDriver <> "") Begin
77105>>>>>>>            Call_driver 0 sDriver Function CLI_REDIRECTCONNECTION Callback 0 Passing sOldConnection sNewConnection iVoid Result iResult
77110>>>>>>>        End
77110>>>>>>>>
77110>>>>>>>        Function_Return iResult
77111>>>>>>>    End_Function // RedirectConnect
77112>>>>>>>
77112>>>>>>>
77112>>>>>>>
77112>>>>>>>    //***
77112>>>>>>>    //*** Function: CreateConnectionID
77112>>>>>>>    //*** Purpose : Create a DataFlex side connection id that can be used later on.
77112>>>>>>>    //***
77112>>>>>>>
77112>>>>>>>    Function CreateConnectionID String sID String sConnStr Integer iOpt Returns Integer
77114>>>>>>>        Local String  sDriver
77114>>>>>>>        Local Integer iResult
77114>>>>>>>        Local Integer iOptions
77114>>>>>>>
77114>>>>>>>        Get psDriverID to sDriver
77115>>>>>>>        If (Num_Arguments = 2) ;            Move 0 to iOptions
77118>>>>>>>        Else ;            Move iOpt to iOptions
77120>>>>>>>        If (sDriver <> "") Begin
77122>>>>>>>            Call_Driver 0 sDriver Function CLI_CREATECONNECTIONID Callback 0 Passing sID sConnStr iOptions Result iResult
77127>>>>>>>        End
77127>>>>>>>>
77127>>>>>>>        Function_Return iResult
77128>>>>>>>    End_Function // CreateConnectionID
77129>>>>>>>
77129>>>>>>>
77129>>>>>>>
77129>>>>>>>    //***
77129>>>>>>>    //*** Function: DeleteConnectionID
77129>>>>>>>    //*** Purpose : Delete a DataFlex side connection id.
77129>>>>>>>    //***
77129>>>>>>>
77129>>>>>>>    Function DeleteConnectionID String sID Integer iIndex Returns Integer
77131>>>>>>>        Local String  sDriver
77131>>>>>>>        Local Integer iResult
77131>>>>>>>        Local String sVoid
77131>>>>>>>
77131>>>>>>>        Get psDriverID To sDriver
77132>>>>>>>        If (sDriver <> "") Begin
77134>>>>>>>            Call_Driver 0 sDriver Function CLI_DELETECONNECTIONID Callback 0 Passing sID sVoid iIndex Result iResult
77139>>>>>>>        End
77139>>>>>>>>
77139>>>>>>>        Function_Return iResult
77140>>>>>>>    End_Function // DeleteConnectionID
77141>>>>>>>
77141>>>>>>>End_Class // cCLIHandler
77142>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files (x86)\DataFlex 18.2\Pkg\DFBTRDRV.PKG)
77142>>>>>>>//****************************************************************************
77142>>>>>>>//
77142>>>>>>>// $File name  : DFBTRDRV.PKG
77142>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
77142>>>>>>>// Notice      : This package contains constants and commands, used to call
77142>>>>>>>//               specific functions in the DFBTRDRV.
77142>>>>>>>// $Author(s)  : Eddy Kleinjan
77142>>>>>>>//
77142>>>>>>>// $System     : DataFlex Connectivity Kit for Pervasive.SQL
77142>>>>>>>// Created     : 01-07-97 @ 12:00:00
77142>>>>>>>//
77142>>>>>>>// Changed     : 04-04-2001.
77142>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.145
77142>>>>>>>//
77142>>>>>>>// Changed     : June 6, 2001
77142>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.148
77142>>>>>>>//
77142>>>>>>>//               Added DFBTR_DDF_OWNER command.
77142>>>>>>>//
77142>>>>>>>// Changed     : June 12, 2001
77142>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.149
77142>>>>>>>//
77142>>>>>>>//               Added DF_FIELD_IS_NULL and DF_FIELD_NULL_ALLOWED attributes
77142>>>>>>>//
77142>>>>>>>// Changed     : August 4, 2004
77142>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 3.0.0.1
77142>>>>>>>//
77142>>>>>>>//               Added cDfbtrdrvHandler class.
77142>>>>>>>//               New functions in this class:
77142>>>>>>>//                  Function CKRevision Returns String
77142>>>>>>>//                  Function CkUsesUri Returns Integer
77142>>>>>>>//                  Function PSQLRequesterVersionInfo Integer iFileNum Returns String
77142>>>>>>>//                  Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
77142>>>>>>>//                  Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
77142>>>>>>>//
77142>>>>>>>// Changed     : September 30, 2005
77142>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 3.0.0.14
77142>>>>>>>//
77142>>>>>>>//               Bugfix: Prevent compiler errors when no (df)error.pkg is used
77142>>>>>>>//****************************************************************************
77142>>>>>>>Use Ui
77142>>>>>>>//
77142>>>>>>>// Driver Indentification
77142>>>>>>>//
77142>>>>>>>
77142>>>>>>>//*** Driver attributes
77142>>>>>>>//
77142>>>>>>>// Call_Driver functions ID's
77142>>>>>>>//
77142>>>>>>>//
77142>>>>>>>// DFBTRFN_CONVERT_FILE options
77142>>>>>>>//
77142>>>>>>>
77142>>>>>>>//
77142>>>>>>>// DFBTRFN_SET_OWNER options
77142>>>>>>>//
77142>>>>>>>
77142>>>>>>>//
77142>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
77142>>>>>>>//
77142>>>>>>>
77142>>>>>>>
77142>>>>>>>//
77142>>>>>>>// Command to create all vars which may be needed
77142>>>>>>>// in other commands.
77142>>>>>>>//
77142>>>>>>>
77142>>>>>>>
77142>>>>>>>
77142>>>>>>>//
77142>>>>>>>// Command to set the owner of a Btrieve file.
77142>>>>>>>// File must have been opened.
77142>>>>>>>// Filenumber needs to be passed.
77142>>>>>>>// To clear set the owner to "".
77142>>>>>>>// Examples:
77142>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
77142>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
77142>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
77142>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
77142>>>>>>>// To clear:
77142>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
77142>>>>>>>//
77142>>>>>>>
77142>>>>>>>
77142>>>>>>>
77142>>>>>>>//
77142>>>>>>>// Command to parse DFBTR_SET_OWNVER
77142>>>>>>>// options.
77142>>>>>>>//
77142>>>>>>>
77142>>>>>>>
77142>>>>>>>
77142>>>>>>>//
77142>>>>>>>// Command to parse for Callback
77142>>>>>>>//
77142>>>>>>>
77142>>>>>>>
77142>>>>>>>
77142>>>>>>>//
77142>>>>>>>// Command to clear the owner of a Btrieve file.
77142>>>>>>>// File must have been opened.
77142>>>>>>>// Filenumber needs to be passed.
77142>>>>>>>// Examples:
77142>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
77142>>>>>>>//
77142>>>>>>>
77142>>>>>>>
77142>>>>>>>
77142>>>>>>>//
77142>>>>>>>// Command to add a owner name to the internal list of ownernames
77142>>>>>>>// which will be tries when opening files.
77142>>>>>>>//
77142>>>>>>>
77142>>>>>>>
77142>>>>>>>
77142>>>>>>>//
77142>>>>>>>// Command to remove all owners from the internal list of ownernames
77142>>>>>>>//
77142>>>>>>>
77142>>>>>>>
77142>>>>>>>//
77142>>>>>>>// Command to set the owner name to be used when opening the DDF files.
77142>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
77142>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
77142>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
77142>>>>>>>//
77142>>>>>>>
77142>>>>>>>//
77142>>>>>>>// Command to change the transaction type.
77142>>>>>>>// Valid types are:
77142>>>>>>>//     DFBTRTT_NONE
77142>>>>>>>//     DFBTRTT_EXCLUSIVE
77142>>>>>>>//     DFBTRTT_CONCURRENT
77142>>>>>>>//
77142>>>>>>>//
77142>>>>>>>
77142>>>>>>>
77142>>>>>>>
77142>>>>>>>//
77142>>>>>>>// Command to get the current transaction type.
77142>>>>>>>//
77142>>>>>>>
77142>>>>>>>//
77142>>>>>>>// Command to set explicit_locking
77142>>>>>>>//
77142>>>>>>>
77142>>>>>>>//
77142>>>>>>>// Command to get explicit locking
77142>>>>>>>//
77142>>>>>>>
77142>>>>>>>//
77142>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
77142>>>>>>>//
77142>>>>>>>
77142>>>>>>>//
77142>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
77142>>>>>>>//
77142>>>>>>>
77142>>>>>>>//*****************************************************************************
77142>>>>>>>//*** Class  : cDfbtrdrvHandler                                                  ***
77142>>>>>>>//*** Purpose: An instance of this class can be used as a broker object to  ***
77142>>>>>>>//***          call several Dfbtrdrv releated methods.                           ***
77142>>>>>>>//*****************************************************************************
77142>>>>>>>
77142>>>>>>>Class cDFBtrDrvHandler Is An Array
77143>>>>>>>
77143>>>>>>>    Procedure Construct_Object Integer iImage
77145>>>>>>>        Forward Send Construct_object iImage
77147>>>>>>>
77147>>>>>>>        Property String  psDriverID       Public "DFBTRDRV"
77148>>>>>>>    End_Procedure // Construct_Object
77149>>>>>>>
77149>>>>>>>
77149>>>>>>>
77149>>>>>>>    //***
77149>>>>>>>    //*** Function: CKRevsion
77149>>>>>>>    //*** Purpose : The revsion of a Dfbtrdrv Connectivity Kit
77149>>>>>>>    //***
77149>>>>>>>
77149>>>>>>>    Function CKRevision Returns String
77151>>>>>>>        Local String  sDriverID
77151>>>>>>>        Local String  sRevision
77151>>>>>>>        Local String  sVoid
77151>>>>>>>        Local Integer iRetval
77151>>>>>>>
77151>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
77151>>>>>>>        // This error would otherwise be raised when we have an older
77151>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
77151>>>>>>>        Send Ignore_error To Error_object_Id 20491
77152>>>>>>>        Get psDriverID To sDriverID
77153>>>>>>>        Move (Repeat(" ", 255)) To sRevision
77154>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
77159>>>>>>>        Send Trap_Error To Error_object_Id 20491
77160>>>>>>>        If (Trim(sRevision) = "") Begin
77162>>>>>>>            // Unable to get the revision. return all zeroes.
77162>>>>>>>            Move "0.0.0.0" To sRevision
77163>>>>>>>        End
77163>>>>>>>>
77163>>>>>>>        Function_Return sRevision
77164>>>>>>>    End_Function // CKRevision
77165>>>>>>>
77165>>>>>>>    Function CkUsesUri Returns Integer
77167>>>>>>>        Local String  sDriverID
77167>>>>>>>        Local String  sVoid1
77167>>>>>>>        Local String  sVoid2
77167>>>>>>>        Local Integer iRetval
77167>>>>>>>
77167>>>>>>>        Get psDriverID To sDriverID
77168>>>>>>>
77168>>>>>>>        Move 0 To iRetval
77169>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
77169>>>>>>>        // This error would otherwise be raised when we have an older
77169>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
77169>>>>>>>        Send Ignore_error To Error_object_Id 20491
77170>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
77175>>>>>>>        Send Trap_Error To Error_object_Id 20491
77176>>>>>>>
77176>>>>>>>        Function_Return iRetval
77177>>>>>>>    End_Function // CKUsesUri
77178>>>>>>>
77178>>>>>>>
77178>>>>>>>
77178>>>>>>>    //***
77178>>>>>>>    //*** Function: ExtractPartFromRevsion
77178>>>>>>>    //*** Purpose : Extarct the Nth part of a a.b.c.d revsion string.
77178>>>>>>>    //***
77178>>>>>>>    //*** Returns : The part version number or -1 if there is no such part number.
77178>>>>>>>    //***
77178>>>>>>>
77178>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
77180>>>>>>>        Local Integer iPartRev
77180>>>>>>>        Local Integer iCurrentPart
77180>>>>>>>        Local Integer iSeparatorPos
77180>>>>>>>
77180>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
77183>>>>>>>
77183>>>>>>>        Move 0 To iCurrentPart
77184>>>>>>>        Repeat
77184>>>>>>>>
77184>>>>>>>            Move (Pos(".", sRevision)) To iSeparatorPos
77185>>>>>>>            If (iSeparatorPos > 0) Begin
77187>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) To iPartRev
77188>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) To sRevision
77189>>>>>>>                Increment iCurrentPart
77190>>>>>>>            End
77190>>>>>>>>
77190>>>>>>>            Else If (sRevision <> "") Begin
77193>>>>>>>                Move sRevision To iPartRev
77194>>>>>>>                Move "" To sRevision
77195>>>>>>>                Increment iCurrentPart
77196>>>>>>>            End
77196>>>>>>>>
77196>>>>>>>            Else ;                Move -1 To iPartRev
77198>>>>>>>        Until (iCurrentPart >= iPartNum Or iPartRev = -1)
77200>>>>>>>
77200>>>>>>>        Function_Return iPartRev
77201>>>>>>>    End_Function // EcxtractPartFromRevision
77202>>>>>>>
77202>>>>>>>
77202>>>>>>>
77202>>>>>>>    //***
77202>>>>>>>    //*** Function: CKMajorRevision
77202>>>>>>>    //*** Purpose : Returns the major revision of the CK
77202>>>>>>>    //***
77202>>>>>>>
77202>>>>>>>    Function CKMajorRevision Returns Integer
77204>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
77205>>>>>>>    End_Function // CKMajorRevision
77206>>>>>>>
77206>>>>>>>
77206>>>>>>>
77206>>>>>>>    //***
77206>>>>>>>    //*** Function: CKMinorRevision
77206>>>>>>>    //*** Purpose : Returns the minor revision of the CK
77206>>>>>>>    //***
77206>>>>>>>
77206>>>>>>>    Function CKMinorRevision Returns Integer
77208>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
77209>>>>>>>    End_Function // CKMinorRevision
77210>>>>>>>
77210>>>>>>>
77210>>>>>>>
77210>>>>>>>    //***
77210>>>>>>>    //*** Function: CKReleaseRevision
77210>>>>>>>    //*** Purpose : Returns the release revision of the CK
77210>>>>>>>    //***
77210>>>>>>>
77210>>>>>>>    Function CKReleaseRevision Returns Integer
77212>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
77213>>>>>>>    End_Function // CKReleaseRevision
77214>>>>>>>
77214>>>>>>>
77214>>>>>>>
77214>>>>>>>    //***
77214>>>>>>>    //*** Function: CKBuildRevision
77214>>>>>>>    //*** Purpose : Returns the major revision of the CK
77214>>>>>>>    //***
77214>>>>>>>
77214>>>>>>>    Function CKBuildRevision Returns Integer
77216>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
77217>>>>>>>    End_Function // CKBuildRevision
77218>>>>>>>
77218>>>>>>>
77218>>>>>>>
77218>>>>>>>    //***
77218>>>>>>>    //*** Function: IsMinimalRevision
77218>>>>>>>    //*** Purpose : Determines if the CK conforms to a passed minimal revsion.
77218>>>>>>>    //***
77218>>>>>>>
77218>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
77220>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_return (TRUE)
77223>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
77226>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_return (TRUE)
77229>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
77232>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_return (TRUE)
77235>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) And iBuild <= CKBuildRevision(Current_object)) ;                    Function_return (TRUE)
77239>>>>>>>            End
77239>>>>>>>>
77239>>>>>>>        End
77239>>>>>>>>
77239>>>>>>>
77239>>>>>>>        Function_Return (FALSE)
77240>>>>>>>    End_Function // IsMinimalRevision
77241>>>>>>>
77241>>>>>>>    //   Functions to query the Pervasive.SQL version:
77241>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
77241>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
77241>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
77241>>>>>>>    //
77241>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
77241>>>>>>>    //   in the following format:
77241>>>>>>>    //       <version>.<revision>.<type>
77241>>>>>>>    //   possible values for <type>:
77241>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
77241>>>>>>>    //         server using Workgroup authentication mode
77241>>>>>>>    //       C for client cache engine
77241>>>>>>>    //       D for DOS workstation
77241>>>>>>>    //       N for client Requester
77241>>>>>>>    //       S for NetWare server
77241>>>>>>>    //       T for 32-bit Windows server engine
77241>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
77241>>>>>>>    //
77241>>>>>>>    //   example:
77241>>>>>>>    //       8.50.T
77241>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
77241>>>>>>>    //   32-bits Windows server.
77241>>>>>>>    //
77241>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
77241>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
77241>>>>>>>    //
77241>>>>>>>    //   If the version information is not available or can not be obtained
77241>>>>>>>    //   the functions will return "0.0.0"
77241>>>>>>>
77241>>>>>>>
77241>>>>>>>    //***
77241>>>>>>>    //*** Function: PSQLRequesterVersionInfo
77241>>>>>>>    //*** Purpose : Returns the version information of the
77241>>>>>>>    //***           Pervasive.SQL Client requester.
77241>>>>>>>
77241>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
77243>>>>>>>
77243>>>>>>>        Local String  sDriverID
77243>>>>>>>        Local String  sVersion
77243>>>>>>>        Local String  sVoid
77243>>>>>>>        Local Integer iRetval
77243>>>>>>>
77243>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
77243>>>>>>>        // This error would otherwise be raised when we have an older
77243>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
77243>>>>>>>        Send Ignore_error To Error_object_Id 20491
77244>>>>>>>        Get psDriverID To sDriverID
77245>>>>>>>        Move (Repeat(" ", 255)) To sVersion
77246>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
77251>>>>>>>        Send Trap_Error To Error_object_Id 20491
77252>>>>>>>        If (Trim(sVersion) = "") Begin
77254>>>>>>>            // Unable to get the revision. return all zeroes.
77254>>>>>>>            Move "0.0.0" To sVersion
77255>>>>>>>        End
77255>>>>>>>>
77255>>>>>>>        Function_Return sVersion
77256>>>>>>>    End_Function //  PSQLRequesterVersion
77257>>>>>>>
77257>>>>>>>    //***
77257>>>>>>>    //*** Function: PSQLLocalEngineVersionInfo
77257>>>>>>>    //*** Purpose : Returns the version information of the
77257>>>>>>>    //***           Pervasive.SQL Local Engine
77257>>>>>>>
77257>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
77259>>>>>>>
77259>>>>>>>        Local String  sDriverID
77259>>>>>>>        Local String  sVersion
77259>>>>>>>        Local String  sVoid
77259>>>>>>>        Local Integer iRetval
77259>>>>>>>
77259>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
77259>>>>>>>        // This error would otherwise be raised when we have an older
77259>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
77259>>>>>>>        Send Ignore_error To Error_object_Id 20491
77260>>>>>>>        Get psDriverID To sDriverID
77261>>>>>>>        Move (Repeat(" ", 255)) To sVersion
77262>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
77267>>>>>>>        Send Trap_Error To Error_object_Id 20491
77268>>>>>>>        If (Trim(sVersion) = "") Begin
77270>>>>>>>            // Unable to get the revision. return all zeroes.
77270>>>>>>>            Move "0.0.0" To sVersion
77271>>>>>>>        End
77271>>>>>>>>
77271>>>>>>>        Function_Return sVersion
77272>>>>>>>    End_Function //  PSQLLocalEngineVersion
77273>>>>>>>
77273>>>>>>>    //***
77273>>>>>>>    //*** Function: PSQLServerEngineVersionInfo
77273>>>>>>>    //*** Purpose : Returns the version information of the
77273>>>>>>>    //***           Pervasive.SQL Server Engine
77273>>>>>>>
77273>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
77275>>>>>>>
77275>>>>>>>        Local String  sDriverID
77275>>>>>>>        Local String  sVersion
77275>>>>>>>        Local String  sVoid
77275>>>>>>>        Local Integer iRetval
77275>>>>>>>
77275>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
77275>>>>>>>        // This error would otherwise be raised when we have an older
77275>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
77275>>>>>>>        Send Ignore_error To Error_object_Id 20491
77276>>>>>>>        Get psDriverID To sDriverID
77277>>>>>>>        Move (Repeat(" ", 255)) To sVersion
77278>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
77283>>>>>>>        Send Trap_Error To Error_object_Id 20491
77284>>>>>>>        If (Trim(sVersion) = "") Begin
77286>>>>>>>            // Unable to get the revision. return all zeroes.
77286>>>>>>>            Move "0.0.0" To sVersion
77287>>>>>>>        End
77287>>>>>>>>
77287>>>>>>>        Function_Return sVersion
77288>>>>>>>    End_Function //  PSQLServerEngineVersion
77289>>>>>>>
77289>>>>>>>End_Class // cDfbtrdrvHandler
77290>>>>>>>
77290>>>>>
77290>>>>>
77290>>>>>External_Function WNetGetUser "WNetGetUserA" MPR.DLL Pointer lpName Pointer lpUser_Name Pointer lpLength Returns DWord
77291>>>>>
77291>>>>>Register_Function phoWorkspace Returns Handle
77291>>>>>Register_Function Help_filename Returns String
77291>>>>>Register_Function GetHelpFile Returns String
77291>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
77291>>>>>
77291>>>>>//****************************************************************************
77291>>>>>// $Module type: FUNCTION
77291>>>>>// $Module name: Network_User_Name
77291>>>>>// $Author     : AK/VOO/KCR
77291>>>>>// Created     : 09-24-96 @ 19:17
77291>>>>>//
77291>>>>>// Description
77291>>>>>//    This function reads the current username Of windows and returns that
77291>>>>>//    name or an text unknown user
77291>>>>>//
77291>>>>>// $Rev History
77291>>>>>//  02/22/2012  Ask Windows how long the size of the name should be
77291>>>>>//  07/25/2003  Replaced obsolete code
77291>>>>>//  09/24/1996  Module header created
77291>>>>>//****************************************************************************
77291>>>>>Function Network_User_Name for cDesktop Returns String
77293>>>>>    String sName
77293>>>>>    Integer iRetval iLength
77293>>>>>
77293>>>>>    Move 0 to iLength
77294>>>>>    Move (WNetGetUser (0, 0, AddressOf (iLength))) to iRetval
77295>>>>>    ZeroString iLength to sName
77296>>>>>    Move (WNetGetUser (0, AddressOf (sName), AddressOf (iLength))) to iRetval
77297>>>>>
77297>>>>>    If (iRetval = NO_ERROR) Begin
77299>>>>>        Function_Return (CString (sName))
77300>>>>>    End
77300>>>>>>
77300>>>>>    
77300>>>>>    Function_Return "User Unknown"
77301>>>>>End_Function
77302>>>>>
77302>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
77302>>>>>Type MEMORYSTATUS
77302>>>>>   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
77302>>>>>   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
77302>>>>>   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
77302>>>>>   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
77302>>>>>   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
77302>>>>>   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
77302>>>>>   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
77302>>>>>   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
77302>>>>>End_Type // MEMORYSTATUS
77302>>>>>
77302>>>>>External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
77303>>>>>
77303>>>>>Struct tWinMemoryStatusEx
77303>>>>>    UInteger dwLength                
77303>>>>>    UInteger dwMemoryLoad          
77303>>>>>    UBigInt ullTotalPhys           
77303>>>>>    UBigInt ullAvailPhys           
77303>>>>>    UBigInt ullTotalPageFile       
77303>>>>>    UBigInt ullAvailPageFile       
77303>>>>>    UBigInt ullTotalVirtual        
77303>>>>>    UBigInt ullAvailVirtual        
77303>>>>>    UBigInt ullAvailExtendedVirtual
77303>>>>>End_Struct
77303>>>>>
77303>>>>>External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
77304>>>>>
77304>>>>>Class SysinfoDisplay is a cTextEdit
77305>>>>>    Procedure Construct_Object
77307>>>>>        Forward Send Construct_Object
77309>>>>>
77309>>>>>        Set Location To 6 6
77310>>>>>        Set Size To 110 255
77311>>>>>        Set Read_Only_State To True
77312>>>>>        Set pbWrap to False
77313>>>>>    End_Procedure
77314>>>>>
77314>>>>>    //****************************************************************************
77314>>>>>    // $Module type: PROCEDURE
77314>>>>>    // $Module name: Show_Current_Directory
77314>>>>>    // $Author     : VOO
77314>>>>>    // Created     : 06-10-96 @ 15:24
77314>>>>>    //
77314>>>>>    // Description
77314>>>>>    //    This method will show the name Of the current directory in the system
77314>>>>>    //    information box
77314>>>>>    //
77314>>>>>    // $Rev History
77314>>>>>    //    06-10-96  Module header created
77314>>>>>    //****************************************************************************
77314>>>>>    Procedure Show_Current_Directory
77316>>>>>        String sDir
77316>>>>>
77316>>>>>        Get_Current_Directory To sDir
77317>>>>>
77317>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
77318>>>>>    End_Procedure
77319>>>>>
77319>>>>>    Procedure Show_Windows_Directory
77321>>>>>        String sWindir
77321>>>>>
77321>>>>>        Get_Windows_Directory To sWindir
77322>>>>>
77322>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
77323>>>>>    End_Procedure
77324>>>>>
77324>>>>>    Procedure Show_Current_User
77326>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
77327>>>>>    End_Procedure
77328>>>>>
77328>>>>>    Procedure Show_Number_Format
77330>>>>>        Integer iFormat
77330>>>>>        String sFormatText
77330>>>>>
77330>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
77333>>>>>        Move (Character (iFormat)) To sFormatText
77334>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
77335>>>>>
77335>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
77338>>>>>        Move (Character (iFormat)) to sFormatText
77339>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
77340>>>>>    End_Procedure
77341>>>>>
77341>>>>>    Procedure Show_Filelist_Name
77343>>>>>        String sFilename
77343>>>>>
77343>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
77346>>>>>
77346>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
77347>>>>>        Send AppendTextLn ""
77348>>>>>    End_Procedure
77349>>>>>
77349>>>>>    Procedure Show_Lock_Delay
77351>>>>>        Integer iLockdelay
77351>>>>>
77351>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
77354>>>>>
77354>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
77355>>>>>    End_Procedure
77356>>>>>
77356>>>>>    Procedure Show_Lock_Timeout
77358>>>>>        Integer iLockTimeout
77358>>>>>
77358>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
77361>>>>>
77361>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
77362>>>>>    End_Procedure
77363>>>>>
77363>>>>>    Procedure Show_Screen_Size
77365>>>>>        Integer iYscreensize iXscreensize
77365>>>>>
77365>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
77366>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
77367>>>>>
77367>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
77368>>>>>    End_Procedure
77369>>>>>
77369>>>>>    Procedure Show_Page_Size
77371>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
77372>>>>>    End_procedure
77373>>>>>
77373>>>>>    Procedure Show_Date
77375>>>>>        Date dToday
77375>>>>>
77375>>>>>        Sysdate dToday
77376>>>>>
77376>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
77377>>>>>    End_procedure
77378>>>>>
77378>>>>>    Procedure Show_Date_Format
77380>>>>>        Integer iDateFormat
77380>>>>>        String sDateFormat
77380>>>>>
77380>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
77383>>>>>        Case Begin
77383>>>>>            Case (iDateFormat = DF_DATE_USA)
77385>>>>>                Move C_$USA To sDateFormat
77386>>>>>                Case Break
77387>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
77390>>>>>                Move C_$European To sDateFormat
77391>>>>>                Case Break
77392>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
77395>>>>>                Move C_$Military To sDateFormat
77396>>>>>                Case Break
77397>>>>>            Case Else
77397>>>>>                Move C_$UnknownDateType To sDateFormat
77398>>>>>                Case Break
77399>>>>>        Case End
77399>>>>>
77399>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
77400>>>>>    End_Procedure
77401>>>>>
77401>>>>>    Procedure Show_Systemresources
77403>>>>>        tWinMemoryStatusEx MemoryStatusInfo
77403>>>>>        tWinMemoryStatusEx MemoryStatusInfo
77403>>>>>        Integer iRetval
77403>>>>>
77403>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
77404>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
77405>>>>>        If (iRetval = 0) Begin
77407>>>>>            Move (ShowLastError ()) to iRetval
77408>>>>>        End
77408>>>>>>
77408>>>>>
77408>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, MemoryStatusInfo.ullTotalPhys))
77409>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, MemoryStatusInfo.dwMemoryLoad))
77410>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
77411>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
77412>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
77413>>>>>    End_Procedure
77414>>>>>
77414>>>>>    Procedure Show_Registration
77416>>>>>        String sRegName
77416>>>>>        Integer iSN iMaxUsers
77416>>>>>
77416>>>>>        Registration sRegName iSN
77417>>>>>>
77417>>>>>        
77417>>>>>        Get_Licensed_Max_Users to iMaxUsers
77418>>>>>
77418>>>>>        Send AppendTextLn ""
77419>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
77420>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
77421>>>>>        Send AppendTextLn (SFormat (C_$MaxNumUsers, iMaxUsers))
77422>>>>>    End_Procedure
77423>>>>>
77423>>>>>    //****************************************************************************
77423>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
77423>>>>>    // To the workspace object passing the an object and message To send back
77423>>>>>    // To this object. It is expected that the workspace object will send this
77423>>>>>    // message for every line Of information it wants displayed (passing the
77423>>>>>    // information To be displayed
77423>>>>>    //****************************************************************************
77423>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
77423>>>>>
77423>>>>>    Procedure Show_ServicePack
77425>>>>>        String sKey sVersionDescription sVersion 
77425>>>>>        Handle hoRegistry
77425>>>>>        Boolean bExists bOpened
77425>>>>>        
77425>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
77426>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
77427>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
77428>>>>>
77428>>>>>        Move C_DFVersionRegistryRoot to sKey
77429>>>>>        Get KeyExists of hoRegistry sKey to bExists
77430>>>>>        If (bExists) Begin
77432>>>>>            Get OpenKey of hoRegistry sKey to bOpened
77433>>>>>            If (bOpened) Begin
77435>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
77436>>>>>                If (bExists) Begin
77438>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersionDescription
77439>>>>>                End
77439>>>>>>
77439>>>>>                
77439>>>>>                Get ValueExists of hoRegistry "CurrentVersion" to bExists
77440>>>>>                If (bExists) Begin
77442>>>>>                    Get ReadString of hoRegistry "CurrentVersion" to sVersion
77443>>>>>                End                
77443>>>>>>
77443>>>>>                Send CloseKey of hoRegistry
77444>>>>>            End
77444>>>>>>
77444>>>>>        End
77444>>>>>>
77444>>>>>        Send Destroy of hoRegistry
77445>>>>>
77445>>>>>        If (sVersionDescription <> "") Begin
77447>>>>>           Send AppendTextLn (sVersionDescription * "-" * sVersion)
77448>>>>>           Send AppendTextLn ""
77449>>>>>        End
77449>>>>>>
77449>>>>>    End_Procedure
77450>>>>>    
77450>>>>>
77450>>>>>    Procedure Show_WorkspaceInformation
77452>>>>>        Integer hoWorkspace
77452>>>>>
77452>>>>>        If (ghoApplication <> 0) Begin
77454>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
77455>>>>>            If (hoWorkspace <> 0) Begin
77457>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self (Refproc (AppendTextLn))
77458>>>>>                Send AppendTextLn ""
77459>>>>>            End
77459>>>>>>
77459>>>>>        End
77459>>>>>>
77459>>>>>    End_Procedure
77460>>>>>
77460>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
77462>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
77463>>>>>    End_Function
77464>>>>>
77464>>>>>    Procedure Show_Versions
77466>>>>>        Integer iVersion iRevision iBuild
77466>>>>>
77466>>>>>        Version_Information iVersion iRevision iBuild
77468>>>>>
77468>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(Self,iVersion,iRevision,iBuild) ))
77469>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(Self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
77470>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(Self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
77471>>>>>    End_Procedure
77472>>>>>    
77472>>>>>    Function CKRevisionNumber String sDriverID Returns String
77474>>>>>        Handle hoCLIHandler
77474>>>>>        Handle hoDFBtrDrvHandler
77474>>>>>        String sCKRevision
77474>>>>>
77474>>>>>
77474>>>>>        If (sDriverID = "MSSQLDRV" or sDriverID = "ODBC_DRV" or sDriverID = "DB2_DRV") Begin
77476>>>>>            Get Create (RefClass(cCLIHandler)) to hoCLIHandler
77477>>>>>            Set psDriverID of hoCLIHandler to sDriverID
77478>>>>>            Move (CKRevision(hoCLIHandler)) to sCKRevision
77479>>>>>            Send Destroy of hoCLIHandler
77480>>>>>        End
77480>>>>>>
77480>>>>>        Else Begin
77481>>>>>            If (sDriverID = "DFBTRDRV") Begin
77483>>>>>                Get Create (RefClass(cDFBtrDrvHandler)) to hoDFBtrDrvHandler
77484>>>>>                Set psDriverID of hoDFBtrDrvHandler to sDriverID
77485>>>>>                Move (CKRevision(hoDFBtrDrvHandler)) to sCKRevision
77486>>>>>                Send Destroy of hoDFBtrDrvHandler
77487>>>>>            End
77487>>>>>>
77487>>>>>        End
77487>>>>>>
77487>>>>>        
77487>>>>>        Function_Return sCKRevision
77488>>>>>    End_Function
77489>>>>>    
77489>>>>>    
77489>>>>>    Function IsDataAccessCK String sDriverID Returns Boolean
77491>>>>>        
77491>>>>>        If (sDriverID = "DATAFLEX") Begin
77493>>>>>            Function_Return False
77494>>>>>        End
77494>>>>>>
77494>>>>>    
77494>>>>>        Function_Return (sDriverID = "MSSQLDRV" or sDriverID = "ODBC_DRV" or sDriverID = "DB2_DRV" or sDriverID = "DFBTRDRV")
77495>>>>>    End_Function    
77496>>>>>
77496>>>>>
77496>>>>>    //***
77496>>>>>    //*** BW
77496>>>>>    //*** Procedure: Show_Drivers
77496>>>>>    //*** Purpose  : Show loaded database drivers
77496>>>>>    //***
77496>>>>>
77496>>>>>    Procedure Show_Drivers
77498>>>>>        String sCurrentDriver sRevNumber
77498>>>>>        String sLoadedDrivers
77498>>>>>        Integer iNumberOfDrivers iCount
77498>>>>>        Boolean bOK
77498>>>>>
77498>>>>>        Move "" To sLoadedDrivers
77499>>>>>        Get_Attribute DF_NUMBER_DRIVERS To iNumberOfDrivers
77502>>>>>        For iCount From 1 To iNumberOfDrivers
77508>>>>>>
77508>>>>>            Get_Attribute DF_DRIVER_NAME Of iCount To sCurrentDriver
77511>>>>>            If (sLoadedDrivers <> "") Begin
77513>>>>>                Move (Append (sLoadedDrivers, ", ")) To sLoadedDrivers
77514>>>>>            End
77514>>>>>>
77514>>>>>            Get IsDataAccessCK sCurrentDriver to bOK
77515>>>>>            If (bOK) Begin
77517>>>>>                Get CKRevisionNumber sCurrentDriver to sRevNumber
77518>>>>>                Move (sCurrentDriver * "(" + sRevNumber + ")") to sCurrentDriver
77519>>>>>            End
77519>>>>>>
77519>>>>>            Move (Append (sLoadedDrivers, sCurrentDriver)) To sLoadedDrivers
77520>>>>>        Loop
77521>>>>>>
77521>>>>>        Send AppendTextLn (SFormat (C_$DatabaseDriver, sLoadedDrivers))
77522>>>>>    End_Procedure
77523>>>>>
77523>>>>>    Procedure Show_HelpFile
77525>>>>>        String sHelpFile
77525>>>>>        Integer eHelpType
77525>>>>>
77525>>>>>        If (ghoApplication <> 0) Begin
77527>>>>>            Get peHelpType Of ghoApplication To eHelpType
77528>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
77530>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
77531>>>>>            End
77531>>>>>>
77531>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
77534>>>>>                Get Help_filename Of Help_object_id To sHelpFile
77535>>>>>            End
77535>>>>>>
77535>>>>>            Else Begin
77536>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
77537>>>>>            End
77537>>>>>>
77537>>>>>
77537>>>>>            Send AppendTextLn ""
77538>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
77539>>>>>        End
77539>>>>>>
77539>>>>>    End_Procedure
77540>>>>>
77540>>>>>    Procedure Show_EnterAsTab
77542>>>>>        Boolean bEnterKeyAsTabKey
77542>>>>>        String sText
77542>>>>>
77542>>>>>        If (ghoApplication <> 0) Begin
77544>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
77545>>>>>            If (bEnterKeyAsTabKey) Begin
77547>>>>>                Move "True" To sText
77548>>>>>            End
77548>>>>>>
77548>>>>>            Else Begin
77549>>>>>                Move "False" To sText
77550>>>>>            End
77550>>>>>>
77550>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
77551>>>>>        End
77551>>>>>>
77551>>>>>    End_Procedure
77552>>>>>
77552>>>>>    //****************************************************************************
77552>>>>>    // $Module type: PROCEDURE
77552>>>>>    // $Module name: Add_Focus
77552>>>>>    // $Author     : VOO
77552>>>>>    // Created     : 24-09-96 @ 19:43
77552>>>>>    //
77552>>>>>    // Description
77552>>>>>    //    During activation we will remove the old information and add the newly
77552>>>>>    //    found systeminformation
77552>>>>>    //
77552>>>>>    // $Rev History
77552>>>>>    //    24-09-96  Module header created
77552>>>>>    //****************************************************************************
77552>>>>>    Procedure Add_Focus Integer hoRoot
77554>>>>>        Forward Send Add_Focus hoRoot
77556>>>>>
77556>>>>>        Send Delete_Data
77557>>>>>
77557>>>>>        Set Changed_State To False
77558>>>>>        Set Read_Only_State To True
77559>>>>>
77559>>>>>        Send Show_ServicePack
77560>>>>>        Send Show_Versions   
77561>>>>>        Send Show_Drivers         
77562>>>>>        Send Show_HelpFile
77563>>>>>        Send Show_Current_Directory
77564>>>>>        Send Show_Filelist_Name          
77565>>>>>        If (ghoApplication <> 0) Begin
77567>>>>>            Send Show_WorkSpaceInformation // added To show WS info
77568>>>>>        End
77568>>>>>>
77568>>>>>        Send Show_Current_User 
77569>>>>>        Send Show_Windows_Directory 
77570>>>>>        Send Show_Screen_Size
77571>>>>>        Send Show_Page_Size
77572>>>>>        Send Show_EnterAsTab        
77573>>>>>        Send Show_Number_Format
77574>>>>>        Send Show_Date_Format
77575>>>>>        Send Show_Lock_Delay
77576>>>>>        Send Show_Lock_Timeout
77577>>>>>        Send Show_Date
77578>>>>>        Send Show_Systemresources
77579>>>>>        Send Show_Registration
77580>>>>>        Send Beginning_of_Data
77581>>>>>
77581>>>>>        Set Icon to 'default.ico'
77582>>>>>    End_Procedure
77583>>>>>End_Class
77584>>>>>
77584>>>>>//****************************************************************************
77584>>>>>// $Module type: OBJECT
77584>>>>>// $Module name: Sysinfo_Dialog
77584>>>>>// $Author     : VOO
77584>>>>>// Created     : 24-09-96 @ 18:47
77584>>>>>//
77584>>>>>// Description
77584>>>>>//    This object shows the systeminformation on the screen
77584>>>>>//
77584>>>>>// $Rev History
77584>>>>>//    24-09-96  Module header created
77584>>>>>//****************************************************************************
77584>>>>>Class SysInfoDialog Is A ModalPanel
77585>>>>>    Procedure Construct_Object
77587>>>>>        Forward Send Construct_Object
77589>>>>>
77589>>>>>        Set Label to C_$SystemInformation
77590>>>>>        Set Size to 140 267
77591>>>>>        Set piMinSize to 140 267
77592>>>>>        Set Locate_Mode To CENTER_ON_SCREEN
77593>>>>>        Set Border_Style to Border_Thick
77594>>>>>
77594>>>>>        Object oSysinfoDisplay Is A SysInfoDisplay
77596>>>>>            Set peAnchors to anAll
77597>>>>>        End_Object
77598>>>>>
77598>>>>>        Object oCloseButton Is A Button
77600>>>>>            Set Label To C_$Close
77601>>>>>            Set Location To 120 210
77602>>>>>            Set Message Item 0 To (Refproc (Close_Panel))
77603>>>>>            Set Default_State To True
77604>>>>>            Set peAnchors to anBottomRight
77605>>>>>        End_Object
77606>>>>>
77606>>>>>        On_Key kCancel Send Close_Panel
77607>>>>>    End_Procedure
77608>>>>>End_Class
77609>>>>>
77609>>>>>// Purpose:
77609>>>>>//
77609>>>>>// Ken Ross 12/17/96 5:16PM
77609>>>>>//
77609>>>>>Class AboutDialog Is A ModalPanel
77610>>>>>    Procedure Construct_Object
77612>>>>>        String sVdfRootDir
77612>>>>>
77612>>>>>        Forward Send Construct_Object
77614>>>>>
77614>>>>>        Set Label To C_$About
77615>>>>>        Set Size to 89 212
77616>>>>>        Set Locate_Mode To CENTER_ON_SCREEN
77617>>>>>
77617>>>>>        Object oSysInfoDialog Is A SysInfoDialog
77619>>>>>        End_Object
77620>>>>>
77620>>>>>        Object oBox Is A Container3d
77622>>>>>            Set Border_Style To Border_StaticEdge
77623>>>>>            Set Size to 63 202
77624>>>>>            Set Location To 4 5
77625>>>>>
77625>>>>>            Object oAboutGraphic Is A BitmapContainer
77627>>>>>                Set Border_Style To Border_None
77628>>>>>                Set Bitmap_Style To Bitmap_Center
77629>>>>>                Set Size To 48 48
77630>>>>>                Set Location To 7 2
77631>>>>>            End_Object
77632>>>>>
77632>>>>>            Object oProductName Is A TextBox
77634>>>>>                Set Label To C_$ProductName
77635>>>>>                Set Size To 10 45
77636>>>>>                Set Location To 8 53
77637>>>>>            End_Object
77638>>>>>
77638>>>>>            Object oVersion Is A TextBox
77640>>>>>                Set Label To C_$Version
77641>>>>>                Set Size To 10 25
77642>>>>>                Set Location To 21 53
77643>>>>>            End_Object
77644>>>>>
77644>>>>>            Object oCopyright Is A TextBox
77646>>>>>                Set Label To C_$Copyright
77647>>>>>                Set Size To 10 31
77648>>>>>                Set Location To 34 53
77649>>>>>            End_Object
77650>>>>>
77650>>>>>            Object oAuthor Is A TextBox
77652>>>>>                Set Label To C_$Author
77653>>>>>                Set Size To 10 22
77654>>>>>                Set Location To 46 53
77655>>>>>            End_Object
77656>>>>>        End_Object
77657>>>>>
77657>>>>>        Object oOKButton Is A Button
77659>>>>>            On_Item C_$OK Send Close_Panel
77660>>>>>            Set Size To 14 50
77661>>>>>            Set Location To 71 157
77662>>>>>        End_Object
77663>>>>>
77663>>>>>        Object oSysInfoButton Is A Button
77665>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
77666>>>>>            Set Size To 14 50
77667>>>>>            Set Location To 71 101
77668>>>>>        End_Object
77669>>>>>
77669>>>>>        On_Key Kcancel Send KeyAction Of oOKButton
77670>>>>>
77670>>>>>        Set Logo To "DacAbout.bmp"  // square bitmaps Of 42x42 work best
77671>>>>>    End_Procedure
77672>>>>>
77672>>>>>    Procedure Set ProductName String sProductName
77674>>>>>        Set Label Of oProductName To sProductName
77675>>>>>    End_Procedure
77676>>>>>
77676>>>>>    Procedure Set Version String sVersion
77678>>>>>        Set Label Of oVersion To sVersion
77679>>>>>    End_Procedure
77680>>>>>
77680>>>>>    Procedure Set Copyright string sCopyright
77682>>>>>        Set Label Of oCopyright To sCopyright
77683>>>>>    End_Procedure
77684>>>>>
77684>>>>>    Procedure Set Author String sAuthor
77686>>>>>        Set Label Of oAuthor To sAuthor
77687>>>>>    End_Procedure
77688>>>>>
77688>>>>>    Procedure Set Logo string sLogo
77690>>>>>        // square bitmaps Of 42x42 work best
77690>>>>>        Set Bitmap Of oAboutGraphic To sLogo
77691>>>>>    End_Procedure
77692>>>>>
77692>>>>>    Procedure Show_Sysinfo
77694>>>>>        Send Popup_Modal Of oSysinfoDialog
77695>>>>>    End_Procedure
77696>>>>>
77696>>>>>    Procedure End_Construct_Object
77698>>>>>        Handle hoVersionInfo
77698>>>>>        Boolean bIncluded
77698>>>>>        Integer iMajor iMinor iRelease iBuild
77698>>>>>        String sLabel
77698>>>>>
77698>>>>>        Get Label Of oVersion To sLabel
77699>>>>>        If (sLabel = C_$VERSION) Begin
77701>>>>>            // set it To the version info Of the program, if available
77701>>>>>            If (ghoApplication <> 0) Begin
77703>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
77704>>>>>                If (hoVersionInfo <> 0) Begin
77706>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
77707>>>>>                    If (bIncluded) Begin
77709>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
77710>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
77711>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
77712>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
77713>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sLabel
77714>>>>>                        Set Version to sLabel
77715>>>>>                    End
77715>>>>>>
77715>>>>>                End
77715>>>>>>
77715>>>>>            End
77715>>>>>>
77715>>>>>        End
77715>>>>>>
77715>>>>>
77715>>>>>        Forward Send End_Construct_Object
77717>>>>>    End_Procedure
77718>>>>>End_Class
77719>>>
77719>>>// *************************************************************************
77719>>>//  Public message. This is the default message. It is expected that you will
77719>>>//   create your own message to override this
77719>>>// *************************************************************************
77719>>>
77719>>>Procedure Activate_About
77722>>>   Send DoAbout "" "" "" "" ""
77723>>>End_Procedure
77724>>>
77724>>>// *************************************************************************
77724>>>//  Public message. It is expected that you will send this message (most
77724>>>//  likely from Activate_About. This creates an about object, activates it
77724>>>//  and destroys it when done. It is not exepected that you will augment this.
77724>>>// *************************************************************************
77724>>>
77724>>>Procedure DoAbout string sTitle string sVersion string sCopyRight string sAuthor string sBitmap
77727>>>        integer hoObj hoMain
77727>>>
77727>>>        // create object
77727>>>        Object About is an AboutDialog
77729>>>            // if no title passed use the label of the main panel
77729>>>            // (if a main panel exists).
77729>>>            if sTitle     eq '' Begin
77731>>>                Get Main_Window of desktop to hoMain
77732>>>                if hoMain Get Label of hoMain to sTitle
77735>>>            end
77735>>>>
77735>>>            set productname to sTitle
77736>>>            set version     to sVersion
77737>>>            set copyright   to sCopyRight
77738>>>            set author      to sAuthor
77739>>>            If sBitmap    ne '' ;               set logo to sBitMap // square bitmaps of 42x42 work best
77742>>>            Move self to hoObj // object Id
77743>>>        End_Object
77744>>>        Send Popup   of hoObj    // popup the about object
77745>>>        Send Destroy of hoObj // when done, it will be destroyed
77746>>>End_procedure
77747>        Use RegistroEmpleado.vw
Including file: RegistroEmpleado.vw    (C:\DataFlex Projects\Control Marcajes\AppSrc\RegistroEmpleado.vw)
77747>>>Use Windows.pkg
77747>>>Use DFClient.pkg
77747>>>Use cNacionalidadDataDictionary.dd
Including file: cNacionalidadDataDictionary.dd    (C:\DataFlex Projects\Control Marcajes\DDSrc\cNacionalidadDataDictionary.dd)
77747>>>>>Use DataDict.pkg
77747>>>>>
77747>>>>>Open Nacionalidad
Including file: Nacionalidad.fd    (C:\DataFlex Projects\Control Marcajes\DDSrc\Nacionalidad.fd)
77749>>>>>Open Empleado
Including file: Empleado.fd    (C:\DataFlex Projects\Control Marcajes\DDSrc\Empleado.fd)
77751>>>>>Open Autoincrementable
Including file: Autoincrementable.fd    (C:\DataFlex Projects\Control Marcajes\DDSrc\Autoincrementable.fd)
77753>>>>>
77753>>>>>Register_Object ListadoNacionalidades
77753>>>>>
77753>>>>>Class cNacionalidadDataDictionary is a DataDictionary
77754>>>>>    
77754>>>>>    Procedure Construct_Object
77756>>>>>        Forward Send Construct_Object
77758>>>>>        Set Main_File to Nacionalidad.File_Number
77759>>>>>
77759>>>>>        Set Add_System_File to Autoincrementable.File_Number DD_Lock_On_All
77760>>>>>
77760>>>>>        Set Add_Client_File to Empleado.File_Number
77761>>>>>
77761>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_NOPUT to True
77762>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
77763>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
77764>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
77765>>>>>
77765>>>>>        Set Field_Option Field Nacionalidad.Numero DD_AUTOFIND to True
77766>>>>>        Set Key_Field_State Field Nacionalidad.Numero to True
77767>>>>>        Set Field_Auto_Increment Field Nacionalidad.Numero to File_Field Autoincrementable.NumNacionalidad
77768>>>>>
77768>>>>>        Set Field_Option Field Nacionalidad.Pais DD_AUTOFIND to True
77769>>>>>        Set Field_Option Field Nacionalidad.Pais DD_CAPSLOCK to True
77770>>>>>        Set Field_Option Field Nacionalidad.Pais DD_REQUIRED to True
77771>>>>>        
77771>>>>>
77771>>>>>    End_Procedure
77772>>>>>
77772>>>>>End_Class
77773>>>>>
77773>>>>>
77773>>>Use cEmpleadoDataDictionary.dd
Including file: cEmpleadoDataDictionary.dd    (C:\DataFlex Projects\Control Marcajes\DDSrc\cEmpleadoDataDictionary.dd)
77773>>>>>Use DataDict.pkg
77773>>>>>
77773>>>>>Open Empleado
77775>>>>>Open Nacionalidad
77777>>>>>Open Marcaje
Including file: Marcaje.fd    (C:\DataFlex Projects\Control Marcajes\DDSrc\Marcaje.fd)
77779>>>>>Open Autoincrementable
77781>>>>>
77781>>>>>Register_Object ListaEmpleado
77781>>>>>Register_Object ListaNacionalidad
77781>>>>>
77781>>>>>Class cEmpleadoDataDictionary is a DataDictionary
77782>>>>>    
77782>>>>>    Procedure Construct_Object
77784>>>>>        Forward Send Construct_Object
77786>>>>>        Set Main_File to Empleado.File_Number
77787>>>>>
77787>>>>>        Set Add_System_File to Autoincrementable.File_Number DD_Lock_On_All
77788>>>>>
77788>>>>>        Set Add_Client_File to Marcaje.File_Number
77789>>>>>
77789>>>>>        Set Add_Server_File to Nacionalidad.File_Number
77790>>>>>
77790>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_NOPUT to True
77791>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
77792>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
77793>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
77794>>>>>
77794>>>>>        Set Field_Option Field Empleado.Numero DD_AUTOFIND to True
77795>>>>>        Set Key_Field_State Field Empleado.Numero to True
77796>>>>>        Set Field_Auto_Increment Field Empleado.Numero to File_Field Autoincrementable.NumEmpleado
77797>>>>>        Set Field_Prompt_Object Field Empleado.Numero to ListaEmpleado
77798>>>>>
77798>>>>>        Set Field_Option Field Empleado.PrimerNombre DD_CAPSLOCK to True
77799>>>>>        Set Field_Option Field Empleado.PrimerNombre DD_REQUIRED to True
77800>>>>>        Set Field_Option Field Empleado.PrimerNombre DD_AUTOFIND to True
77801>>>>>
77801>>>>>        Set Field_Option Field Empleado.SegundoNombre DD_AUTOFIND to True
77802>>>>>        Set Field_Option Field Empleado.SegundoNombre DD_CAPSLOCK to True
77803>>>>>        Set Field_Option Field Empleado.SegundoNombre DD_REQUIRED to True
77804>>>>>
77804>>>>>        Set Field_Option Field Empleado.PrimerApellido DD_AUTOFIND to True
77805>>>>>        Set Field_Option Field Empleado.PrimerApellido DD_CAPSLOCK to True
77806>>>>>        Set Field_Option Field Empleado.PrimerApellido DD_REQUIRED to True
77807>>>>>
77807>>>>>        Set Field_Option Field Empleado.SegundoApellido DD_AUTOFIND to True
77808>>>>>        Set Field_Option Field Empleado.SegundoApellido DD_CAPSLOCK to True
77809>>>>>        Set Field_Option Field Empleado.SegundoApellido DD_REQUIRED to True
77810>>>>>
77810>>>>>         
77810>>>>>        Set Field_Option Field Empleado.Nacionalidad DD_AUTOFIND to True
77811>>>>>        Set Field_Prompt_Object Field Empleado.Nacionalidad to ListaNacionalidad
77812>>>>>        Set Field_Option Field Empleado.Nacionalidad DD_CAPSLOCK to True
77813>>>>>        Set Field_Option Field Empleado.Nacionalidad DD_REQUIRED to True
77814>>>>>        
77814>>>>>       
77814>>>>>        
77814>>>>>         
77814>>>>>
77814>>>>>    End_Procedure
77815>>>>>
77815>>>>>End_Class
77816>>>>>
77816>>>>>Use ListaNacionalidad.sl
Including file: ListaNacionalidad.sl    (C:\DataFlex Projects\Control Marcajes\AppSrc\ListaNacionalidad.sl)
77816>>>>>>>//**************************************************************
77816>>>>>>>// TableLookup.tpl for Windows application for Spanish 
77816>>>>>>>// translated by Moose Software (www.moose-software.com) 
77816>>>>>>>// 13/07/2010 Revised for VDF 16.0 by Moose Software
77816>>>>>>>// 05/02/2012 Revised for VDF 17.0 by Moose Software
77816>>>>>>>// 13/06/2013 Revised for VDF 17.1 by Moose Software
77816>>>>>>>// 02/05/2014 Revised for VDF 18.0 by Moose Software
77816>>>>>>>//*************************************************************
77816>>>>>>>
77816>>>>>>>Use Windows.pkg
77816>>>>>>>Use DFClient.pkg
77816>>>>>>>use DFSellst.pkg
77816>>>>>>>Use cNacionalidadDataDictionary.dd
77816>>>>>>>
77816>>>>>>>Object ListaNacionalidad is a dbModalPanel
77818>>>>>>>    Object oNacionalidad_DD is a cNacionalidadDataDictionary
77820>>>>>>>    End_Object
77821>>>>>>>
77821>>>>>>>    Set Main_DD to oNacionalidad_DD
77822>>>>>>>    Set Server to oNacionalidad_DD
77823>>>>>>>
77823>>>>>>>    Set Size to 133 184
77824>>>>>>>    Set Location     to 4 5
77825>>>>>>>    Set Border_Style to Border_Thick
77826>>>>>>>    Set Label to "Lista de Nacionalidades"
77827>>>>>>>    Set piMaxSize to 133 184
77828>>>>>>>    Set piMinSize to 133 184
77829>>>>>>>
77829>>>>>>>    Object oSelList is a dbList
77831>>>>>>>        Set peAnchors to anAll
77832>>>>>>>        Set Size to 105 172
77833>>>>>>>        Set Location to 5 5
77834>>>>>>>
77834>>>>>>>        Begin_Row
77837>>>>>>>            Entry_Item Nacionalidad.Numero
77838>>>>>>>            Entry_Item Nacionalidad.Pais
77839>>>>>>>        End_Row
77844>>>>>>>
77844>>>>>>>        Set Main_File to Nacionalidad.File_Number
77845>>>>>>>
77845>>>>>>>        Set Form_Width 0 to 60
77846>>>>>>>        Set Resize_Column_State to False
77847>>>>>>>        Set Header_Label 0 to "Numero"
77848>>>>>>>        Set Form_Width 1 to 100
77849>>>>>>>        Set Resize_Column_State to false
77850>>>>>>>        Set Header_Label 1 to "Pais"
77851>>>>>>>        
77851>>>>>>>    End_Object
77852>>>>>>>
77852>>>>>>>    Object oOK_bn is a Button
77854>>>>>>>        Set Label     to "&Aceptar"
77855>>>>>>>        Set Location to 115 20
77856>>>>>>>        Set peAnchors to anBottomRight
77857>>>>>>>
77857>>>>>>>        Procedure OnClick
77860>>>>>>>            Send Ok of oSelList
77861>>>>>>>        End_Procedure
77862>>>>>>>
77862>>>>>>>    End_Object
77863>>>>>>>
77863>>>>>>>    Object oCancel_bn is a Button
77865>>>>>>>        Set Label     to "&Cancelar"
77866>>>>>>>        Set Location to 115 74
77867>>>>>>>        Set peAnchors to anBottomRight
77868>>>>>>>
77868>>>>>>>        Procedure OnClick
77871>>>>>>>            Send Cancel of oSelList
77872>>>>>>>        End_Procedure
77873>>>>>>>
77873>>>>>>>    End_Object
77874>>>>>>>
77874>>>>>>>    Object oSearch_bn is a Button
77876>>>>>>>        Set Label     to "&Buscar..."
77877>>>>>>>        Set Location to 115 128
77878>>>>>>>        Set peAnchors to anBottomRight
77879>>>>>>>
77879>>>>>>>        Procedure OnClick
77882>>>>>>>            Send Search of oSelList
77883>>>>>>>        End_Procedure
77884>>>>>>>
77884>>>>>>>    End_Object
77885>>>>>>>
77885>>>>>>>    On_Key Key_Alt+Key_A Send KeyAction of oOk_bn
77886>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_bn
77887>>>>>>>    On_Key Key_Alt+Key_B Send KeyAction of oSearch_bn
77888>>>>>>>
77888>>>>>>>End_Object
77889>>>>>>>
77889>>>>>>>//*********************************************** end of TableLookup.tpl for Spanish ****************
77889>>>>>>>
77889>>>>>
77889>>>>>Use ListaEmpleado.sl
Including file: ListaEmpleado.sl    (C:\DataFlex Projects\Control Marcajes\AppSrc\ListaEmpleado.sl)
77889>>>>>>>//**************************************************************
77889>>>>>>>// TableLookup.tpl for Windows application for Spanish 
77889>>>>>>>// translated by Moose Software (www.moose-software.com) 
77889>>>>>>>// 13/07/2010 Revised for VDF 16.0 by Moose Software
77889>>>>>>>// 05/02/2012 Revised for VDF 17.0 by Moose Software
77889>>>>>>>// 13/06/2013 Revised for VDF 17.1 by Moose Software
77889>>>>>>>// 02/05/2014 Revised for VDF 18.0 by Moose Software
77889>>>>>>>//*************************************************************
77889>>>>>>>
77889>>>>>>>Use Windows.pkg
77889>>>>>>>Use DFClient.pkg
77889>>>>>>>use DFSellst.pkg
77889>>>>>>>Use cNacionalidadDataDictionary.dd
77889>>>>>>>Use cEmpleadoDataDictionary.dd
77889>>>>>>>
77889>>>>>>>Object ListaEmpleado is a dbModalPanel
77891>>>>>>>    Object oNacionalidad_DD is a cNacionalidadDataDictionary
77893>>>>>>>    End_Object
77894>>>>>>>
77894>>>>>>>    Object oEmpleado_DD is a cEmpleadoDataDictionary
77896>>>>>>>        Set DDO_Server to oNacionalidad_DD
77897>>>>>>>    End_Object
77898>>>>>>>
77898>>>>>>>    Set Main_DD to oEmpleado_DD
77899>>>>>>>    Set Server to oEmpleado_DD
77900>>>>>>>
77900>>>>>>>    Set Size to 131 251
77901>>>>>>>    Set Location to 5 5
77902>>>>>>>    Set Border_Style to Border_Thick
77903>>>>>>>    Set Label to "Lista de Empleado"
77904>>>>>>>
77904>>>>>>>    Object oSelList is a dbList
77906>>>>>>>        Set peAnchors to anAll
77907>>>>>>>        Set Size to 103 243
77908>>>>>>>        Set Location to 5 5
77909>>>>>>>
77909>>>>>>>        Begin_Row
77912>>>>>>>            Entry_Item Empleado.Numero
77913>>>>>>>            Entry_Item (Trim(Empleado.PrimerNombre) + '  ' + Trim(Empleado.SegundoNombre) + '  ' + Trim(Empleado.PrimerApellido) + '  ' + Trim(Empleado.SegundoApellido) )
77914>>>>>>>         //   Entry_Item Empleado.SegundoNombre
77914>>>>>>>         //   Entry_Item Empleado.PrimerApellido
77914>>>>>>>         //   Entry_Item Empleado.SegundoApellido
77914>>>>>>>            Entry_Item Nacionalidad.Pais
77915>>>>>>>        End_Row
77920>>>>>>>
77920>>>>>>>        Set Main_File to Empleado.File_Number
77921>>>>>>>
77921>>>>>>>        Set Form_Width 0 to 24
77922>>>>>>>        Set Resize_Column_State to False
77923>>>>>>>        Set Header_Label 0 to "#"
77924>>>>>>>        Set Form_Width 1 to 150
77925>>>>>>>        Set Resize_Column_State to False
77926>>>>>>>        Set Header_Label 1 to "Nombres y Apellidos"      
77927>>>>>>>   
77927>>>>>>>        Set Form_Width 5 to 60
77928>>>>>>>        Set Header_Label 5 to "Pais"
77929>>>>>>>    End_Object
77930>>>>>>>
77930>>>>>>>    Object oOK_bn is a Button
77932>>>>>>>        Set Label     to "&Aceptar"
77933>>>>>>>        Set Location to 113 87
77934>>>>>>>        Set peAnchors to anBottomRight
77935>>>>>>>
77935>>>>>>>        Procedure OnClick
77938>>>>>>>            Send Ok of oSelList
77939>>>>>>>        End_Procedure
77940>>>>>>>
77940>>>>>>>    End_Object
77941>>>>>>>
77941>>>>>>>    Object oCancel_bn is a Button
77943>>>>>>>        Set Label     to "&Cancelar"
77944>>>>>>>        Set Location to 113 141
77945>>>>>>>        Set peAnchors to anBottomRight
77946>>>>>>>
77946>>>>>>>        Procedure OnClick
77949>>>>>>>            Send Cancel of oSelList
77950>>>>>>>        End_Procedure
77951>>>>>>>
77951>>>>>>>    End_Object
77952>>>>>>>
77952>>>>>>>    Object oSearch_bn is a Button
77954>>>>>>>        Set Label     to "&Buscar..."
77955>>>>>>>        Set Location to 113 195
77956>>>>>>>        Set peAnchors to anBottomRight
77957>>>>>>>
77957>>>>>>>        Procedure OnClick
77960>>>>>>>            Send Search of oSelList
77961>>>>>>>        End_Procedure
77962>>>>>>>
77962>>>>>>>    End_Object
77963>>>>>>>
77963>>>>>>>    On_Key Key_Alt+Key_A Send KeyAction of oOk_bn
77964>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_bn
77965>>>>>>>    On_Key Key_Alt+Key_B Send KeyAction of oSearch_bn
77966>>>>>>>
77966>>>>>>>End_Object
77967>>>>>>>
77967>>>>>>>//*********************************************** end of TableLookup.tpl for Spanish ****************
77967>>>>>>>
77967>>>Use DFEntry.pkg
77967>>>Use cDbCJGrid.pkg
77967>>>Use cdbCJGridColumn.pkg
77967>>>Use cDbCJGridColumnSuggestion.pkg
Including file: cDbCJGridColumnSuggestion.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cDbCJGridColumnSuggestion.pkg)
77967>>>>>Use WinSuggestion.pkg
Including file: WinSuggestion.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\WinSuggestion.pkg)
77967>>>>>>>// 
77967>>>>>>>
77967>>>>>>>Use Windows.pkg
77967>>>>>>>Use tWinStructs.pkg
77967>>>>>>>Use tSuggestion.pkg
Including file: tSuggestion.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\tSuggestion.pkg)
77967>>>>>>>>>// struct used for suggestion forms, representing an item of data
77967>>>>>>>>>Enum_List 
77967>>>>>>>>>    Define smFind
77967>>>>>>>>>    Define smValidationTable
77967>>>>>>>>>    Define smCustom
77967>>>>>>>>>End_Enum_List
77967>>>>>>>>>
77967>>>>>>>>>Struct tSuggestion
77967>>>>>>>>>    String sRowId
77967>>>>>>>>>    String[] aValues
77967>>>>>>>>>End_Struct
77967>>>>>>>>>
77967>>>>>>>Use cTimer.pkg
Including file: cTimer.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cTimer.pkg)
77967>>>>>>>>>// cTimer class
77967>>>>>>>>>//
77967>>>>>>>>>// This supercedes the DFTimer class. 
77967>>>>>>>>>// It is simpler and more flexible
77967>>>>>>>>>
77967>>>>>>>>>Use Dftimer.pkg // we still use the Timer Manager classes and global objects
Including file: Dftimer.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\Dftimer.pkg)
77967>>>>>>>>>>>//************************************************************************
77967>>>>>>>>>>>//--- DFTimer   Timer package for DataFlex programs
77967>>>>>>>>>>>//
77967>>>>>>>>>>>// Copyright (c) 1983-2002 Data Access Corporation, Miami Florida,
77967>>>>>>>>>>>// All rights reserved.
77967>>>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
77967>>>>>>>>>>>//
77967>>>>>>>>>>>//************************************************************************
77967>>>>>>>>>>>//  Description:
77967>>>>>>>>>>>//      This package contains all components needed to implement timers
77967>>>>>>>>>>>//      in a DataFlex 4 program.
77967>>>>>>>>>>>//
77967>>>>>>>>>>>//
77967>>>>>>>>>>>//  Author: Eddy Kleinjan, Data Access Nederland
77967>>>>>>>>>>>//************************************************************************
77967>>>>>>>>>>>// 03/03/2001 EK  Fixed Timer_Active_State to check for valid windows
77967>>>>>>>>>>>//                handle before trying to set or kill a timer.
77967>>>>>>>>>>>//                Fixed Kill_All_Timers to check for valid windows
77967>>>>>>>>>>>//                handle before trying to kill a timer.
77967>>>>>>>>>>>//                The windows handle might not exist anymore when the
77967>>>>>>>>>>>//                program is being exited using Exit_Application.
77967>>>>>>>>>>>// 12/13/2001 JJT fixed Timer_Active_State to check for -1 (not 0). Fixed a
77967>>>>>>>>>>>//                a bug where set Timeout started inactive timers.
77967>>>>>>>>>>>//                Added code to force timer object to desktop
77967>>>>>>>>>>>//************************************************************************
77967>>>>>>>>>>>// CLASS DFTimer
77967>>>>>>>>>>>//
77967>>>>>>>>>>>// Usage:
77967>>>>>>>>>>>//    Object MyTimer is a DFTimer
77967>>>>>>>>>>>//
77967>>>>>>>>>>>//        Set Timeout to 2000                             // Default 1000
77967>>>>>>>>>>>//        Set Auto_Start_State to TRUE|FALSE              // Default TRUE
77967>>>>>>>>>>>//        Set Auto_Stop_State to TRUE|FALSE               // Default TRUE
77967>>>>>>>>>>>//        Set Timer_Message to MyMessage                  // Default 0
77967>>>>>>>>>>>//        Set Timer_Object to (MyObject(self))            // Default 0
77967>>>>>>>>>>>//        Set Timer_Active_State to TRUE|FALSE            // Default FALSE
77967>>>>>>>>>>>//
77967>>>>>>>>>>>//        // Augment when no Timer_Message
77967>>>>>>>>>>>//        Procedure OnTimer
77967>>>>>>>>>>>//            Send Info_Box "HEY, WAKE UP!"
77967>>>>>>>>>>>//        End_Procedure
77967>>>>>>>>>>>//
77967>>>>>>>>>>>//    End_Object
77967>>>>>>>>>>>//
77967>>>>>>>>>>>// DESCRIPTION
77967>>>>>>>>>>>//      Objects of this class can be used to trigger an event after a
77967>>>>>>>>>>>//      certain amount of time has passed. You can specify this time
77967>>>>>>>>>>>//      by setting the Timeout property of the object. This timeout
77967>>>>>>>>>>>//      is in miliseconds.
77967>>>>>>>>>>>//
77967>>>>>>>>>>>//      Whenever a timer event happens, it will notify the object by
77967>>>>>>>>>>>//      sending an OnTimer event. You can trap this event to do whatever
77967>>>>>>>>>>>//      you want the timer to do. By default this OnTimer event
77967>>>>>>>>>>>//      will send the Timer_Message to Timer_Object, when these have
77967>>>>>>>>>>>//      been specified.
77967>>>>>>>>>>>//
77967>>>>>>>>>>>//      By default, you have to activate a timer by setting its
77967>>>>>>>>>>>//      Timer_Active_State to TRUE. When the timer has been placed
77967>>>>>>>>>>>//      inside a user-interface object, it can also be activated
77967>>>>>>>>>>>//      automatically when this user-interface object is being
77967>>>>>>>>>>>//      activated. This only happes when it Auto_Start_State is TRUE,
77967>>>>>>>>>>>//      which is the default setting. In such a case, the timer will
77967>>>>>>>>>>>//      also automatically being stopped when the user-interface
77967>>>>>>>>>>>//      object is taken of the screen. This depends on the
77967>>>>>>>>>>>//      Auto_Stop_Timer state to happen.
77967>>>>>>>>>>>//
77967>>>>>>>>>>>//      When you need to set a new timeout value, you can do so
77967>>>>>>>>>>>//      even when the timer is active. It will adjust the timeout
77967>>>>>>>>>>>//      immediately.
77967>>>>>>>>>>>//
77967>>>>>>>>>>>//      Note that timer events depend on Windows for the delivery of
77967>>>>>>>>>>>//      the event. Since timer events get a low priority in Windows,
77967>>>>>>>>>>>//      it might put your program on hold when other programs are very
77967>>>>>>>>>>>//      busy. In such a case, you will only receive one timer event
77967>>>>>>>>>>>//      after the process stopped. There is no way, other than
77967>>>>>>>>>>>//      calculating it yourself, to determine how many time has passed
77967>>>>>>>>>>>//      or how many timer event should have happened since the last
77967>>>>>>>>>>>//      timer event or timer activation.
77967>>>>>>>>>>>//
77967>>>>>>>>>>>// PUBLIC INTERFACE
77967>>>>>>>>>>>//
77967>>>>>>>>>>>//    PROPERTIES
77967>>>>>>>>>>>//
77967>>>>>>>>>>>//    Auto_Start_State When TRUE (default) the timer will be activated
77967>>>>>>>>>>>//                     automatically when the object will be (virtually)
77967>>>>>>>>>>>//                     paged on the screen.
77967>>>>>>>>>>>//                     Example: When a timer object has been placed
77967>>>>>>>>>>>//                     inside a view, then the timer will be activated
77967>>>>>>>>>>>//                     when the view is activated.
77967>>>>>>>>>>>//
77967>>>>>>>>>>>//    Auto_Stop_State  When TRUE (default) the timer will be deactivated
77967>>>>>>>>>>>//                     automatically when the object will be (virtually)
77967>>>>>>>>>>>//                     taken off the screen.
77967>>>>>>>>>>>//
77967>>>>>>>>>>>//    Timeout          The timeout value for the timer to fire. The
77967>>>>>>>>>>>//                     timeout value must be set in miliseconds.
77967>>>>>>>>>>>//                     This property may be set even when the timer is
77967>>>>>>>>>>>//                     active. The new timeout value will be applied
77967>>>>>>>>>>>//                     immediately.
77967>>>>>>>>>>>//                     NOTE: The timeout set here is never precise. It
77967>>>>>>>>>>>//                     depends on Windows to deliver the message to our
77967>>>>>>>>>>>//                     application.
77967>>>>>>>>>>>//                     Default 1000.
77967>>>>>>>>>>>//
77967>>>>>>>>>>>//    Timer_Active_State
77967>>>>>>>>>>>//                     Set to TRUE to activate the timer, to FALSE to
77967>>>>>>>>>>>//                     deactivate the timer.
77967>>>>>>>>>>>//
77967>>>>>>>>>>>//
77967>>>>>>>>>>>//    Timer_Message    This property can be set to a messageID which has
77967>>>>>>>>>>>//                     to be sent whenever a timer event occurs. Default
77967>>>>>>>>>>>//                     this message will be send to the object itself
77967>>>>>>>>>>>//                     unless a Timer_Object as been specified.
77967>>>>>>>>>>>//
77967>>>>>>>>>>>//    Timer_Object     This property can be set to an objectID which has
77967>>>>>>>>>>>//                     to receive the Timer_Message whenever a timer
77967>>>>>>>>>>>//                     event occurs. This value has no meaning when
77967>>>>>>>>>>>//                     no Timer_Message has been set.
77967>>>>>>>>>>>//
77967>>>>>>>>>>>//    METHODS
77967>>>>>>>>>>>//
77967>>>>>>>>>>>//    OnTimer          This event will happen whenever the specified
77967>>>>>>>>>>>//                     amount of time has passed and the timer is
77967>>>>>>>>>>>//                     active. By default it sends the message in
77967>>>>>>>>>>>//                     the Timer_Message property to the object in
77967>>>>>>>>>>>//                     the Timer_Object when these have been specified.
77967>>>>>>>>>>>//                     When you don't need this, you can just override
77967>>>>>>>>>>>//                     the OnTimer event.
77967>>>>>>>>>>>//
77967>>>>>>>>>>>// PUBLIC INTERFACE
77967>>>>>>>>>>>//
77967>>>>>>>>>>>//    Page_Object      Has been augmented to auto_start the timer when
77967>>>>>>>>>>>//                     it becomes active as part or a user-interface
77967>>>>>>>>>>>//                     object.
77967>>>>>>>>>>>//
77967>>>>>>>>>>>//    Page_Delete      Has been augmented to auto_stop the timer when
77967>>>>>>>>>>>//                     it is deactivated as part or a user-interface
77967>>>>>>>>>>>//                     object.
77967>>>>>>>>>>>//
77967>>>>>>>>>>>//    Destroy_Object   Has been augmented to deactivate the timer.
77967>>>>>>>>>>>//
77967>>>>>>>>>>>Use LanguageText.pkg
77967>>>>>>>>>>>Use Windows.pkg
77967>>>>>>>>>>>Use WinUser.pkg
77967>>>>>>>>>>>
77967>>>>>>>>>>>External_Function SetTimer "SetTimer" User32.DLL ;    Integer hWnd ;    Integer idTimer ;    Integer idTimeout ;    Pointer tmprc ;    Returns Integer
77968>>>>>>>>>>>
77968>>>>>>>>>>>External_Function KillTimer "KillTimer" User32.DLL ;    Integer hWnd ;    Integer idTimer ;    Returns Integer
77969>>>>>>>>>>>
77969>>>>>>>>>>>// This global integer holds the ID of the object
77969>>>>>>>>>>>// that manages all timers.
77969>>>>>>>>>>>Integer giTimerManager
77969>>>>>>>>>>>
77969>>>>>>>>>>>// This class is used to store the object IDs
77969>>>>>>>>>>>// of the active timer objects. It augments
77969>>>>>>>>>>>// the Destroy_Object procedure to notify
77969>>>>>>>>>>>// the DFTimerManager to kill all its active
77969>>>>>>>>>>>// timers.
77969>>>>>>>>>>>// NOTE: This class looks very much like the
77969>>>>>>>>>>>// Set class. I didn't want to use Set because
77969>>>>>>>>>>>// Remove_Element shifts items which I don't
77969>>>>>>>>>>>// want to happen because item numbers are used
77969>>>>>>>>>>>// as timerIDs.
77969>>>>>>>>>>>
77969>>>>>>>>>>>Class TimersArray is an Array
77970>>>>>>>>>>>
77970>>>>>>>>>>>    Function Find_Object Integer iObj Returns Integer
77972>>>>>>>>>>>        Integer iMax
77972>>>>>>>>>>>        Integer iItem
77972>>>>>>>>>>>        Integer iValue
77972>>>>>>>>>>>        Get Item_count to iMax
77973>>>>>>>>>>>        Decrement iMax
77974>>>>>>>>>>>        For iItem from 1 to iMax
77980>>>>>>>>>>>>
77980>>>>>>>>>>>            Get Integer_Value item iItem to iValue
77981>>>>>>>>>>>            If iValue EQ iObj;                Function_Return iItem
77984>>>>>>>>>>>        Loop
77985>>>>>>>>>>>>
77985>>>>>>>>>>>        Function_Return -1
77986>>>>>>>>>>>    End_Function
77987>>>>>>>>>>>
77987>>>>>>>>>>>    Procedure Add_Object Integer iObj Returns Integer
77989>>>>>>>>>>>        Integer iItem
77989>>>>>>>>>>>        Get Find_Object iObj to iItem
77990>>>>>>>>>>>        If iItem LT 0 Begin
77992>>>>>>>>>>>            Get Find_Object 0 to iItem
77993>>>>>>>>>>>            If iItem LT 0 ;                Get Item_Count to iItem
77996>>>>>>>>>>>        End
77996>>>>>>>>>>>>
77996>>>>>>>>>>>        Set Array_Value item iItem to iObj
77997>>>>>>>>>>>        Procedure_Return iItem
77998>>>>>>>>>>>    End_Procedure
77999>>>>>>>>>>>
77999>>>>>>>>>>>    Procedure Remove_Object Integer iObj
78001>>>>>>>>>>>        Integer iItem
78001>>>>>>>>>>>        Get Find_Object iObj to iItem
78002>>>>>>>>>>>        If iItem GT 0 ;            Set Array_Value item iItem to 0
78005>>>>>>>>>>>    End_Procedure
78006>>>>>>>>>>>
78006>>>>>>>>>>>    Procedure Destroy_Object
78008>>>>>>>>>>>        Delegate Send Kill_All_Timers
78010>>>>>>>>>>>        Forward Send Destroy_Object
78012>>>>>>>>>>>    End_Procedure
78013>>>>>>>>>>>
78013>>>>>>>>>>>End_Class // TimersArray
78014>>>>>>>>>>>
78014>>>>>>>>>>>// This class is the actual timer manager
78014>>>>>>>>>>>// A timer will be created when Message Set_Timer_Active_State
78014>>>>>>>>>>>// has been send. This message needs two arguments. The first
78014>>>>>>>>>>>// is the objectID of the object to receive the timer event,
78014>>>>>>>>>>>// and the second is state. The object which ID has been passed,
78014>>>>>>>>>>>// needs to have a Timeout property to return the timeout for the
78014>>>>>>>>>>>// timer and it also needs to handle the MSG_OnTimer whenever a
78014>>>>>>>>>>>// timer event occurs.
78014>>>>>>>>>>>// The objectID of the Object will be placed in an array which contains
78014>>>>>>>>>>>// the objectIDs of all active timers. The Windows timer ID of a timer
78014>>>>>>>>>>>// is the itemnumber of the object in the array.
78014>>>>>>>>>>>//
78014>>>>>>>>>>>Class DFTimerManager is a DfBaseControl
78015>>>>>>>>>>>
78015>>>>>>>>>>>    Procedure Construct_Object
78017>>>>>>>>>>>
78017>>>>>>>>>>>        Forward Send Construct_Object
78019>>>>>>>>>>>
78019>>>>>>>>>>>        Set Visible_State to FALSE
78020>>>>>>>>>>>
78020>>>>>>>>>>>        Set External_Class_Name "cVdfTimer" to "static"
78021>>>>>>>>>>>        Set External_Message WM_TIMER to OnTimer
78022>>>>>>>>>>>
78022>>>>>>>>>>>        Object TimersArray is a TimersArray
78024>>>>>>>>>>>            Set Array_Value item 0 to -9999 // So we don't use item 0
78025>>>>>>>>>>>        End_Object
78026>>>>>>>>>>>
78026>>>>>>>>>>>        Move self to giTimerManager
78027>>>>>>>>>>>
78027>>>>>>>>>>>    End_Procedure
78028>>>>>>>>>>>
78028>>>>>>>>>>>    Procedure Set Timer_Active_State Integer iObj Integer iState
78030>>>>>>>>>>>        Integer iTimerID
78030>>>>>>>>>>>        Integer iTimeout
78030>>>>>>>>>>>        Integer iResult
78030>>>>>>>>>>>        Integer iSet
78030>>>>>>>>>>>        Dword   nResult
78030>>>>>>>>>>>        Handle  hWnd
78030>>>>>>>>>>>
78030>>>>>>>>>>>        // Get the handle of this object
78030>>>>>>>>>>>        Get Window_Handle to hWnd
78031>>>>>>>>>>>        If (Not(hWnd)) Begin
78033>>>>>>>>>>>            Error DFERR_DFTIMER C_$TimerNoHandle
78034>>>>>>>>>>>>
78034>>>>>>>>>>>            Procedure_Return
78035>>>>>>>>>>>        End
78035>>>>>>>>>>>>
78035>>>>>>>>>>>
78035>>>>>>>>>>>        // Test if handle is valid. If not, we leave.
78035>>>>>>>>>>>        If (Not(IsWindow(hWnd))) ;            Procedure_Return
78038>>>>>>>>>>>
78038>>>>>>>>>>>        Move (TimersArray(self)) to iSet
78039>>>>>>>>>>>
78039>>>>>>>>>>>        If (iSet) Begin
78041>>>>>>>>>>>
78041>>>>>>>>>>>            // Let's create or modify a timer
78041>>>>>>>>>>>            If iState Begin
78043>>>>>>>>>>>
78043>>>>>>>>>>>                // Get the exising to new TimerID
78043>>>>>>>>>>>                Get MSG_Add_Object of iSet iObj to iTimerID
78044>>>>>>>>>>>
78044>>>>>>>>>>>                // Set/Modify the timer
78044>>>>>>>>>>>                Get Timeout of iObj to iTimeout
78045>>>>>>>>>>>                Move (SetTimer(hWnd, iTimerID, iTimeout, 0)) to iResult
78046>>>>>>>>>>>                If Not iResult Begin
78048>>>>>>>>>>>                    Error DFERR_DFTIMER C_$TooManyTimers
78049>>>>>>>>>>>>
78049>>>>>>>>>>>                    Procedure_Return
78050>>>>>>>>>>>                End
78050>>>>>>>>>>>>
78050>>>>>>>>>>>
78050>>>>>>>>>>>            End
78050>>>>>>>>>>>>
78050>>>>>>>>>>>
78050>>>>>>>>>>>            // Let's kill an existing timer
78050>>>>>>>>>>>            Else Begin
78051>>>>>>>>>>>
78051>>>>>>>>>>>                // Look up the object in the set
78051>>>>>>>>>>>                Get Find_Object of iSet iObj to iTimerID
78052>>>>>>>>>>>
78052>>>>>>>>>>>                If iTimerID EQ -1 ;                    Procedure_Return
78055>>>>>>>>>>>
78055>>>>>>>>>>>                // Kill the timer
78055>>>>>>>>>>>                Move (KillTimer(hWnd, iTimerID)) to iResult
78056>>>>>>>>>>>                If Not iResult Begin
78058>>>>>>>>>>>                    Move (GetLastError()) to nResult
78059>>>>>>>>>>>                    Error DFERR_DFTIMER (C_$CantKillTimer * string(nResult) - "!")
78060>>>>>>>>>>>>
78060>>>>>>>>>>>                    Procedure_Return
78061>>>>>>>>>>>                End
78061>>>>>>>>>>>>
78061>>>>>>>>>>>
78061>>>>>>>>>>>                // Remove the objectID
78061>>>>>>>>>>>                Send Remove_Object to iSet iObj
78062>>>>>>>>>>>            End
78062>>>>>>>>>>>>
78062>>>>>>>>>>>        End
78062>>>>>>>>>>>>
78062>>>>>>>>>>>    End_Procedure
78063>>>>>>>>>>>
78063>>>>>>>>>>>    Function Timer_Active_State Integer iObj Returns Integer
78065>>>>>>>>>>>        Integer iResult
78065>>>>>>>>>>>        Get Find_Object of (TimersArray(self)) iObj to iResult
78066>>>>>>>>>>>        Function_Return (iResult<>-1) // note: -1= not found
78067>>>>>>>>>>>    End_Function
78068>>>>>>>>>>>
78068>>>>>>>>>>>    // Will be called by the Set when it is being destroyed.
78068>>>>>>>>>>>    Procedure Kill_All_Timers
78070>>>>>>>>>>>        Integer iMax
78070>>>>>>>>>>>        Integer iSet
78070>>>>>>>>>>>        Integer iItem
78070>>>>>>>>>>>        Integer iObj
78070>>>>>>>>>>>        Integer iResult
78070>>>>>>>>>>>        Handle  hWnd
78070>>>>>>>>>>>
78070>>>>>>>>>>>        // Get the handle of this object
78070>>>>>>>>>>>        Get Window_Handle to hWnd
78071>>>>>>>>>>>        If (Not(hWnd)) Begin
78073>>>>>>>>>>>            Error DFERR_DFTIMER C_$TimerNoHandle
78074>>>>>>>>>>>>
78074>>>>>>>>>>>            Procedure_Return
78075>>>>>>>>>>>        End
78075>>>>>>>>>>>>
78075>>>>>>>>>>>
78075>>>>>>>>>>>        // If the window handle is no longer valid, we
78075>>>>>>>>>>>        // leave this procedure. This can happen when the
78075>>>>>>>>>>>        // program is begin aborted using Exit_Application
78075>>>>>>>>>>>        If (Not(IsWindow(hWnd))) ;            Procedure_Return
78078>>>>>>>>>>>
78078>>>>>>>>>>>        // Scan the set and kill all known timers
78078>>>>>>>>>>>        Move (TimersArray(self)) to iSet
78079>>>>>>>>>>>        If (iSet) Begin
78081>>>>>>>>>>>            Get Item_Count of iSet to iMax
78082>>>>>>>>>>>            Decrement iMax
78083>>>>>>>>>>>            For iItem From 1 to iMax
78089>>>>>>>>>>>>
78089>>>>>>>>>>>                Get Integer_Value of iSet item iItem to iObj
78090>>>>>>>>>>>                If iObj Begin
78092>>>>>>>>>>>                    Move (KillTimer(hWnd, iItem)) to iResult
78093>>>>>>>>>>>                    Set Array_Value of iSet item iItem to 0
78094>>>>>>>>>>>                End
78094>>>>>>>>>>>>
78094>>>>>>>>>>>            Loop
78095>>>>>>>>>>>>
78095>>>>>>>>>>>        End
78095>>>>>>>>>>>>
78095>>>>>>>>>>>
78095>>>>>>>>>>>    End_Procedure
78096>>>>>>>>>>>
78096>>>>>>>>>>>    Procedure OnTimer Integer wParam Integer lParam
78098>>>>>>>>>>>        Integer iObj
78098>>>>>>>>>>>        Get Integer_Value of (TimersArray(self)) item wParam to iObj
78099>>>>>>>>>>>        If Not iObj Begin
78101>>>>>>>>>>>            Error DFERR_DFTIMER C_$TimerWithoutObject
78102>>>>>>>>>>>>
78102>>>>>>>>>>>            Procedure_Return
78103>>>>>>>>>>>        End
78103>>>>>>>>>>>>
78103>>>>>>>>>>>        Send OnTimer to iObj wParam lParam
78104>>>>>>>>>>>    End_Procedure
78105>>>>>>>>>>>
78105>>>>>>>>>>>    Procedure Destroy_Object
78107>>>>>>>>>>>        Send Kill_All_Timers
78108>>>>>>>>>>>        Forward Send Destroy_Object
78110>>>>>>>>>>>        Move 0 to giTimerManager
78111>>>>>>>>>>>    End_Procedure
78112>>>>>>>>>>>
78112>>>>>>>>>>>End_Class // DFTimerManger
78113>>>>>>>>>>>
78113>>>>>>>>>>>
78113>>>>>>>>>>>
78113>>>>>>>>>>>
78113>>>>>>>>>>>// This class acts as a container for the
78113>>>>>>>>>>>// timer manager object. This is needed because
78113>>>>>>>>>>>// A DFTimerManager object created directly at the
78113>>>>>>>>>>>// desktop doesn't have a Window_Handle which we
78113>>>>>>>>>>>// need to create a Windoows timer. By placing
78113>>>>>>>>>>>// this non-visual container around the timer
78113>>>>>>>>>>>// manager, it does get a Window_Handle.
78113>>>>>>>>>>>// The procedure End_Construct_Object has been
78113>>>>>>>>>>>// augmented to create a window and also
78113>>>>>>>>>>>// automatically page all children, which will
78113>>>>>>>>>>>// be the timer manager.
78113>>>>>>>>>>>//
78113>>>>>>>>>>>Class DFTimerManagerPanel is a dfBasePanel
78114>>>>>>>>>>>
78114>>>>>>>>>>>    Procedure Construct_Object
78116>>>>>>>>>>>        Forward Send Construct_Object
78118>>>>>>>>>>>        Set Visible_State to FALSE
78119>>>>>>>>>>>        Object DFTimerManager is a DFTimerManager
78121>>>>>>>>>>>        End_Object
78122>>>>>>>>>>>    End_Procedure
78123>>>>>>>>>>>
78123>>>>>>>>>>>    Procedure End_Construct_Object
78125>>>>>>>>>>>        Forward Send End_Construct_Object
78127>>>>>>>>>>>        Send Page_Object TRUE
78128>>>>>>>>>>>        Broadcast Send Page_Object TRUE
78130>>>>>>>>>>>    End_Procedure
78131>>>>>>>>>>>
78131>>>>>>>>>>>End_Class
78132>>>>>>>>>>>
78132>>>>>>>>>>>// This is the class the user uses to create DFTimer objects
78132>>>>>>>>>>>
78132>>>>>>>>>>>
78132>>>>>>>>>>>//{ OverrideProperty=Skip_State DesignTime=False }
78132>>>>>>>>>>>//{ OverrideProperty=TypeFace DesignTime=False }
78132>>>>>>>>>>>Class DFTimer is a Textbox
78133>>>>>>>>>>>
78133>>>>>>>>>>>    Procedure Construct_Object
78135>>>>>>>>>>>        Forward Send Construct_Object
78137>>>>>>>>>>>
78137>>>>>>>>>>>        // Make sure this object never appears
78137>>>>>>>>>>>        Set Visible_State to FALSE
78138>>>>>>>>>>>
78138>>>>>>>>>>>        Property Integer Private.Timeout    1000
78139>>>>>>>>>>>
78139>>>>>>>>>>>        Property Integer Timer_Message      0
78140>>>>>>>>>>>        Property Integer Timer_Object       0
78141>>>>>>>>>>>        Property Integer Auto_Start_State   True
78142>>>>>>>>>>>        Property Integer Auto_Stop_State    True
78143>>>>>>>>>>>    End_Procedure
78144>>>>>>>>>>>
78144>>>>>>>>>>>    Procedure Set Timer_Active_State Integer iState
78146>>>>>>>>>>>        Integer iObj
78146>>>>>>>>>>>        Move self to iObj
78147>>>>>>>>>>>        If giTimerManager ;            Set Timer_Active_State of giTimerManager iObj to iState
78150>>>>>>>>>>>    End_Procedure
78151>>>>>>>>>>>
78151>>>>>>>>>>>    Function Timer_Active_State Returns Integer
78153>>>>>>>>>>>        Integer iState
78153>>>>>>>>>>>        Integer iObj
78153>>>>>>>>>>>        Move self to iObj
78154>>>>>>>>>>>        If giTimerManager ;            Get Timer_Active_State of giTimerManager iObj to iState
78157>>>>>>>>>>>        Function_Return iState
78158>>>>>>>>>>>    End_Function
78159>>>>>>>>>>>
78159>>>>>>>>>>>    Procedure Set Timeout Integer iTimeout
78161>>>>>>>>>>>        Integer iActive
78161>>>>>>>>>>>        Set Private.Timeout to iTimeout
78162>>>>>>>>>>>        Get Timer_Active_State to iActive
78163>>>>>>>>>>>        If iActive ;            Set Timer_Active_State to TRUE
78166>>>>>>>>>>>    End_Procedure
78167>>>>>>>>>>>
78167>>>>>>>>>>>    Function Timeout Returns Integer
78169>>>>>>>>>>>        Integer iTimeout
78169>>>>>>>>>>>        Get Private.Timeout to iTimeout
78170>>>>>>>>>>>        Function_Return iTimeout
78171>>>>>>>>>>>    End_Function
78172>>>>>>>>>>>
78172>>>>>>>>>>>    Procedure OnTimer Integer iwParam Integer ilParam
78174>>>>>>>>>>>        Integer iMsg
78174>>>>>>>>>>>        Integer iObj
78174>>>>>>>>>>>        Get Timer_Message to iMsg
78175>>>>>>>>>>>        If (iMsg) Begin
78177>>>>>>>>>>>            Get Timer_Object  to iObj
78178>>>>>>>>>>>            If iObj ;                Send iMsg to iObj iwParam ilParam
78181>>>>>>>>>>>            Else ;                Send iMsg iwParam ilParam
78183>>>>>>>>>>>        End
78183>>>>>>>>>>>>
78183>>>>>>>>>>>    End_Procedure
78184>>>>>>>>>>>
78184>>>>>>>>>>>    // Augmented to Auto_Start a timer
78184>>>>>>>>>>>    //
78184>>>>>>>>>>>    Procedure Page_Object Integer iState
78186>>>>>>>>>>>        Forward Send Page_Object iState
78188>>>>>>>>>>>        If (iState AND Auto_Start_State(self)) ;            Set Timer_Active_State to TRUE
78191>>>>>>>>>>>    End_Procedure
78192>>>>>>>>>>>
78192>>>>>>>>>>>    // Augmented to Auto_Stop a timer
78192>>>>>>>>>>>    //
78192>>>>>>>>>>>    Procedure Page_Delete
78194>>>>>>>>>>>        If (Auto_Stop_State(self)) ;            Set Timer_Active_State to FALSE
78197>>>>>>>>>>>        Forward Send Page_Delete
78199>>>>>>>>>>>    End_Procedure
78200>>>>>>>>>>>
78200>>>>>>>>>>>    // Augmented to stop the timer
78200>>>>>>>>>>>    //
78200>>>>>>>>>>>    Procedure Destroy_Object
78202>>>>>>>>>>>        Set Timer_Active_State to FALSE
78203>>>>>>>>>>>        Forward Send Destroy_Object
78205>>>>>>>>>>>    End_Procedure
78206>>>>>>>>>>>
78206>>>>>>>>>>>End_Class // DFTimer
78207>>>>>>>>>>>
78207>>>>>>>>>>>//
78207>>>>>>>>>>>// This was moved into a method so it can be reliable created
78207>>>>>>>>>>>// at the desktop. Note that cDesktop adds method to cDesktop class (class of desktop)
78207>>>>>>>>>>>//
78207>>>>>>>>>>>Procedure CreateDfTimerManagerPanel FOR cDesktop
78209>>>>>>>>>>>    // Create the Desktop Timer Manager Object.
78209>>>>>>>>>>>    Object DFTimerManagerPanel is a DFTimerManagerPanel
78211>>>>>>>>>>>    End_Object
78212>>>>>>>>>>>End_Procedure
78213>>>>>>>>>>>
78213>>>>>>>>>>>Send CreateDfTimerManagerPanel of DESKTOP
78214>>>>>>>>>>>
78214>>>>>>>>>
78214>>>>>>>>>Class cTimer is a cObject
78215>>>>>>>>>
78215>>>>>>>>>    Procedure Construct_Object
78217>>>>>>>>>        Forward Send Construct_Object
78219>>>>>>>>>        Property Integer piPrivate_Timeout 1000
78220>>>>>>>>>    End_Procedure
78221>>>>>>>>>
78221>>>>>>>>>    Procedure Set pbEnabled Boolean bEnabled
78223>>>>>>>>>        If giTimerManager Begin
78225>>>>>>>>>            Set Timer_Active_State of giTimerManager Self to bEnabled
78226>>>>>>>>>        End
78226>>>>>>>>>>
78226>>>>>>>>>    End_Procedure
78227>>>>>>>>>
78227>>>>>>>>>    Function pbEnabled Returns Boolean
78229>>>>>>>>>        Boolean bEnabled
78229>>>>>>>>>        If giTimerManager Begin
78231>>>>>>>>>            Get Timer_Active_State of giTimerManager Self to bEnabled
78232>>>>>>>>>        End
78232>>>>>>>>>>
78232>>>>>>>>>        Function_Return bEnabled
78233>>>>>>>>>    End_Function
78234>>>>>>>>>
78234>>>>>>>>>    Procedure Set piTimeout Integer iTimeout
78236>>>>>>>>>        Boolean bEnabled
78236>>>>>>>>>        Set piPrivate_Timeout to iTimeout
78237>>>>>>>>>        Get pbEnabled to bEnabled
78238>>>>>>>>>        If bEnabled Begin
78240>>>>>>>>>            Set pbEnabled to True
78241>>>>>>>>>        End
78241>>>>>>>>>>
78241>>>>>>>>>    End_Procedure
78242>>>>>>>>>
78242>>>>>>>>>    Function piTimeout Returns Integer
78244>>>>>>>>>        Integer iTimeout
78244>>>>>>>>>        Get piPrivate_Timeout to iTimeout
78245>>>>>>>>>        Function_Return iTimeout
78246>>>>>>>>>    End_Function
78247>>>>>>>>>
78247>>>>>>>>>    Procedure OnTimer
78249>>>>>>>>>    End_Procedure
78250>>>>>>>>>    
78250>>>>>>>>>    // this is needed by the timer manager 
78250>>>>>>>>>    Function Timeout Returns Integer
78252>>>>>>>>>        Integer iTimeout
78252>>>>>>>>>        Get piPrivate_Timeout to iTimeout
78253>>>>>>>>>        Function_Return iTimeout
78254>>>>>>>>>    End_Function
78255>>>>>>>>>
78255>>>>>>>>>    Procedure Destroy_Object
78257>>>>>>>>>        Set pbEnabled to False
78258>>>>>>>>>        Forward Send Destroy_Object
78260>>>>>>>>>    End_Procedure
78261>>>>>>>>>
78261>>>>>>>>>End_Class
78262>>>>>>>Use cRichEdit.pkg
Including file: cRichEdit.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cRichEdit.pkg)
78262>>>>>>>>>use Windows.pkg
78262>>>>>>>>>Use cEdit_Mixin.pkg
78262>>>>>>>>>
78262>>>>>>>>>// DFO: cRichEdit.Dfo
78262>>>>>>>>>// DFC: cRichEdit.Dfc
78262>>>>>>>>>
78262>>>>>>>>>// constants used for RichEdit Properties
78262>>>>>>>>>// peAlignment 
78262>>>>>>>>>Enum_List 
78262>>>>>>>>>    Define alLeft   for 1 
78262>>>>>>>>>    Define alRight  for 2 
78262>>>>>>>>>    Define alCenter for 3 
78262>>>>>>>>>End_Enum_List 
78262>>>>>>>>>
78262>>>>>>>>>// peBullets 
78262>>>>>>>>>Enum_List 
78262>>>>>>>>>    Define buNone 
78262>>>>>>>>>    Define buBullets 
78262>>>>>>>>>    Define buArabicNumbers 
78262>>>>>>>>>    Define buLowerLetters 
78262>>>>>>>>>    Define buUpperLetters 
78262>>>>>>>>>    Define buLowerRomans 
78262>>>>>>>>>    Define buUpperRomans 
78262>>>>>>>>>End_Enum_List 
78262>>>>>>>>>
78262>>>>>>>>>// peBulletStyle 
78262>>>>>>>>>Enum_List 
78262>>>>>>>>>    Define busRightParen   for 0 
78262>>>>>>>>>    Define busEncloseParen for 256 
78262>>>>>>>>>    Define busPeriod       for 512 
78262>>>>>>>>>    Define busNumberOnly   for 768 
78262>>>>>>>>>    Define busNoDisplay    for 1024 
78262>>>>>>>>>End_Enum_List
78262>>>>>>>>>    
78262>>>>>>>>>// peLineSpacingType
78262>>>>>>>>>Enum_List 
78262>>>>>>>>>    Define lstSingle
78262>>>>>>>>>    Define lstSingleAndOneHalf
78262>>>>>>>>>    Define lstDouble
78262>>>>>>>>>End_Enum_List
78262>>>>>>>>>
78262>>>>>>>>>Class cRichEdit Is A DFBaseRichEdit
78263>>>>>>>>>
78263>>>>>>>>>    Procedure Construct_Object
78265>>>>>>>>>        Forward Send Construct_Object
78267>>>>>>>>>        Send Define_cEdit_Mixin
78268>>>>>>>>>
78268>>>>>>>>>        On_key Key_Ctrl+Key_B send ToggleBold
78269>>>>>>>>>        On_key Key_Ctrl+Key_I send ToggleItalics
78270>>>>>>>>>        On_key Key_Ctrl+Key_U send ToggleUnderline
78271>>>>>>>>>
78271>>>>>>>>>    End_Procedure // Construct_Object
78272>>>>>>>>>
78272>>>>>>>>>    Import_Class_Protocol cEdit_Mixin
78273>>>>>>>>>    
78273>>>>>>>>>    Procedure ToggleBold
78275>>>>>>>>>        Set pbBold to (not(pbBold(self))) 
78276>>>>>>>>>    end_procedure
78277>>>>>>>>>    
78277>>>>>>>>>    Procedure ToggleItalics
78279>>>>>>>>>        Set pbItalics to (not(pbItalics(self))) 
78280>>>>>>>>>    end_procedure
78281>>>>>>>>>    
78281>>>>>>>>>    Procedure ToggleUnderline
78283>>>>>>>>>       Set pbUnderLine to (not(pbUnderLine(self))) 
78284>>>>>>>>>    end_procedure
78285>>>>>>>>>
78285>>>>>>>>>End_Class
78286>>>>>>>>>
78286>>>>>>>Use sql.pkg
Including file: sql.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\sql.pkg)
78286>>>>>>>>>//*****************************************************************************
78286>>>>>>>>>//*** SQL.pkg                                                               ***
78286>>>>>>>>>//***                                                                       ***
78286>>>>>>>>>//*** Author: Ben Weijers                                                   ***
78286>>>>>>>>>//***         Data Access Wordwide                                          ***
78286>>>>>>>>>//***         14 February 2000                                              ***
78286>>>>>>>>>//***                                                                       ***
78286>>>>>>>>>//*** Purpose:                                                              ***
78286>>>>>>>>>//***   Embedded SQL manager.                                               ***
78286>>>>>>>>>//***                                                                       ***
78286>>>>>>>>>//*** Changes:                                                              ***
78286>>>>>>>>>//***                                                                       ***
78286>>>>>>>>>//***   March 14, 2001. CLI Connectivity Kits 2.0.0.13                      ***
78286>>>>>>>>>//***       Allocate memory before call_driver command with spaces instead  ***
78286>>>>>>>>>//***       of binary zeroes.                                               ***
78286>>>>>>>>>//***                                                                       ***
78286>>>>>>>>>//*****************************************************************************
78286>>>>>>>>>
78286>>>>>>>>>Use UI
78286>>>>>>>>>Use CLI
78286>>>>>>>>>Use Case.mac
78286>>>>>>>>>
78286>>>>>>>>>//Doc/ Ignore=True
78286>>>>>>>>>//*** Global object handle for the manager
78286>>>>>>>>>Integer _embsqlghoSQLHandleMngr
78286>>>>>>>>>
78286>>>>>>>>>//*** Global stroage for results
78286>>>>>>>>>Integer SQLResult
78286>>>>>>>>>
78286>>>>>>>>>//*** Embedded SQL function constants
78286>>>>>>>>>Define FUNC_SQLCONNECT             For 1000000
78286>>>>>>>>>Define FUNC_SQLFILECONNECT         For 1000001
78286>>>>>>>>>Define FUNC_SQLDISCONNECT          For 1000002
78286>>>>>>>>>Define FUNC_SQLOPEN                For 1000003
78286>>>>>>>>>Define FUNC_SQLCLOSE               For 1000004
78286>>>>>>>>>Define FUNC_SQLPREPARE             For 1000005
78286>>>>>>>>>Define FUNC_SQLEXECUTE             For 1000006
78286>>>>>>>>>Define FUNC_SQLEXECDIRECT          For 1000007
78286>>>>>>>>>Define FUNC_SQLFETCH               For 1000008
78286>>>>>>>>>Define FUNC_SQLCOLUMNINFO          For 1000009
78286>>>>>>>>>Define FUNC_SQLCOLUMNVALUE         For 1000010
78286>>>>>>>>>Define FUNC_SQLBINDFILE            For 1000011
78286>>>>>>>>>Define FUNC_SQLGETDATA             For 1000012
78286>>>>>>>>>Define FUNC_SQLCOLSTRINGATTRIBLEN  For 1000013
78286>>>>>>>>>Define FUNC_SQLCOLSTRINGATTRIB     For 1000014
78286>>>>>>>>>Define FUNC_SQLCOLINTATTRIB        For 1000015
78286>>>>>>>>>Define FUNC_SQLSTMTINTATTRIB       For 1000016
78286>>>>>>>>>Define FUNC_SQLSETPROCNAME         For 1000017
78286>>>>>>>>>DEfine FUNC_SQLSETPROCARG          For 1000018
78286>>>>>>>>>Define FUNC_SQLCALL                For 1000019
78286>>>>>>>>>Define FUNC_SQLGETPROCARGLEN       For 1000020
78286>>>>>>>>>Define FUNC_SQLGETPROCARG          For 1000021
78286>>>>>>>>>Define FUNC_SQLGETPROCRETVALLEN    For 1000022
78286>>>>>>>>>Define FUNC_SQLGETPROCRETVAL       For 1000023
78286>>>>>>>>>Define FUNC_SQLNEXTRESULTSET       For 1000024
78286>>>>>>>>>Define FUNC_SQLBUFFERSTATUS        For 1000025
78286>>>>>>>>>
78286>>>>>>>>>//*** Embedded SQL statement attribute constants
78286>>>>>>>>>Define SQLSTMTATTRIB_COLUMNCOUNT    For 1
78286>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT       For 2
78286>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT_TYPE  For 3
78286>>>>>>>>>
78286>>>>>>>>>//*** Embedded SQL column attribute constants
78286>>>>>>>>>Define SQLCOLATTRIB_SIZE           For 1
78286>>>>>>>>>Define SQLCOLATTRIB_LENGTH         For 1
78286>>>>>>>>>Define SQLCOLATTRIB_PRECISION      For 2
78286>>>>>>>>>Define SQLCOLATTRIB_LABEL          For 3
78286>>>>>>>>>Define SQLCOLATTRIB_BASECOLUMNNAME For 4
78286>>>>>>>>>Define SQLCOLATTRIB_BASETABLENAME  For 5
78286>>>>>>>>>Define SQLCOLATTRIB_SQLTYPE        For 6
78286>>>>>>>>>Define SQLCOLATTRIB_NULLABLE       For 7
78286>>>>>>>>>Define SQLCOLATTRIB_DFTYPE         For 8
78286>>>>>>>>>
78286>>>>>>>>>//*** Possible SQL Column type values
78286>>>>>>>>>Define SQL_UNKNOWN_TYPE   For    0
78286>>>>>>>>>Define SQL_CHAR           For    1
78286>>>>>>>>>Define SQL_NUMERIC        For    2
78286>>>>>>>>>Define SQL_DECIMAL        For    3
78286>>>>>>>>>Define SQL_INTEGER        For    4
78286>>>>>>>>>Define SQL_SMALLINT       For    5
78286>>>>>>>>>Define SQL_FLOAT          For    6
78286>>>>>>>>>Define SQL_REAL           For    7
78286>>>>>>>>>Define SQL_DOUBLE         For    8
78286>>>>>>>>>Define SQL_DATETIME       For    9
78286>>>>>>>>>Define SQL_VARCHAR        For   12
78286>>>>>>>>>Define SQL_TYPE_DATE      For   91
78286>>>>>>>>>Define SQL_TYPE_TIME      For   92
78286>>>>>>>>>Define SQL_TYPE_TIMESTAMP For   93
78286>>>>>>>>>
78286>>>>>>>>>Define SQL_DATE           For    9
78286>>>>>>>>>Define SQL_INTERVAL       For   10
78286>>>>>>>>>Define SQL_TIME           For   10
78286>>>>>>>>>Define SQL_TIMESTAMP      For   11
78286>>>>>>>>>Define SQL_LONGVARCHAR    For  (-1)
78286>>>>>>>>>Define SQL_BINARY         For  (-2)
78286>>>>>>>>>Define SQL_VARBINARY      For  (-3)
78286>>>>>>>>>Define SQL_LONGVARBINARY  For  (-4)
78286>>>>>>>>>Define SQL_BIGINT         For  (-5)
78286>>>>>>>>>Define SQL_TINYINT        For  (-6)
78286>>>>>>>>>Define SQL_BIT            For  (-7)
78286>>>>>>>>>Define SQL_GUID           For (-11)
78286>>>>>>>>>
78286>>>>>>>>>
78286>>>>>>>>>
78286>>>>>>>>>//*****************************************************************************
78286>>>>>>>>>//*** Class  : cSQLStatement                                                ***
78286>>>>>>>>>//*** Purpose: Statement object for embedded sql                            ***
78286>>>>>>>>>//***                                                                       ***
78286>>>>>>>>>//*** Description:                                                          ***
78286>>>>>>>>>//***   An object is created for each statement. These will be children     ***
78286>>>>>>>>>//***   of cSQLConnection objects which manage the create and destruction   ***
78286>>>>>>>>>//***   of these.                                                           ***
78286>>>>>>>>>//*****************************************************************************
78286>>>>>>>>>
78286>>>>>>>>>Class cSQLStatement is an Array
78287>>>>>>>>>
78287>>>>>>>>>    Procedure Construct_object Integer Image
78289>>>>>>>>>        Forward Send Construct_object Image
78291>>>>>>>>>
78291>>>>>>>>>        Property Integer phCLIHandle      public 0
78292>>>>>>>>>        Property String  psDriverID       Public ""
78293>>>>>>>>>        Property Integer phStmtConnection Public 0
78294>>>>>>>>>        Property Integer piLastColumn     Public 0
78295>>>>>>>>>        Property Integer piLastArgument   Public 0
78296>>>>>>>>>        Property Integer piBindFile       Public 0
78297>>>>>>>>>
78297>>>>>>>>>        Set Delegation_mode To NO_Delegation
78298>>>>>>>>>    End_procedure // Construct_object
78299>>>>>>>>>
78299>>>>>>>>>
78299>>>>>>>>>
78299>>>>>>>>>    //***
78299>>>>>>>>>    //*** Procedure: StoreHandleInfo
78299>>>>>>>>>    //*** Purpose  : Store basic information about the statement handle.
78299>>>>>>>>>    //***
78299>>>>>>>>>
78299>>>>>>>>>    Procedure StoreHandleInfo Integer iCLIHandle String sDrvrId Integer iParentHandle
78301>>>>>>>>>        Set phCLIHandle      To iCLIHandle
78302>>>>>>>>>        Set psDriverID       To sDrvrId
78303>>>>>>>>>        Set phStmtConnection To iParentHandle
78304>>>>>>>>>    End_Procedure // StoreHandleInfo
78305>>>>>>>>>
78305>>>>>>>>>
78305>>>>>>>>>
78305>>>>>>>>>    //***
78305>>>>>>>>>    //*** Procedure: FreeHandle
78305>>>>>>>>>    //*** Purpose  : Free a handle. Since a handle is stored in an
78305>>>>>>>>>    //***            cSQLStatement object, we destroy the object.
78305>>>>>>>>>    //***
78305>>>>>>>>>
78305>>>>>>>>>    Procedure FreeHandle
78307>>>>>>>>>        Send Destroy_Object
78308>>>>>>>>>    End_Procedure // FreeHandle
78309>>>>>>>>>
78309>>>>>>>>>
78309>>>>>>>>>
78309>>>>>>>>>    //***
78309>>>>>>>>>    //*** Procedure: HandleError
78309>>>>>>>>>    //*** Puprose  : Handle an error that has occured while checking properties.
78309>>>>>>>>>    //***
78309>>>>>>>>>
78309>>>>>>>>>    Procedure HandleError Integer ihstmt Integer ihdbc String sDrvrId String sOriginMsg
78311>>>>>>>>>        Local Integer iErrHandle
78311>>>>>>>>>        Local Integer iErrNum
78311>>>>>>>>>        Local String  sLocationInfo
78311>>>>>>>>>
78311>>>>>>>>>        //*** Get the DataFlex statement identifier
78311>>>>>>>>>        Move Current_object To iErrHandle
78312>>>>>>>>>
78312>>>>>>>>>        //*** Determine error number
78312>>>>>>>>>        If (ihstmt = 0) ;            Move CLIERR_SQLINVALID_CLI_STMT_HANDLE To iErrNum
78315>>>>>>>>>        Else If (ihdbc = 0) ;            Move CLIERR_SQLINVALID_CLI_CONN_HANDLE To iErrNum
78319>>>>>>>>>        Else If (sDrvrId = "") ;            Move CLIERR_SQLINVALID_DRIVER_ID To iErrNum
78323>>>>>>>>>        Else ;            Move CLIERR_SQL_ERROR To iErrNum
78325>>>>>>>>>
78325>>>>>>>>>        //*** Create location ifnormation
78325>>>>>>>>>        Move "[" To sLocationInfo
78326>>>>>>>>>        If (sOriginMsg <> "") Begin
78328>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) To sLocationInfo
78329>>>>>>>>>            Move (Append(sLocationInfo, ", "))       To sLocationInfo
78330>>>>>>>>>        End
78330>>>>>>>>>>
78330>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) To sLocationInfo
78331>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          To sLocationInfo
78332>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 To sLocationInfo
78333>>>>>>>>>
78333>>>>>>>>>        //*** Generate the error
78333>>>>>>>>>        Error iErrNum sLocationInfo
78334>>>>>>>>>>
78334>>>>>>>>>    End_Procedure // HandleError
78335>>>>>>>>>
78335>>>>>>>>>
78335>>>>>>>>>
78335>>>>>>>>>    //***
78335>>>>>>>>>    //*** Procedure: StmtError
78335>>>>>>>>>    //*** Purpose  : Handle general error not related to the properties
78335>>>>>>>>>    //***
78335>>>>>>>>>
78335>>>>>>>>>    Procedure StmtError Integer iErrNum String sErrText String sOriginMsg
78337>>>>>>>>>        Local Integer iErrHandle
78337>>>>>>>>>        Local String  sLocationInfo
78337>>>>>>>>>
78337>>>>>>>>>        //*** Get the DataFlex statement identifier
78337>>>>>>>>>        Move Current_object To iErrHandle
78338>>>>>>>>>
78338>>>>>>>>>
78338>>>>>>>>>        //*** Create location information
78338>>>>>>>>>        Move "[" To sLocationInfo
78339>>>>>>>>>        If (sOriginMsg <> "") Begin
78341>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) To sLocationInfo
78342>>>>>>>>>            Move (Append(sLocationInfo, ", "))       To sLocationInfo
78343>>>>>>>>>        End
78343>>>>>>>>>>
78343>>>>>>>>>        If (sErrtext <> "") Begin
78345>>>>>>>>>            Move (Append(sLocationInfo, sErrtext)) To sLocationInfo
78346>>>>>>>>>            Move (Append(sLocationInfo, ", "))     To sLocationInfo
78347>>>>>>>>>        End
78347>>>>>>>>>>
78347>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) To sLocationInfo
78348>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          To sLocationInfo
78349>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 To sLocationInfo
78350>>>>>>>>>
78350>>>>>>>>>        //*** Generate the error
78350>>>>>>>>>        Error iErrNum sLocationInfo
78351>>>>>>>>>>
78351>>>>>>>>>    End_Procedure // StmtError
78352>>>>>>>>>
78352>>>>>>>>>
78352>>>>>>>>>
78352>>>>>>>>>    //***
78352>>>>>>>>>    //*** Procedure: SQLIllegalAttribute
78352>>>>>>>>>    //*** Purpose  : Handle an illegal attribute error
78352>>>>>>>>>    //***
78352>>>>>>>>>
78352>>>>>>>>>    Procedure SQLIllegalAttribute String sErrText String sOriginMsg
78354>>>>>>>>>        Local Integer bReport
78354>>>>>>>>>
78354>>>>>>>>>        Get_attribute DF_REPORT_UNSUPPORTED_ATTRIBUTES To bReport
78357>>>>>>>>>        If (bReport) ;            Send StmtError CLIERR_SQLINVALID_ATTRIBUTE sErrtext sOriginMsg
78360>>>>>>>>>    End_Procedure // SQLIllegalAttribute
78361>>>>>>>>>
78361>>>>>>>>>
78361>>>>>>>>>
78361>>>>>>>>>    //***
78361>>>>>>>>>    //*** Function: SQLPrivateColumnIsLegal
78361>>>>>>>>>    //*** Purpose : Check if a column number is legal
78361>>>>>>>>>    //***
78361>>>>>>>>>
78361>>>>>>>>>    Function SQLPrivateColumnIsLegal Integer ihdbc String sDrvrId Integer ihstmt Integer iCol Returns Integer
78363>>>>>>>>>        Local Integer bLegal
78363>>>>>>>>>        Local Integer iNumColumns
78363>>>>>>>>>
78363>>>>>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt To iNumColumns
78364>>>>>>>>>        If (iCol > 0 And iCol <= iNumColumns) ;            Move DFTRUE To bLegal
78367>>>>>>>>>        Else ;            Move DFFALSE To bLegal
78369>>>>>>>>>
78369>>>>>>>>>        Function_Return bLegal
78370>>>>>>>>>    End_Function // SQLPrivateColumnIsLegal
78371>>>>>>>>>
78371>>>>>>>>>
78371>>>>>>>>>
78371>>>>>>>>>    //***
78371>>>>>>>>>    //*** Procedure: SQLClose
78371>>>>>>>>>    //*** Purpose  : Close a statement and free all alllocated resources
78371>>>>>>>>>    //***
78371>>>>>>>>>
78371>>>>>>>>>    Procedure SQLClose
78373>>>>>>>>>        Local Integer ihdbc
78373>>>>>>>>>        Local Integer ihstmt
78373>>>>>>>>>        Local Integer iVoid
78373>>>>>>>>>        Local String  sDrvrId
78373>>>>>>>>>        Local String  sEmpty
78373>>>>>>>>>
78373>>>>>>>>>        //*** Initialize
78373>>>>>>>>>        Move "" To sEmpty
78374>>>>>>>>>
78374>>>>>>>>>        //*** Get the cli handle to the connection
78374>>>>>>>>>        Get phCLIHandle        To ihstmt
78375>>>>>>>>>        Get psDriverId         To sDrvrId
78376>>>>>>>>>        Get phStmtConnection   To ihdbc
78377>>>>>>>>>
78377>>>>>>>>>        //*** Free the CLI handle
78377>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
78379>>>>>>>>>            //*** Call the driver function to close
78379>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCLOSE ;                        Callback Current_Object ;                        Passing ihdbc sEmpty ihstmt ;                        Result iVoid
78384>>>>>>>>>
78384>>>>>>>>>            //*** Free the DataFlex handle
78384>>>>>>>>>            Send FreeHandle
78385>>>>>>>>>        End
78385>>>>>>>>>>
78385>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLClose"
78387>>>>>>>>>    End_procedure // SQLClose
78388>>>>>>>>>
78388>>>>>>>>>
78388>>>>>>>>>
78388>>>>>>>>>    //***
78388>>>>>>>>>    //*** Procedure: SQLPrepare
78388>>>>>>>>>    //*** Purpose  : Prepare a statement for execution
78388>>>>>>>>>    //***
78388>>>>>>>>>
78388>>>>>>>>>    Procedure SQLPrepare String sStatement
78390>>>>>>>>>        Local Integer ihdbc
78390>>>>>>>>>        Local Integer ihstmt
78390>>>>>>>>>        Local Integer iVoid
78390>>>>>>>>>        Local String  sDrvrId
78390>>>>>>>>>
78390>>>>>>>>>        //*** Get the cli handle to the connection
78390>>>>>>>>>        Get phCLIHandle       To ihstmt
78391>>>>>>>>>        Get psDriverId        To sDrvrId
78392>>>>>>>>>        Get phStmtConnection  To ihdbc
78393>>>>>>>>>
78393>>>>>>>>>        //*** Prepare
78393>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
78395>>>>>>>>>            //*** Call the driver function to prepare
78395>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLPREPARE ;                        Callback Current_Object ;                        Passing ihdbc sStatement ihstmt ;                        Result iVoid
78400>>>>>>>>>        End
78400>>>>>>>>>>
78400>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrepare"
78402>>>>>>>>>    End_procedure // SQLPrepare
78403>>>>>>>>>
78403>>>>>>>>>
78403>>>>>>>>>
78403>>>>>>>>>    //***
78403>>>>>>>>>    //*** Procedure: SQLExecute
78403>>>>>>>>>    //*** Purpose  : Execute a prepared statement
78403>>>>>>>>>    //***
78403>>>>>>>>>
78403>>>>>>>>>    Procedure SQLExecute
78405>>>>>>>>>        Local Integer ihdbc
78405>>>>>>>>>        Local Integer ihstmt
78405>>>>>>>>>        Local Integer iVoid
78405>>>>>>>>>        Local String  sDrvrId
78405>>>>>>>>>        Local String  sEmpty
78405>>>>>>>>>
78405>>>>>>>>>        //*** Initialize
78405>>>>>>>>>        Move "" To sEmpty
78406>>>>>>>>>
78406>>>>>>>>>        //*** Get the cli handle to the connection
78406>>>>>>>>>        Get phCLIHandle       To ihstmt
78407>>>>>>>>>        Get psDriverId        To sDrvrId
78408>>>>>>>>>        Get phStmtConnection  To ihdbc
78409>>>>>>>>>
78409>>>>>>>>>        //*** Execute
78409>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
78411>>>>>>>>>            //*** Call the driver function to execute
78411>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLEXECUTE ;                        Callback Current_Object ;                        Passing ihdbc sEmpty ihstmt ;                        Result iVoid
78416>>>>>>>>>        End
78416>>>>>>>>>>
78416>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLExecute"
78418>>>>>>>>>    End_Procedure // SQLExecute
78419>>>>>>>>>
78419>>>>>>>>>
78419>>>>>>>>>
78419>>>>>>>>>    //***
78419>>>>>>>>>    //*** Procedure: SQLExecDirect
78419>>>>>>>>>    //*** Purpose  : Prepare and execute a statement
78419>>>>>>>>>    //***
78419>>>>>>>>>
78419>>>>>>>>>    Procedure SQLExecDirect String sStatement
78421>>>>>>>>>        Local Integer ihdbc
78421>>>>>>>>>        Local Integer ihstmt
78421>>>>>>>>>        Local Integer iVoid
78421>>>>>>>>>        Local String  sDrvrId
78421>>>>>>>>>
78421>>>>>>>>>        //*** Get the cli handle to the connection
78421>>>>>>>>>        Get phCLIHandle        To ihstmt
78422>>>>>>>>>        Get psDriverId         To sDrvrId
78423>>>>>>>>>        Get phStmtConnection   To ihdbc
78424>>>>>>>>>
78424>>>>>>>>>        //*** ExecDirect
78424>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
78426>>>>>>>>>            //*** Call the driver function to execdirect
78426>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLEXECDIRECT ;                        Callback Current_Object ;                        Passing ihdbc sStatement ihstmt ;                        Result iVoid
78431>>>>>>>>>        End
78431>>>>>>>>>>
78431>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLExecDirect"
78433>>>>>>>>>    End_procedure // SQLExecDirect
78434>>>>>>>>>
78434>>>>>>>>>
78434>>>>>>>>>
78434>>>>>>>>>    //***
78434>>>>>>>>>    //*** Procedure: SQLFetch
78434>>>>>>>>>    //*** Purpose  : Fetch the next row
78434>>>>>>>>>    //*** Returns  : 0   = No more data
78434>>>>>>>>>    //***            <>0 = Success
78434>>>>>>>>>    //***
78434>>>>>>>>>
78434>>>>>>>>>    Function SQLFetch Returns Integer
78436>>>>>>>>>        Local Integer ihdbc
78436>>>>>>>>>        Local Integer ihstmt
78436>>>>>>>>>        Local Integer iResult
78436>>>>>>>>>        Local String  sDrvrId
78436>>>>>>>>>        Local String  sEmpty
78436>>>>>>>>>
78436>>>>>>>>>        //*** Initialize
78436>>>>>>>>>        Move "" To sEmpty
78437>>>>>>>>>        Move 0  To iResult
78438>>>>>>>>>
78438>>>>>>>>>        //*** Get the cli handle to the connection
78438>>>>>>>>>        Get phCLIHandle        To ihstmt
78439>>>>>>>>>        Get psDriverId         To sDrvrId
78440>>>>>>>>>        Get phStmtConnection   To ihdbc
78441>>>>>>>>>
78441>>>>>>>>>        //*** Fetch
78441>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
78443>>>>>>>>>            Indicate Err False
78444>>>>>>>>>
78444>>>>>>>>>            //*** Call the driver function to fetch
78444>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLFETCH ;                        Callback Current_Object ;                        Passing ihdbc sEmpty ihstmt ;                        Result iResult
78449>>>>>>>>>
78449>>>>>>>>>            //*** If something went wrong, adjust the result
78449>>>>>>>>>            If (Err) ;                Move 0 To iResult
78452>>>>>>>>>
78452>>>>>>>>>            Set piLastcolumn To 0
78453>>>>>>>>>        End
78453>>>>>>>>>>
78453>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLFetch"
78455>>>>>>>>>
78455>>>>>>>>>        Function_return iResult
78456>>>>>>>>>    End_Function // SQLFetch
78457>>>>>>>>>
78457>>>>>>>>>
78457>>>>>>>>>
78457>>>>>>>>>    //***
78457>>>>>>>>>    //*** Function: SQLNextColumn
78457>>>>>>>>>    //*** Purpose : Get the next column
78457>>>>>>>>>    //***
78457>>>>>>>>>
78457>>>>>>>>>    Function SQLNextColumn Returns String
78459>>>>>>>>>        Local Integer iCol
78459>>>>>>>>>        Local String  sResult
78459>>>>>>>>>
78459>>>>>>>>>        Get piLastColumn To iCol
78460>>>>>>>>>        Increment iCol
78461>>>>>>>>>        Get SQLColumnValue iCol To sResult
78462>>>>>>>>>        Set piLastColumn To iCol
78463>>>>>>>>>
78463>>>>>>>>>        Function_return sResult
78464>>>>>>>>>    End_Function // SQLNextColumn
78465>>>>>>>>>
78465>>>>>>>>>
78465>>>>>>>>>
78465>>>>>>>>>    //***
78465>>>>>>>>>    //*** Function: SQLColumnValue
78465>>>>>>>>>    //*** Purpose : Return the value of a column in a fetched row of a given
78465>>>>>>>>>    //***           statement.
78465>>>>>>>>>    //***
78465>>>>>>>>>
78465>>>>>>>>>    Function SQLColumnValue Integer iCol Returns String
78467>>>>>>>>>        Local Integer ihdbc
78467>>>>>>>>>        Local Integer ihstmt
78467>>>>>>>>>        Local String  sDrvrId
78467>>>>>>>>>        Local String  sResult
78467>>>>>>>>>
78467>>>>>>>>>        //*** Initialize
78467>>>>>>>>>        Move "" To sResult
78468>>>>>>>>>
78468>>>>>>>>>        //*** Get the cli handle to the connection
78468>>>>>>>>>        Get phCLIHandle       To ihstmt
78469>>>>>>>>>        Get psDriverId        To sDrvrId
78470>>>>>>>>>        Get phStmtConnection  To ihdbc
78471>>>>>>>>>
78471>>>>>>>>>        //*** Get the value
78471>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") ;            Get SQLPrivateColumnValue iCol ihdbc sDRvrId ihstmt To sResult
78474>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnValue"
78476>>>>>>>>>
78476>>>>>>>>>        Function_return sResult
78477>>>>>>>>>    End_Function // SQLColumnValue
78478>>>>>>>>>
78478>>>>>>>>>    Function SQLPrivateColumnValue Integer iCol Integer ihdbc String sDrvrId Integer ihstmt Returns String
78480>>>>>>>>>        Local Integer iVoid
78480>>>>>>>>>        Local Integer iColSize
78480>>>>>>>>>        Local String  sResult
78480>>>>>>>>>        Local String  sEmpty
78480>>>>>>>>>        Local Integer bLegalColumn
78480>>>>>>>>>
78480>>>>>>>>>        //*** Initialize
78480>>>>>>>>>        Move "" To sEmpty
78481>>>>>>>>>
78481>>>>>>>>>        //*** Get the value
78481>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
78483>>>>>>>>>            //*** Check if the column exists
78483>>>>>>>>>            Get SQLPrivateColumnIsLegal ihdbc sDrvrId ihstmt iCol To bLegalColumn
78484>>>>>>>>>            If (bLegalColumn) Begin
78486>>>>>>>>>                //*** Determine the column size
78486>>>>>>>>>                Get SQLPrivateColAttribute iCol SQLCOLATTRIB_SIZE ihdbc sDrvrId ihstmt To iColSize
78487>>>>>>>>>                If (iColSize > 0) Begin
78489>>>>>>>>>                    //*** Setup function arguments
78489>>>>>>>>>                    Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                                Callback Current_Object ;                                Passing ihdbc iCol ihstmt ;                                Result iVoid
78494>>>>>>>>>
78494>>>>>>>>>                    //*** Allocate
78494>>>>>>>>>                    Move (Repeat(' ', iColSize)) To sResult
78495>>>>>>>>>
78495>>>>>>>>>                    //*** Call the driver function to get the value
78495>>>>>>>>>                    Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                                Callback Current_Object ;                                Passing sResult sEmpty 0 ;                                Result iVoid
78500>>>>>>>>>                End
78500>>>>>>>>>>
78500>>>>>>>>>            End
78500>>>>>>>>>>
78500>>>>>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLPrivateColumnValue"
78502>>>>>>>>>        End
78502>>>>>>>>>>
78502>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateColumnValue"
78504>>>>>>>>>
78504>>>>>>>>>        Function_return sResult
78505>>>>>>>>>    End_Function // SQLColumnValue
78506>>>>>>>>>
78506>>>>>>>>>
78506>>>>>>>>>
78506>>>>>>>>>    //***
78506>>>>>>>>>    //*** Procedure: SQLBindFile
78506>>>>>>>>>    //*** Purpose  : Add a file to the files used to place the statement result in.
78506>>>>>>>>>    //***
78506>>>>>>>>>
78506>>>>>>>>>    Procedure SQLBindFile Integer iFileNum
78508>>>>>>>>>        Local Integer ihdbc
78508>>>>>>>>>        Local Integer ihstmt
78508>>>>>>>>>        Local Integer iVoid
78508>>>>>>>>>        Local String  sDrvrId
78508>>>>>>>>>        Local String  sFileType
78508>>>>>>>>>        Local Integer bIsOpen
78508>>>>>>>>>
78508>>>>>>>>>        //*** Get the cli handle to the connection
78508>>>>>>>>>        Get phCLIHandle       To ihstmt
78509>>>>>>>>>        Get psDriverId        To sDrvrId
78510>>>>>>>>>        Get phStmtConnection  To ihdbc
78511>>>>>>>>>
78511>>>>>>>>>        //*** If a file number is not passed see if we can use the statement's
78511>>>>>>>>>        //*** default file number which is usually set with SetFileConnection
78511>>>>>>>>>        If (iFileNum = 0) Begin
78513>>>>>>>>>            Get piBindFile To iFileNum
78514>>>>>>>>>            If (iFileNum = 0) Begin
78516>>>>>>>>>                //*** Logic error, if 0 is passed as filenumber, piBindFile should be set.
78516>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_BIND_FILE "piBindFile should be set" "SQLBindFile"
78517>>>>>>>>>
78517>>>>>>>>>                Move 0 to SQLResult
78518>>>>>>>>>                Procedure_Return
78519>>>>>>>>>            End
78519>>>>>>>>>>
78519>>>>>>>>>        End
78519>>>>>>>>>>
78519>>>>>>>>>
78519>>>>>>>>>        //*** Bind the file
78519>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
78521>>>>>>>>>            //*** Chek if the file is open
78521>>>>>>>>>            Get_attribute DF_FILE_OPENED Of iFileNum To bIsOpen
78524>>>>>>>>>            If (bIsOpen) Begin
78526>>>>>>>>>                //*** Check if the file has the correct type
78526>>>>>>>>>                Get_attribute DF_FILE_DRIVER Of iFileNum To sFileType
78529>>>>>>>>>                If (sFileType = sDrvrId) Begin
78531>>>>>>>>>                    //*** Call the driver function to add a file to a statement
78531>>>>>>>>>                    Call_driver 0 sDrvrId Function FUNC_SQLBINDFILE ;                                Callback Current_Object ;                                Passing ihdbc iFileNum ihstmt ;                                Result iVoid
78536>>>>>>>>>                End
78536>>>>>>>>>>
78536>>>>>>>>>                Else ;                    Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File" * String(iFileNum) * "type incompatible with statement ("  + sFileType + ")") "SQLBindFile"
78538>>>>>>>>>            End
78538>>>>>>>>>>
78538>>>>>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File not open (number =" * String(iFileNum) + ")") "SQLBindFile"
78540>>>>>>>>>        End
78540>>>>>>>>>>
78540>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLBindFile"
78542>>>>>>>>>    End_Procedure // SQLBindFile
78543>>>>>>>>>
78543>>>>>>>>>
78543>>>>>>>>>
78543>>>>>>>>>    //*************************************************************************
78543>>>>>>>>>    //*** Function: SQLGetData                                              ***
78543>>>>>>>>>    //*** Purpose : Get data of a column.                                   ***
78543>>>>>>>>>    //*************************************************************************
78543>>>>>>>>>
78543>>>>>>>>>    Function SQLGetData Integer iCol Integer iLen Returns String
78545>>>>>>>>>        Local Integer ihdbc
78545>>>>>>>>>        Local Integer ihstmt
78545>>>>>>>>>        Local Integer iVoid
78545>>>>>>>>>        Local Integer iColSize
78545>>>>>>>>>        Local Integer iResult
78545>>>>>>>>>        Local String  sDrvrId
78545>>>>>>>>>        Local String  sResult
78545>>>>>>>>>        Local String  sEmpty
78545>>>>>>>>>        Local Integer bLegalColumn
78545>>>>>>>>>
78545>>>>>>>>>        //*** Initialize
78545>>>>>>>>>        Move "" To sEmpty
78546>>>>>>>>>        Move 0 To iResult
78547>>>>>>>>>
78547>>>>>>>>>        //*** Get the cli handle to the connection
78547>>>>>>>>>        Get phCLIHandle       To ihstmt
78548>>>>>>>>>        Get psDriverId        To sDrvrId
78549>>>>>>>>>        Get phStmtConnection  To ihdbc
78550>>>>>>>>>
78550>>>>>>>>>        //*** Get the data
78550>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
78552>>>>>>>>>            //*** Check if the column exists
78552>>>>>>>>>            Get SQLPrivateColumnIsLegal ihdbc sDrvrId ihstmt iCol To bLegalColumn
78553>>>>>>>>>            If (bLegalColumn) Begin
78555>>>>>>>>>                If (iLen = 0) ;                    Get SQLPrivateColumnValue iCol ihdbc sDrvrId ihstmt To sResult
78558>>>>>>>>>                Else Begin
78559>>>>>>>>>                    //*** Setup function arguments
78559>>>>>>>>>                    Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                                Callback Current_Object ;                                Passing ihdbc iCol ihstmt ;                                Result iVoid
78564>>>>>>>>>
78564>>>>>>>>>                    //*** Allocate
78564>>>>>>>>>                    Move (Repeat(' ', iLen)) To sResult
78565>>>>>>>>>
78565>>>>>>>>>                    Indicate Err False
78566>>>>>>>>>
78566>>>>>>>>>                    //*** Call the driver function to get the data
78566>>>>>>>>>                    Call_driver 0 sDrvrId Function FUNC_SQLGETDATA ;                                Callback Current_Object ;                                Passing sResult sEmpty iLen ;                                Result iResult
78571>>>>>>>>>
78571>>>>>>>>>                    //*** If something went wrong, adjust the result
78571>>>>>>>>>                    If (Err) ;                        Move 0 To iResult
78574>>>>>>>>>                End
78574>>>>>>>>>>
78574>>>>>>>>>            End
78574>>>>>>>>>>
78574>>>>>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLGetData"
78576>>>>>>>>>        End
78576>>>>>>>>>>
78576>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetData"
78578>>>>>>>>>
78578>>>>>>>>>        //*** Fill global result
78578>>>>>>>>>        Move iResult To SQLResult
78579>>>>>>>>>
78579>>>>>>>>>        Function_Return sResult
78580>>>>>>>>>    End_Function // SQLGetData
78581>>>>>>>>>
78581>>>>>>>>>
78581>>>>>>>>>
78581>>>>>>>>>    //***
78581>>>>>>>>>    //*** Function: SQLColumnMap
78581>>>>>>>>>    //*** Purpose : Map a column name to a number, if the name id not found no
78581>>>>>>>>>    //***           error is generated the returned number will be 0 (zero) in
78581>>>>>>>>>    //***           that case
78581>>>>>>>>>    //***
78581>>>>>>>>>
78581>>>>>>>>>    Function SQLColumnMap String sColname Returns Integer
78583>>>>>>>>>        Local Integer ihdbc
78583>>>>>>>>>        Local Integer ihstmt
78583>>>>>>>>>        Local Integer iNumColumns
78583>>>>>>>>>        Local Integer iColCount
78583>>>>>>>>>        Local Integer iColNum
78583>>>>>>>>>        Local String  sDrvrId
78583>>>>>>>>>        Local String  sCurColName
78583>>>>>>>>>
78583>>>>>>>>>        //*** Get the cli handle to the connection
78583>>>>>>>>>        Get phCLIHandle       To ihstmt
78584>>>>>>>>>        Get psDriverId        To sDrvrId
78585>>>>>>>>>        Get phStmtConnection  To ihdbc
78586>>>>>>>>>
78586>>>>>>>>>        //*** Get the number by looping through the column names
78586>>>>>>>>>        Move 0 To iColNum
78587>>>>>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt To iNumColumns
78588>>>>>>>>>        For iColCount From 1 To iNumColumns
78594>>>>>>>>>>
78594>>>>>>>>>            Get SQLPrivateColAttribute iColCount SQLCOLATTRIB_LABEL ihdbc sDrvrId ihstmt To sCurColName
78595>>>>>>>>>            If (Uppercase(Trim(sColName)) = Uppercase(Trim(sCurColName))) ;                Move iColCount To iColNum
78598>>>>>>>>>
78598>>>>>>>>>            If (iColNum) ;                Break
78601>>>>>>>>>        Loop
78602>>>>>>>>>>
78602>>>>>>>>>
78602>>>>>>>>>        Function_return iColNum
78603>>>>>>>>>    End_Function // SQLColumnMap
78604>>>>>>>>>
78604>>>>>>>>>
78604>>>>>>>>>
78604>>>>>>>>>    //***
78604>>>>>>>>>    //*** Function: SQLStmtAttribute
78604>>>>>>>>>    //*** Purpose : Get a statement attribute
78604>>>>>>>>>    //***
78604>>>>>>>>>
78604>>>>>>>>>    Function SQLStmtAttribute Integer iAttribId Returns String
78606>>>>>>>>>        Local Integer ihdbc
78606>>>>>>>>>        Local Integer ihstmt
78606>>>>>>>>>        Local String  sResult
78606>>>>>>>>>        Local String  sDrvrId
78606>>>>>>>>>
78606>>>>>>>>>        //*** Initialize
78606>>>>>>>>>        Move "" To sResult
78607>>>>>>>>>
78607>>>>>>>>>        //*** Get the cli handle to the connection
78607>>>>>>>>>        Get phCLIHandle       To ihstmt
78608>>>>>>>>>        Get psDriverId        To sDrvrId
78609>>>>>>>>>        Get phStmtConnection  To ihdbc
78610>>>>>>>>>
78610>>>>>>>>>        //*** Get the attribute
78610>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") ;            Get SQLPrivateStmtAttribute iAttribId ihdbc sDrvrId ihstmt To sResult
78613>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLStmtAttribute"
78615>>>>>>>>>
78615>>>>>>>>>        Function_Return sResult
78616>>>>>>>>>    End_Function // SQLStmtAttibute
78617>>>>>>>>>
78617>>>>>>>>>    Function SQLPrivateStmtAttribute Integer iAttribId Integer ihdbc String sDrvrId Integer ihstmt Returns String
78619>>>>>>>>>        Local String  sResult
78619>>>>>>>>>        Local Integer iLen
78619>>>>>>>>>        Local Integer bLegalAttrib
78619>>>>>>>>>
78619>>>>>>>>>        //*** Initialize
78619>>>>>>>>>        Move ""     To sResult
78620>>>>>>>>>
78620>>>>>>>>>        //*** Get the attribute
78620>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
78622>>>>>>>>>            Case Begin
78622>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_COLUMNCOUNT)
78624>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT)
78627>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT_TYPE)
78630>>>>>>>>>                    Move DFTRUE To bLegalAttrib
78631>>>>>>>>>                    Break
78632>>>>>>>>>
78632>>>>>>>>>                Case Else
78632>>>>>>>>>                    Move DFFALSE To bLegalAttrib
78633>>>>>>>>>                    Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLPrivateStmtAttribute"
78634>>>>>>>>>            Case End
78634>>>>>>>>>
78634>>>>>>>>>            If (bLegalAttrib) Begin
78636>>>>>>>>>                //*** Setup function arguments
78636>>>>>>>>>                Call_driver 0 sDrvrId Function FUNC_SQLSTMTINTATTRIB ;                            Callback Current_Object ;                            Passing ihdbc iAttribId ihstmt ;                            Result sResult
78641>>>>>>>>>            End
78641>>>>>>>>>>
78641>>>>>>>>>        End
78641>>>>>>>>>>
78641>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateStmtAttribute"
78643>>>>>>>>>
78643>>>>>>>>>        Function_Return sResult
78644>>>>>>>>>    End_Function // SQLPrivateStmtAttribute
78645>>>>>>>>>
78645>>>>>>>>>
78645>>>>>>>>>
78645>>>>>>>>>    //***
78645>>>>>>>>>    //*** Function: SQLColAttribute
78645>>>>>>>>>    //*** Purpose : Get a column's attribute
78645>>>>>>>>>    //***
78645>>>>>>>>>
78645>>>>>>>>>    Function SQLColAttribute Integer iCol Integer iAttribId Returns String
78647>>>>>>>>>        Local Integer ihdbc
78647>>>>>>>>>        Local Integer ihstmt
78647>>>>>>>>>        Local String  sResult
78647>>>>>>>>>        Local String  sDrvrId
78647>>>>>>>>>
78647>>>>>>>>>        //*** Initialize
78647>>>>>>>>>        Move "" To sResult
78648>>>>>>>>>
78648>>>>>>>>>        //*** Get the cli handle to the connection
78648>>>>>>>>>        Get phCLIHandle       To ihstmt
78649>>>>>>>>>        Get psDriverId        To sDrvrId
78650>>>>>>>>>        Get phStmtConnection  To ihdbc
78651>>>>>>>>>
78651>>>>>>>>>        //*** Get the attribute
78651>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") ;            Get SQLPrivateColAttribute iCol iAttribId ihdbc sDrvrId ihstmt To sResult
78654>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLColAttribute"
78656>>>>>>>>>
78656>>>>>>>>>        Function_Return sResult
78657>>>>>>>>>    End_Function // SQLColAttribute
78658>>>>>>>>>
78658>>>>>>>>>    Function SQLPrivateColAttribute Integer iCol Integer iAttribId Integer ihdbc String sDrvrId Integer ihstmt Returns String
78660>>>>>>>>>        Local String  sResult
78660>>>>>>>>>        Local String  sEmpty
78660>>>>>>>>>        Local Integer bIsStringAttribute
78660>>>>>>>>>        Local Integer iLen
78660>>>>>>>>>        Local Integer iVoid
78660>>>>>>>>>        Local Integer bLegalAttrib
78660>>>>>>>>>        Local Integer bLegalColumn
78660>>>>>>>>>
78660>>>>>>>>>        //*** Initialize
78660>>>>>>>>>        Move "" To sResult
78661>>>>>>>>>        Move "" To sEmpty
78662>>>>>>>>>        MOve 0  To iLen
78663>>>>>>>>>
78663>>>>>>>>>        //*** Get the attribute
78663>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
78665>>>>>>>>>            Get SQLPrivateColumnIsLegal ihdbc sDrvrId ihstmt iCol To bLegalColumn
78666>>>>>>>>>            If (bLegalColumn) Begin
78668>>>>>>>>>                //*** Determine the atributes type
78668>>>>>>>>>                Case Begin
78668>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_SIZE)
78670>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_LENGTH)
78673>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_PRECISION)
78676>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_SQLTYPE)
78679>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_NULLABLE)
78682>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_DFTYPE)
78685>>>>>>>>>                        Move DFFALSE To bIsStringAttribute
78686>>>>>>>>>                        Move DFTRUE To bLegalAttrib
78687>>>>>>>>>                        Break
78688>>>>>>>>>
78688>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_LABEL)
78691>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_BASECOLUMNNAME)
78694>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_BASETABLENAME)
78697>>>>>>>>>                        Move DFTRUE To bIsStringAttribute
78698>>>>>>>>>                        Move DFTRUE To bLegalAttrib
78699>>>>>>>>>                        Break
78700>>>>>>>>>
78700>>>>>>>>>                    Case Else
78700>>>>>>>>>                        Move DFFALSE To bLegalAttrib
78701>>>>>>>>>                        Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLPrivateColAttribute"
78702>>>>>>>>>                Case End
78702>>>>>>>>>
78702>>>>>>>>>                If (bLegalAttrib) Begin
78704>>>>>>>>>                    //*** Setup function arguments
78704>>>>>>>>>                    Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                                Callback Current_Object ;                                Passing ihdbc iCol ihstmt ;                                Result iVoid
78709>>>>>>>>>
78709>>>>>>>>>                    If (bIsStringAttribute) Begin
78711>>>>>>>>>                        //*** Call the driver function to get the data length
78711>>>>>>>>>                        Call_driver 0 sDrvrId Function FUNC_SQLCOLSTRINGATTRIBLEN ;                                    Callback Current_Object ;                                    Passing sEmpty sEmpty iAttribId ;                                    Result iLen
78716>>>>>>>>>
78716>>>>>>>>>                        If (iLen) Begin
78718>>>>>>>>>                            //*** Allocate
78718>>>>>>>>>                            Move (Repeat(' ', iLen)) To sResult
78719>>>>>>>>>
78719>>>>>>>>>                            //*** Call the driver function to get the name
78719>>>>>>>>>                            Call_driver 0 sDrvrId Function FUNC_SQLCOLSTRINGATTRIB ;                                        Callback Current_Object ;                                        Passing sResult sEmpty iAttribId ;                                        Result iVoid
78724>>>>>>>>>                        End
78724>>>>>>>>>>
78724>>>>>>>>>                    End
78724>>>>>>>>>>
78724>>>>>>>>>                    Else Begin
78725>>>>>>>>>                        //*** get the attribute
78725>>>>>>>>>                        Call_driver 0 sDrvrId Function FUNC_SQLCOLINTATTRIB ;                                    Callback Current_Object ;                                    Passing sEmpty sEmpty iAttribId ;                                    Result sResult
78730>>>>>>>>>                    End
78730>>>>>>>>>>
78730>>>>>>>>>                End
78730>>>>>>>>>>
78730>>>>>>>>>            End
78730>>>>>>>>>>
78730>>>>>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLPrivateColAttribute"
78732>>>>>>>>>        End
78732>>>>>>>>>>
78732>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateColAttribute"
78734>>>>>>>>>
78734>>>>>>>>>        Function_Return sResult
78735>>>>>>>>>    End_Function // SQLPrivateColAttribute
78736>>>>>>>>>
78736>>>>>>>>>
78736>>>>>>>>>
78736>>>>>>>>>    //***
78736>>>>>>>>>    //*** Procedure: SQLSetProcedureName
78736>>>>>>>>>    //*** Purpsoe  : Preapre for calling a stored procedure, pass the procedure name.
78736>>>>>>>>>    //***
78736>>>>>>>>>
78736>>>>>>>>>    Procedure SQLSetProcedureName String sProcName
78738>>>>>>>>>        Local Integer ihdbc
78738>>>>>>>>>        Local Integer ihstmt
78738>>>>>>>>>        Local String  sDrvrId
78738>>>>>>>>>        Local Integer iVoid
78738>>>>>>>>>        Local String  sEmpty
78738>>>>>>>>>
78738>>>>>>>>>        //*** Initialize
78738>>>>>>>>>        Move "" To sEmpty
78739>>>>>>>>>
78739>>>>>>>>>        //*** Get the cli handle to the connection
78739>>>>>>>>>        Get phCLIHandle       To ihstmt
78740>>>>>>>>>        Get psDriverId        To sDrvrId
78741>>>>>>>>>        Get phStmtConnection  To ihdbc
78742>>>>>>>>>
78742>>>>>>>>>        //*** Call the procedure
78742>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
78744>>>>>>>>>            //*** Call the procedure
78744>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLSETPROCNAME ;                        Callback Current_Object ;                        Passing ihdbc sProcName ihstmt ;                        Result iVoid
78749>>>>>>>>>
78749>>>>>>>>>            Set piLastArgument To 0
78750>>>>>>>>>        End
78750>>>>>>>>>>
78750>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetProcedurename"
78752>>>>>>>>>    End_Procedure // SQLSetProcedureName
78753>>>>>>>>>
78753>>>>>>>>>
78753>>>>>>>>>
78753>>>>>>>>>    //***
78753>>>>>>>>>    //*** Function: SQLSetNextArgument
78753>>>>>>>>>    //*** Purpose : Pass the next argument
78753>>>>>>>>>    //***
78753>>>>>>>>>
78753>>>>>>>>>    Procedure SQLSetNextArgument String sArgument
78755>>>>>>>>>        Local Integer iArgnum
78755>>>>>>>>>
78755>>>>>>>>>        Get piLastArgument To iArgnum
78756>>>>>>>>>        Increment iArgnum
78757>>>>>>>>>        Send SQLSetArgument iArgnum sArgument
78758>>>>>>>>>        Set piLastArgument To iArgnum
78759>>>>>>>>>    End_Procedure // SQLSetNextArgument
78760>>>>>>>>>
78760>>>>>>>>>
78760>>>>>>>>>
78760>>>>>>>>>    //***
78760>>>>>>>>>    //*** Procedure: SQLSetArgument
78760>>>>>>>>>    //*** Purpose  : Set the next argument
78760>>>>>>>>>    //***
78760>>>>>>>>>
78760>>>>>>>>>    Procedure SQLSetArgument Integer iArgnum String sArgument
78762>>>>>>>>>        Local Integer ihdbc
78762>>>>>>>>>        Local Integer ihstmt
78762>>>>>>>>>        Local String  sDrvrId
78762>>>>>>>>>        Local Integer iVoid
78762>>>>>>>>>        Local String  sEmpty
78762>>>>>>>>>
78762>>>>>>>>>        //*** Initialize
78762>>>>>>>>>        Move "" To sEmpty
78763>>>>>>>>>
78763>>>>>>>>>        //*** Get the cli handle to the connection
78763>>>>>>>>>        Get phCLIHandle       To ihstmt
78764>>>>>>>>>        Get psDriverId        To sDrvrId
78765>>>>>>>>>        Get phStmtConnection  To ihdbc
78766>>>>>>>>>
78766>>>>>>>>>        //*** Call the procedure
78766>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
78768>>>>>>>>>            //*** Pass the information
78768>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback Current_Object ;                        Passing ihdbc iArgnum ihstmt ;                        Result iVoid
78773>>>>>>>>>
78773>>>>>>>>>            //*** Pass the argument
78773>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLSETPROCARG ;                        Callback Current_Object ;                        Passing sArgument sEmpty 0 ;                        Result iVoid
78778>>>>>>>>>        End
78778>>>>>>>>>>
78778>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetArgument"
78780>>>>>>>>>    End_Procedure // SQLSetArgument
78781>>>>>>>>>
78781>>>>>>>>>
78781>>>>>>>>>
78781>>>>>>>>>    //***
78781>>>>>>>>>    //*** Procedure: SQLCall
78781>>>>>>>>>    //*** Purpose  : Call a stored procedure
78781>>>>>>>>>    //***
78781>>>>>>>>>
78781>>>>>>>>>    Procedure SQLCall
78783>>>>>>>>>        Local Integer ihdbc
78783>>>>>>>>>        Local Integer ihstmt
78783>>>>>>>>>        Local String  sDrvrId
78783>>>>>>>>>        Local Integer iVoid
78783>>>>>>>>>        Local String  sEmpty
78783>>>>>>>>>
78783>>>>>>>>>        //*** Initialize
78783>>>>>>>>>        Move "" To sEmpty
78784>>>>>>>>>
78784>>>>>>>>>        //*** Get the cli handle to the connection
78784>>>>>>>>>        Get phCLIHandle       To ihstmt
78785>>>>>>>>>        Get psDriverId        To sDrvrId
78786>>>>>>>>>        Get phStmtConnection  To ihdbc
78787>>>>>>>>>
78787>>>>>>>>>        //*** Call the procedure
78787>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
78789>>>>>>>>>            //*** Call the procedure
78789>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCALL ;                        Callback Current_Object ;                        Passing ihdbc sEmpty ihstmt ;                        Result iVoid
78794>>>>>>>>>
78794>>>>>>>>>            Set piLastArgument To 0
78795>>>>>>>>>        End
78795>>>>>>>>>>
78795>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLCall"
78797>>>>>>>>>    End_Procedure // SQLCall
78798>>>>>>>>>
78798>>>>>>>>>
78798>>>>>>>>>
78798>>>>>>>>>    //***
78798>>>>>>>>>    //*** Function: SQLGetNextArgument
78798>>>>>>>>>    //*** Purpose : Get the next argument
78798>>>>>>>>>    //***
78798>>>>>>>>>
78798>>>>>>>>>    Function SQLGetNextArgument Returns String
78800>>>>>>>>>        Local Integer iArgnum
78800>>>>>>>>>        Local String  sResult
78800>>>>>>>>>
78800>>>>>>>>>        Get piLastArgument To iArgnum
78801>>>>>>>>>        Increment iArgnum
78802>>>>>>>>>        Get SQLGetArgument iArgnum To sResult
78803>>>>>>>>>        Set piLastArgument To iArgnum
78804>>>>>>>>>
78804>>>>>>>>>        Function_return sResult
78805>>>>>>>>>    End_Function // SQLGetNextArgument
78806>>>>>>>>>
78806>>>>>>>>>
78806>>>>>>>>>
78806>>>>>>>>>    //***
78806>>>>>>>>>    //*** Function: SQLGetArgument
78806>>>>>>>>>    //*** Purpose : Get the specified argument from a procedure
78806>>>>>>>>>    //***
78806>>>>>>>>>
78806>>>>>>>>>    Function SQLGetArgument Integer iArgnum Returns String
78808>>>>>>>>>        Local Integer ihdbc
78808>>>>>>>>>        Local Integer ihstmt
78808>>>>>>>>>        Local String  sDrvrId
78808>>>>>>>>>        Local Integer iVoid
78808>>>>>>>>>        Local String  sEmpty
78808>>>>>>>>>        Local String  sArgument
78808>>>>>>>>>        Local Integer iLen
78808>>>>>>>>>
78808>>>>>>>>>        //*** Initialize
78808>>>>>>>>>        Move "" To sEmpty
78809>>>>>>>>>        Move "" To sArgument
78810>>>>>>>>>
78810>>>>>>>>>        //*** Get the cli handle to the connection
78810>>>>>>>>>        Get phCLIHandle       To ihstmt
78811>>>>>>>>>        Get psDriverId        To sDrvrId
78812>>>>>>>>>        Get phStmtConnection  To ihdbc
78813>>>>>>>>>
78813>>>>>>>>>        //*** Call the procedure
78813>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
78815>>>>>>>>>            //*** Pass the information
78815>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback Current_Object ;                        Passing ihdbc iArgnum ihstmt ;                        Result iVoid
78820>>>>>>>>>
78820>>>>>>>>>            //*** Get the length
78820>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLGETPROCARGLEN ;                        Callback Current_Object ;                        Passing sEmpty sEmpty 0 ;                        Result iLen
78825>>>>>>>>>
78825>>>>>>>>>            If (iLen) Begin
78827>>>>>>>>>                //*** Allocate
78827>>>>>>>>>                Move (Repeat(' ', iLen)) To sArgument
78828>>>>>>>>>
78828>>>>>>>>>                //*** Pass the argument
78828>>>>>>>>>                Call_driver 0 sDrvrId Function FUNC_SQLGETPROCARG ;                            Callback Current_Object ;                            Passing sArgument sEmpty 0 ;                            Result iVoid
78833>>>>>>>>>            End
78833>>>>>>>>>>
78833>>>>>>>>>        End
78833>>>>>>>>>>
78833>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetArgument"
78835>>>>>>>>>
78835>>>>>>>>>        Function_Return sArgument
78836>>>>>>>>>    End_Function // SQLGetArgument
78837>>>>>>>>>
78837>>>>>>>>>
78837>>>>>>>>>
78837>>>>>>>>>    //***
78837>>>>>>>>>    //*** Function: SQLReturnValue
78837>>>>>>>>>    //*** Purpose : Get the reutn value of a stored function
78837>>>>>>>>>    //***
78837>>>>>>>>>
78837>>>>>>>>>    Function SQLReturnValue Returns String
78839>>>>>>>>>        Local Integer ihdbc
78839>>>>>>>>>        Local Integer ihstmt
78839>>>>>>>>>        Local String  sDrvrId
78839>>>>>>>>>        Local Integer iVoid
78839>>>>>>>>>        Local String  sEmpty
78839>>>>>>>>>        Local String  sRetval
78839>>>>>>>>>        Local Integer iLen
78839>>>>>>>>>
78839>>>>>>>>>        //*** Initialize
78839>>>>>>>>>        Move "" To sEmpty
78840>>>>>>>>>        Move "" To sRetval
78841>>>>>>>>>
78841>>>>>>>>>        //*** Get the cli handle to the connection
78841>>>>>>>>>        Get phCLIHandle       To ihstmt
78842>>>>>>>>>        Get psDriverId        To sDrvrId
78843>>>>>>>>>        Get phStmtConnection  To ihdbc
78844>>>>>>>>>
78844>>>>>>>>>        //*** Call the procedure
78844>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
78846>>>>>>>>>            //*** Get the length
78846>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLGETPROCRETVALLEN ;                        Callback Current_Object ;                        Passing ihdbc sEmpty ihstmt  ;                        Result iLen
78851>>>>>>>>>
78851>>>>>>>>>            If (iLen) Begin
78853>>>>>>>>>                //*** Allocate
78853>>>>>>>>>                Move (Repeat(' ', iLen)) To sRetval
78854>>>>>>>>>
78854>>>>>>>>>                //*** Pass the argument
78854>>>>>>>>>                Call_driver 0 sDrvrId Function FUNC_SQLGETPROCRETVAL ;                            Callback Current_Object ;                            Passing ihdbc sRetval ihstmt ;                            Result iVoid
78859>>>>>>>>>            End
78859>>>>>>>>>>
78859>>>>>>>>>        End
78859>>>>>>>>>>
78859>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLReturnValue"
78861>>>>>>>>>
78861>>>>>>>>>        Function_Return sRetval
78862>>>>>>>>>    End_Function // SQLReturnValue
78863>>>>>>>>>
78863>>>>>>>>>
78863>>>>>>>>>
78863>>>>>>>>>    //***
78863>>>>>>>>>    //*** Function: SQLNextResultSet
78863>>>>>>>>>    //*** Purpose : Switch to the next set
78863>>>>>>>>>    //*** Returns : 0   = No more result sets
78863>>>>>>>>>    //***           <>0 = Switched to next set
78863>>>>>>>>>    //***
78863>>>>>>>>>
78863>>>>>>>>>    Function SQLNextResultSet Returns Integer
78865>>>>>>>>>        Local Integer ihdbc
78865>>>>>>>>>        Local Integer ihstmt
78865>>>>>>>>>        Local String  sDrvrId
78865>>>>>>>>>        Local String  sEmpty
78865>>>>>>>>>        Local Integer iResult
78865>>>>>>>>>
78865>>>>>>>>>        //*** Initialize
78865>>>>>>>>>        Move "" To sEmpty
78866>>>>>>>>>        Move 0  To iResult
78867>>>>>>>>>
78867>>>>>>>>>        //*** Get the cli handle to the connection
78867>>>>>>>>>        Get phCLIHandle       To ihstmt
78868>>>>>>>>>        Get psDriverId        To sDrvrId
78869>>>>>>>>>        Get phStmtConnection  To ihdbc
78870>>>>>>>>>
78870>>>>>>>>>        //*** Call the procedure
78870>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
78872>>>>>>>>>            //*** Get the length
78872>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLNEXTRESULTSET ;                        Callback Current_Object ;                        Passing ihdbc sEmpty ihstmt  ;                        Result iResult
78877>>>>>>>>>
78877>>>>>>>>>            Set piLastArgument To 0
78878>>>>>>>>>        End
78878>>>>>>>>>>
78878>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLNextResultSet"
78880>>>>>>>>>
78880>>>>>>>>>        Function_Return iResult
78881>>>>>>>>>    End_Function // SQLNextResultSet
78882>>>>>>>>>
78882>>>>>>>>>
78882>>>>>>>>>
78882>>>>>>>>>    //***
78882>>>>>>>>>    //*** Procedure: SQLFetchActivatesBuffer
78882>>>>>>>>>    //*** Purpose  : Setup a file that will be acivated after a succesfull
78882>>>>>>>>>    //***            fetch on the statement
78882>>>>>>>>>    //***
78882>>>>>>>>>
78882>>>>>>>>>    Procedure SQLFetchActivatesBuffer Integer iFileNum Integer bState
78884>>>>>>>>>        Local Integer ihdbc
78884>>>>>>>>>        Local Integer ihstmt
78884>>>>>>>>>        Local String  sDrvrId
78884>>>>>>>>>        Local Integer iResult
78884>>>>>>>>>        Local Integer bIsOpen
78884>>>>>>>>>        Local Integer iVoid
78884>>>>>>>>>        Local String  sFileType
78884>>>>>>>>>
78884>>>>>>>>>        //*** Check if file is open
78884>>>>>>>>>        Get_attribute DF_FILE_OPENED Of iFileNum To bIsOpen
78887>>>>>>>>>        If (bIsOpen) Begin
78889>>>>>>>>>            //*** Get the cli handle to the connection
78889>>>>>>>>>            Get phCLIHandle       To ihstmt
78890>>>>>>>>>            Get psDriverId        To sDrvrId
78891>>>>>>>>>            Get phStmtConnection  To ihdbc
78892>>>>>>>>>
78892>>>>>>>>>            //*** Call the procedure
78892>>>>>>>>>            If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
78894>>>>>>>>>                //*** Check if the file has the correct type
78894>>>>>>>>>                Get_attribute DF_FILE_DRIVER Of iFileNum To sFileType
78897>>>>>>>>>                If (sFileType = sDrvrId) Begin
78899>>>>>>>>>                    //*** Setup the buffer
78899>>>>>>>>>                    Call_driver iFileNum sDrvrId Function FUNC_SQLBUFFERSTATUS ;                                Callback Current_Object ;                                Passing ihdbc bState ihstmt  ;                                Result iVoid
78904>>>>>>>>>                End
78904>>>>>>>>>>
78904>>>>>>>>>                Else ;                    Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File" * String(iFileNum) * "type incompatible with statement ("  + sFileType + ")") "SQLBindFile"
78906>>>>>>>>>            End
78906>>>>>>>>>>
78906>>>>>>>>>            Else ;                Send HandleError ihstmt ihdbc sDrvrId "SQLFetchActivatesBuffer"
78908>>>>>>>>>        End
78908>>>>>>>>>>
78908>>>>>>>>>        Else ;            Send StmtError CLIERR_SQLINVALID_BUFFER ("File not open (number =" * String(iFileNum) + ")") "SQLFetchActivatesBuffer"
78910>>>>>>>>>    End_Procedure // SQLFetchActivatesBuffer
78911>>>>>>>>>
78911>>>>>>>>>End_Class // cSQLStatement
78912>>>>>>>>>
78912>>>>>>>>>
78912>>>>>>>>>//*****************************************************************************
78912>>>>>>>>>//*** Class  : cSQLConnection                                               ***
78912>>>>>>>>>//*** Purpose: Connection object for embedded SQL                           ***
78912>>>>>>>>>//***                                                                       ***
78912>>>>>>>>>//*** Description:                                                          ***
78912>>>>>>>>>//***   This provides the ability to create a connection for a driver.      ***
78912>>>>>>>>>//***   It will contain child statement objects                             ***
78912>>>>>>>>>//*****************************************************************************
78912>>>>>>>>>
78912>>>>>>>>>Class cSQLConnection is an Array
78913>>>>>>>>>
78913>>>>>>>>>    Procedure Construct_object Integer Image
78915>>>>>>>>>        Forward Send Construct_object Image
78917>>>>>>>>>
78917>>>>>>>>>        Property Integer phCLIHandle      Public 0
78918>>>>>>>>>        Property String  psDriverID       Public ""
78919>>>>>>>>>        Property Integer piBindFile       Public 0
78920>>>>>>>>>
78920>>>>>>>>>        Set Delegation_mode to NO_Delegation
78921>>>>>>>>>    End_procedure // COnstruct_object
78922>>>>>>>>>
78922>>>>>>>>>
78922>>>>>>>>>
78922>>>>>>>>>    //***
78922>>>>>>>>>    //*** Procedure: StoreHandleInfo
78922>>>>>>>>>    //*** Purpose  : Store basic information about the statement handle.
78922>>>>>>>>>    //***
78922>>>>>>>>>
78922>>>>>>>>>    Procedure StoreHandleInfo Integer iCLIHandle String sDrvrId Integer iParentHandle
78924>>>>>>>>>        Set phCLIHandle      To iCLIHandle
78925>>>>>>>>>        Set psDriverID       To sDrvrId
78926>>>>>>>>>    End_Procedure // StoreHandleInfo
78927>>>>>>>>>
78927>>>>>>>>>
78927>>>>>>>>>
78927>>>>>>>>>    //***
78927>>>>>>>>>    //*** Procedure: FreeHandle
78927>>>>>>>>>    //*** Purpose : Destroys handle object and all child statement objects
78927>>>>>>>>>    //***
78927>>>>>>>>>    Procedure FreeHandle
78929>>>>>>>>>        Send Destroy_Object
78930>>>>>>>>>    End_Procedure // FreeHandle
78931>>>>>>>>>
78931>>>>>>>>>
78931>>>>>>>>>
78931>>>>>>>>>    //***
78931>>>>>>>>>    //*** Function: SQLConnect
78931>>>>>>>>>    //*** Purpose : Make a connectin to an embedded SQL server
78931>>>>>>>>>    //*** Returns : The DataFlex handle to the connection
78931>>>>>>>>>    //***
78931>>>>>>>>>
78931>>>>>>>>>    Function SQLConnect string sDrvrID String sConnect Returns Integer
78933>>>>>>>>>        Local Integer ihdbc
78933>>>>>>>>>        Local String  sEmpty
78933>>>>>>>>>
78933>>>>>>>>>        //*** Initialize
78933>>>>>>>>>        Move "" To sEmpty
78934>>>>>>>>>        Move 0  To ihdbc
78935>>>>>>>>>
78935>>>>>>>>>        Indicate Err False
78936>>>>>>>>>
78936>>>>>>>>>        //*** Call the driver function to connect
78936>>>>>>>>>        Call_driver 0 sDrvrId Function FUNC_SQLCONNECT ;                    Callback current_object ;                    Passing sConnect sEmpty 0 ;                    Result ihdbc
78941>>>>>>>>>
78941>>>>>>>>>        //*** If there was an error, make result invalid
78941>>>>>>>>>        If (Err) ;            Move 0 To ihdbc
78944>>>>>>>>>
78944>>>>>>>>>        //*** Check result and store it
78944>>>>>>>>>        If (ihdbc <> 0) ;            Send StoreHandleInfo ihdbc sDrvrId 0
78947>>>>>>>>>
78947>>>>>>>>>        //*** Return success status
78947>>>>>>>>>        Function_Return (ihdbc <> 0)
78948>>>>>>>>>    End_function // SQLConnect
78949>>>>>>>>>
78949>>>>>>>>>
78949>>>>>>>>>
78949>>>>>>>>>    //***
78949>>>>>>>>>    //*** Function: SQLFileConnect
78949>>>>>>>>>    //*** Purpose : Use a connection of an already open file
78949>>>>>>>>>    //***
78949>>>>>>>>>
78949>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
78951>>>>>>>>>        Local Integer ihdbc
78951>>>>>>>>>        Local Integer bIsOpen
78951>>>>>>>>>        Local String  sDrvrId
78951>>>>>>>>>        Local String  sEmpty
78951>>>>>>>>>
78951>>>>>>>>>        //*** Initialize
78951>>>>>>>>>        Move "" To sEmpty
78952>>>>>>>>>        Move 0  To ihdbc
78953>>>>>>>>>
78953>>>>>>>>>        //*** Check if file is open
78953>>>>>>>>>        Get_attribute DF_FILE_OPENED Of iFileNum To bIsOpen
78956>>>>>>>>>        If (bIsOpen) Begin
78958>>>>>>>>>            //*** Fill the driver id, assume longest is 255 characters
78958>>>>>>>>>            Move (Repeat(' ', 255)) To sDrvrId
78959>>>>>>>>>            Get_attribute DF_FILE_DRIVER Of iFileNum To sDrvrId
78962>>>>>>>>>
78962>>>>>>>>>            Indicate Err False
78963>>>>>>>>>
78963>>>>>>>>>            //*** Call the driver function to connect
78963>>>>>>>>>            Call_driver iFileNum sDrvrId Function FUNC_SQLFILECONNECT ;                        Callback current_object ;                        Passing sEmpty sEmpty 0 ;                        Result ihdbc
78968>>>>>>>>>
78968>>>>>>>>>            //*** If there was an error, make result invalid
78968>>>>>>>>>            If (Err) ;                Move 0 To ihdbc
78971>>>>>>>>>
78971>>>>>>>>>            //*** Check result and store it
78971>>>>>>>>>            If (ihdbc <> 0) Begin
78973>>>>>>>>>                //*** Somehow Call_driver overwrites the sDrvrId variable, restore it here
78973>>>>>>>>>                Get_attribute DF_FILE_DRIVER Of iFileNum To sDrvrId
78976>>>>>>>>>                Send StoreHandleInfo ihdbc sDrvrId 0
78977>>>>>>>>>
78977>>>>>>>>>                //*** Set filenum so it can be used for fetching
78977>>>>>>>>>                Set piBindFile To iFileNum
78978>>>>>>>>>            End
78978>>>>>>>>>>
78978>>>>>>>>>        End
78978>>>>>>>>>>
78978>>>>>>>>>
78978>>>>>>>>>        //*** Return success status
78978>>>>>>>>>        Function_Return (ihdbc <> 0)
78979>>>>>>>>>    End_Function // SQLFileConnect
78980>>>>>>>>>
78980>>>>>>>>>
78980>>>>>>>>>
78980>>>>>>>>>    //***
78980>>>>>>>>>    //*** Procedure: SQLDisconnect
78980>>>>>>>>>    //*** Purpose  : Disconnect from an embedded SQL server and free allocated
78980>>>>>>>>>    //***            resources
78980>>>>>>>>>    //***
78980>>>>>>>>>
78980>>>>>>>>>    Procedure SQLDisconnect
78982>>>>>>>>>        Local Integer ihdbc
78982>>>>>>>>>        Local Integer iVoid
78982>>>>>>>>>        Local String  sDrvrId
78982>>>>>>>>>        Local String  sEmpty
78982>>>>>>>>>
78982>>>>>>>>>        //*** Initialize
78982>>>>>>>>>        Move "" To sEmpty
78983>>>>>>>>>
78983>>>>>>>>>        //*** Get the cli handle
78983>>>>>>>>>        Get phCLIHandle To ihdbc
78984>>>>>>>>>        Get psDriverId To sDrvrId
78985>>>>>>>>>
78985>>>>>>>>>        //*** Free the CLI handle
78985>>>>>>>>>        If (ihdbc <> 0) Begin
78987>>>>>>>>>            //*** Call the driver function to disconnect
78987>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLDISCONNECT ;                        Callback Current_object ;                        Passing sEmpty sEmpty ihdbc ;                        Result iVoid
78992>>>>>>>>>
78992>>>>>>>>>            //*** Free the DataFlex handle
78992>>>>>>>>>            Send FreeHandle
78993>>>>>>>>>        End
78993>>>>>>>>>>
78993>>>>>>>>>    End_Procedure // SQLDisconnect
78994>>>>>>>>>
78994>>>>>>>>>
78994>>>>>>>>>
78994>>>>>>>>>    //***
78994>>>>>>>>>    //*** Function: CreateHandle
78994>>>>>>>>>    //*** Purpose : Creates a child statement handle
78994>>>>>>>>>    //***
78994>>>>>>>>>
78994>>>>>>>>>    Function CreateHandle Returns Integer
78996>>>>>>>>>        Local Integer hSQL
78996>>>>>>>>>
78996>>>>>>>>>        Object oSQLStatement Is A cSQLStatement
78998>>>>>>>>>            Move current_object To hSQL
78999>>>>>>>>>        End_Object // oSQLStatement
79000>>>>>>>>>
79000>>>>>>>>>        //*** If the connection has a default Bind File, assign it to the
79000>>>>>>>>>        //*** statement object. The default is set when you open a file with a
79000>>>>>>>>>        //*** SetFileConnection command.
79000>>>>>>>>>        Set piBindFile Of hSQL To (piBindFile(Current_object))
79001>>>>>>>>>
79001>>>>>>>>>        Function_Return hSQL
79002>>>>>>>>>    End_Function // CreateHandle
79003>>>>>>>>>
79003>>>>>>>>>
79003>>>>>>>>>
79003>>>>>>>>>    //***
79003>>>>>>>>>    //*** Function: SQLOpen
79003>>>>>>>>>    //*** Prupose : Open a statement for use
79003>>>>>>>>>    //***
79003>>>>>>>>>
79003>>>>>>>>>    Function SQLOpen Returns Integer
79005>>>>>>>>>        Local Integer hDFHandle
79005>>>>>>>>>        Local Integer ihdbc
79005>>>>>>>>>        Local Integer ihstmt
79005>>>>>>>>>        Local Integer iVoid
79005>>>>>>>>>        Local String  sDrvrId
79005>>>>>>>>>        Local String  sEmpty
79005>>>>>>>>>
79005>>>>>>>>>        //*** Initialize
79005>>>>>>>>>        Move "" To sEmpty
79006>>>>>>>>>
79006>>>>>>>>>        //*** Get the cli handle to the connection
79006>>>>>>>>>        Get phCLIHandle To ihdbc
79007>>>>>>>>>        Get psDriverId  To sDrvrId
79008>>>>>>>>>
79008>>>>>>>>>        //*** Allocate a new handle and populate it
79008>>>>>>>>>        If (ihdbc <> 0) Begin
79010>>>>>>>>>            //**** Create a new DataFlex handle
79010>>>>>>>>>            Get CreateHandle To hDFHandle
79011>>>>>>>>>
79011>>>>>>>>>            //*** Call the driver function to allocate a statement handle
79011>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLOPEN ;                        Callback Current_object ;                        Passing hDFHandle sEmpty ihdbc ;                        Result ihstmt
79016>>>>>>>>>
79016>>>>>>>>>            //*** If unsuccessful destroy DF side info
79016>>>>>>>>>            If (ihstmt = 0) Begin
79018>>>>>>>>>                Send FreeHandle to hDFHandle
79019>>>>>>>>>                Move 0 to hDFHandle
79020>>>>>>>>>            End
79020>>>>>>>>>>
79020>>>>>>>>>            Else ;                Send StoreHandleInfo to hDFHandle ihstmt sDrvrId ihdbc
79022>>>>>>>>>        End
79022>>>>>>>>>>
79022>>>>>>>>>
79022>>>>>>>>>        Function_return hDFHandle
79023>>>>>>>>>    End_function // SQLOpen
79024>>>>>>>>>
79024>>>>>>>>>End_Class // cSQLConnection
79025>>>>>>>>>
79025>>>>>>>>>
79025>>>>>>>>>
79025>>>>>>>>>//*****************************************************************************
79025>>>>>>>>>//*** Class  : cSQLHandlemanager                                            ***
79025>>>>>>>>>//*** Purpose: Manager for embedded SQL handles.                            ***
79025>>>>>>>>>//***                                                                       ***
79025>>>>>>>>>//*** Description:                                                          ***
79025>>>>>>>>>//***   We want to be able to use multiple drivers and multiple             ***
79025>>>>>>>>>//***   connections within a driver and multiple statements within a        ***
79025>>>>>>>>>//***   connection. To allow this we have palced our own handle logic on    ***
79025>>>>>>>>>//***   top of the driver handle logic. This way we can handle the          ***
79025>>>>>>>>>//***   situation where two driver handles may be equal.                    ***
79025>>>>>>>>>//*****************************************************************************
79025>>>>>>>>>
79025>>>>>>>>>Class cSQLHandleManager Is A Array
79026>>>>>>>>>
79026>>>>>>>>>    Procedure Construct_object Integer Image
79028>>>>>>>>>        Forward Send Construct_object Image
79030>>>>>>>>>
79030>>>>>>>>>        Property String  psDefaultDriver     Public ""
79031>>>>>>>>>        Property String  psDefaultConnection Public ""
79032>>>>>>>>>
79032>>>>>>>>>        Set Delegation_mode to NO_Delegation
79033>>>>>>>>>    End_procedure // COnstruct_object
79034>>>>>>>>>
79034>>>>>>>>>
79034>>>>>>>>>
79034>>>>>>>>>    //***
79034>>>>>>>>>    //*** Function: CreateHandle
79034>>>>>>>>>    //*** Purpose : Allocate memory for the desired type of handle
79034>>>>>>>>>    //***
79034>>>>>>>>>
79034>>>>>>>>>    Function CreateHandle Returns Integer
79036>>>>>>>>>        Local Integer hSQL
79036>>>>>>>>>
79036>>>>>>>>>        //*** Create a connection object
79036>>>>>>>>>        Object oSQLConnection Is A cSQLConnection
79038>>>>>>>>>            Move current_object To hSQL
79039>>>>>>>>>        End_Object // oSQLConnection
79040>>>>>>>>>
79040>>>>>>>>>        Function_Return hSQL
79041>>>>>>>>>    End_Function // CreateHandle
79042>>>>>>>>>
79042>>>>>>>>>
79042>>>>>>>>>
79042>>>>>>>>>    //***
79042>>>>>>>>>    //*** Procedure: SQLSetConnect
79042>>>>>>>>>    //*** Purpose  : Store default connection information
79042>>>>>>>>>    //***
79042>>>>>>>>>
79042>>>>>>>>>    Procedure SQLSetConnect String sDriver String sConnect
79044>>>>>>>>>        Set psDefaultDriver      To sDriver
79045>>>>>>>>>        Set psDefaultConnection  To sConnect
79046>>>>>>>>>    End_Procedure // SQLSetConnect
79047>>>>>>>>>
79047>>>>>>>>>
79047>>>>>>>>>
79047>>>>>>>>>    //***
79047>>>>>>>>>    //*** Function: SQLConnect
79047>>>>>>>>>    //*** Purpose : Make a connectin to an embedded SQL server
79047>>>>>>>>>    //*** Returns : The DataFlex handle to the connection
79047>>>>>>>>>    //***
79047>>>>>>>>>
79047>>>>>>>>>    Function SQLConnect String sDrvrID String sConnect Returns integer
79049>>>>>>>>>        Local Integer hDFHandle
79049>>>>>>>>>        Local Integer bOK
79049>>>>>>>>>
79049>>>>>>>>>        //*** Check arguments
79049>>>>>>>>>        If (sDrvrID = "" And sConnect = "") Begin
79051>>>>>>>>>            Get psDefaultDriver      To sDrvrId
79052>>>>>>>>>            Get psDefaultConnection  To sConnect
79053>>>>>>>>>        End
79053>>>>>>>>>>
79053>>>>>>>>>
79053>>>>>>>>>        //*** Allocate a new handle
79053>>>>>>>>>        Get CreateHandle To hDFHandle
79054>>>>>>>>>        Get SQLConnect of hDFHandle sDrvrID sConnect To bOK
79055>>>>>>>>>
79055>>>>>>>>>        //*** If failure, kill the handle and return a 0 handle
79055>>>>>>>>>        If (Not(bOK)) Begin
79057>>>>>>>>>            Send FreeHandle to hDFHandle
79058>>>>>>>>>            Move 0 to hDFHandle
79059>>>>>>>>>        End
79059>>>>>>>>>>
79059>>>>>>>>>
79059>>>>>>>>>        Function_return hDFHandle
79060>>>>>>>>>    End_function // SQLConnect
79061>>>>>>>>>
79061>>>>>>>>>
79061>>>>>>>>>
79061>>>>>>>>>    //***
79061>>>>>>>>>    //*** Function: SQLFileConnect
79061>>>>>>>>>    //*** Purpose : Make an existing connection available for use with Embedded
79061>>>>>>>>>    //***           SQL. The connection is identified by the number opf a file
79061>>>>>>>>>    //***           that is open for that connection.
79061>>>>>>>>>    //***
79061>>>>>>>>>
79061>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
79063>>>>>>>>>        Local Integer hDFHandle
79063>>>>>>>>>        Local Integer bOK
79063>>>>>>>>>
79063>>>>>>>>>        //*** Allocate a new handle
79063>>>>>>>>>        Get CreateHandle To hDFHandle
79064>>>>>>>>>        Get SQLFileConnect of hDFHandle iFileNum To bOK
79065>>>>>>>>>
79065>>>>>>>>>        //*** If failure, kill the handle and return a 0 handle
79065>>>>>>>>>        If (Not(bOK)) Begin
79067>>>>>>>>>            Send FreeHandle to hDFHandle
79068>>>>>>>>>            Move 0 to hDFHandle
79069>>>>>>>>>        End
79069>>>>>>>>>>
79069>>>>>>>>>
79069>>>>>>>>>        Function_return hDFHandle
79070>>>>>>>>>    End_Function // SQLFileConnect
79071>>>>>>>>>
79071>>>>>>>>>End_Class // cSQLHandleManager
79072>>>>>>>>>
79072>>>>>>>>>
79072>>>>>>>>>
79072>>>>>>>>>//***
79072>>>>>>>>>//*** Function: CreateSQLManager
79072>>>>>>>>>//*** Purpose : Create the embedded SQL manager, this is an internal function!
79072>>>>>>>>>//***
79072>>>>>>>>>
79072>>>>>>>>>Function CreateSQLmanager For Desktop Returns Integer
79074>>>>>>>>>    Local Integer hoSQlMngr
79074>>>>>>>>>
79074>>>>>>>>>    Object oSQLHandleManager Is A cSQLHandleManager
79076>>>>>>>>>        MOve Current_object To hoSQLMngr
79077>>>>>>>>>    End_Object // oSQLHandleManager
79078>>>>>>>>>
79078>>>>>>>>>    Function_Return hoSQLMngr
79079>>>>>>>>>End_Function // CreateSQLMngr
79080>>>>>>>>>
79080>>>>>>>>>//*** Make sure the object is global by creating it under DESKTOP
79080>>>>>>>>>Get CreateSQLManager Of Desktop To _embsqlghoSQLHandleMngr
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>//*** Command: SQLSetConnect                                                ***
79081>>>>>>>>>//*** Purpose: Setup default connection information for embedded SQL.       ***
79081>>>>>>>>>//***                                                                       ***
79081>>>>>>>>>//*** Syntax : SQLSetConnect sSDriverId sConnectString                      ***
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>//*** Command: SQLConnect                                                   ***
79081>>>>>>>>>//*** Purpose: Connect to a server for embedded SQL usage.                  ***
79081>>>>>>>>>//***                                                                       ***
79081>>>>>>>>>//*** Syntax : SQLConnect To hdbc                                           ***
79081>>>>>>>>>//***          SQLConnect [sDriverId sConnectString] To hdbc                ***
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>//*** Command: SQLFileConnect                                               ***
79081>>>>>>>>>//*** Purpsoe: Return the handle to a connection of an open file. This      ***
79081>>>>>>>>>//***          connection is (obviously) already opened. We are just using  ***
79081>>>>>>>>>//***          the same connection for Embedded SQL. This allows the        ***
79081>>>>>>>>>//***          programmer not to know connection details.                   ***
79081>>>>>>>>>//***                                                                       ***
79081>>>>>>>>>//*** Syntax : SQLFileConnect Filex To hdbc                                 ***
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>//*** Command: SQLDisconnect                                                ***
79081>>>>>>>>>//*** Purpose: Connect to a server for embedded SQL usage.                  ***
79081>>>>>>>>>//***                                                                       ***
79081>>>>>>>>>//*** Syntax : SQLDisConnect hdbc                                           ***
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>//*** Command: SQLOpen                                                      ***
79081>>>>>>>>>//*** Purpose: Allocate the memory to stroe statement information.          ***
79081>>>>>>>>>//***                                                                       ***
79081>>>>>>>>>//*** Syntax : SQLOpen hdbc To hstmt                                        ***
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>//*** Command: SQLClose                                                     ***
79081>>>>>>>>>//*** Purpose: Close a statement and free all associated memory.            ***
79081>>>>>>>>>//***                                                                       ***
79081>>>>>>>>>//*** Syntax : SQLClose hstmt                                               ***
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>//*** Command: SQLPrepare                                                   ***
79081>>>>>>>>>//*** Purpose: Prepare a statement for execution.                           ***
79081>>>>>>>>>//***                                                                       ***
79081>>>>>>>>>//*** Syntax : SQLPrepare hstmt sStatement                                  ***
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>//*** Command: SQLExecute                                                   ***
79081>>>>>>>>>//*** Purpose: Execute a prepared statement                                 ***
79081>>>>>>>>>//***                                                                       ***
79081>>>>>>>>>//*** Syntax : SQLExecute hstmt                                             ***
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>//*** Command: SQLExecDirect                                                ***
79081>>>>>>>>>//*** Purpose: Prepare and execute a statement.                             ***
79081>>>>>>>>>//***                                                                       ***
79081>>>>>>>>>//*** Syntax : SQLExecDirect hstmt sStatement                               ***
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>//*** Command: SQLFileFetch                                                 ***
79081>>>>>>>>>//*** Purpose: Get a row from a statement result set.                       ***
79081>>>>>>>>>//***                                                                       ***
79081>>>>>>>>>//*** Syntax : SQLFileFetch hstmt [To File1 [File2 ...]]                    ***
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>//*** Command: SQLBindFetchFile                                             ***
79081>>>>>>>>>//*** Purpose: Binds a file number to a statement so it can be used for     ***
79081>>>>>>>>>//***          fetching data. Only needed in non fileconnect. Note that     ***
79081>>>>>>>>>//***          can be assigned to the connection or the statement handle    ***
79081>>>>>>>>>//***                                                                       ***
79081>>>>>>>>>//*** Syntax : SQLBindFileForFetch hstmt|hdbc FileName|FileNumber           ***
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>//*** Command: SQLFetch                                                     ***
79081>>>>>>>>>//*** Purpose: Get a row from a statement result set.                       ***
79081>>>>>>>>>//***                                                                       ***
79081>>>>>>>>>//*** Syntax : SQLFetch hstmt [To Var1 [Var2 ...]]                          ***
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>//*** Command: SQLGetData                                                   ***
79081>>>>>>>>>//*** Purpose: Get a column's data.                                         ***
79081>>>>>>>>>//***                                                                       ***
79081>>>>>>>>>//*** Syntax : SQLGetData hstmt iColumnNUmber [Length iLen] To Var          ***
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>//*** Command: SQLColumnMap                                                 ***
79081>>>>>>>>>//*** Purpose: Determine the column number based on the column name.        ***
79081>>>>>>>>>//***                                                                       ***
79081>>>>>>>>>//*** Syntax : SQLColumnMap hstmt sColName To iColNumber                    ***
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>//*** Command: SQLColAttribute                                              ***
79081>>>>>>>>>//*** Purpose: Get an attribute of a column in a statements result set.     ***
79081>>>>>>>>>//***                                                                       ***
79081>>>>>>>>>//*** Syntax : SQLColAttribute hstmt iCol iAttrId To sAttrib                ***
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>//*** Command: SQLStmtAttribute                                             ***
79081>>>>>>>>>//*** Purpose: Get an atribute of a statement.                              ***
79081>>>>>>>>>//***                                                                       ***
79081>>>>>>>>>//*** Syntax : SQLStmtAttribute hstmt iAttribId To sAttrib                  ***
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>//*** Command: SQLCall                                                      ***
79081>>>>>>>>>//*** Purpose: Call a stored procedure.                                     ***
79081>>>>>>>>>//***                                                                       ***
79081>>>>>>>>>//*** Syntax : SQLCall hstmt ProcedureName [Arg1 ...] [To Var]              ***
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>//*** Command: SQLGetArguments                                              ***
79081>>>>>>>>>//*** Purpsoe: Get the arguments of a stored procedure. This command should ***
79081>>>>>>>>>//***          be used when a procedure has multiple result sets. Some      ***
79081>>>>>>>>>//***          backends (SQL SErver for example) will return these as the   ***
79081>>>>>>>>>//***          last result set. This emans you first process all other      ***
79081>>>>>>>>>//***          result sets and then get the arguments and return value.     ***
79081>>>>>>>>>//***                                                                       ***
79081>>>>>>>>>//*** Syntax : SQLGetArguments hstmt [Arg1...] [To Var]                     ***
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>//*** Command: SQLNextResultSet                                             ***
79081>>>>>>>>>//*** Purpose: Go the the next result set. This command should be used when ***
79081>>>>>>>>>//***          a procedure call results in multiple result sets. Processing ***
79081>>>>>>>>>//***          such procedures can be done by loping through the result     ***
79081>>>>>>>>>//***          sets.                                                        ***
79081>>>>>>>>>//***                                                                       ***
79081>>>>>>>>>//*** Syntax : SQLNextResultSet hstmt                                       ***
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>//*** Command: SQLFetchActivatesBuffer                                      ***
79081>>>>>>>>>//*** Purpose: Setup fetch behavior for a file. When set to true a          ***
79081>>>>>>>>>//***          succesfull fetch of the statement resutl set will            ***
79081>>>>>>>>>//***          automatically set the status of the file's bufer to          ***
79081>>>>>>>>>//***          DF_FILE_ACTIVE.                                              ***
79081>>>>>>>>>//***                                                                       ***
79081>>>>>>>>>//*** Syntax : SQLFetchActivatesBuffer hstmt FileNUmber|FileName sState     ***
79081>>>>>>>>>//*****************************************************************************
79081>>>>>>>>>
79081>>>>>>>>>//Doc/ Ignore=False
79081>>>>>>>
79081>>>>>>>// defines interface for cWindowMesageHook - currently a private runtime class
79081>>>>>>>Define     U_DFWINDOWSMESSAGEHOOK  for |CI0106
79081>>>>>>>Define     GET_ENABLEWINDOWSHOOK   for |CI$0542
79081>>>>>>>Define     MSG_DISABLEWINDOWSHOOK  for |CI$0543
79081>>>>>>>Define     GET_ONWINDOWSHOOK       for |CI$0544
79081>>>>>>>Define     WH_MOUSE for 7
79081>>>>>>>Define     WH_KEYBOARD for 2
79081>>>>>>>
79081>>>>>>>
79081>>>>>>>// suggestion lists use a global timer and a global suggestion list
79081>>>>>>>Global_Variable Handle ghoSuggestionList 
79081>>>>>>>Move 0 to ghoSuggestionList
79082>>>>>>>
79082>>>>>>>Global_Variable Handle ghoSuggestionTimer
79082>>>>>>>Move 0 to ghoSuggestionTimer
79083>>>>>>>
79083>>>>>>>// this will get created the first time it is needed. 
79083>>>>>>>Class cSuggestionTimer is a cTimer
79084>>>>>>>
79084>>>>>>>    Procedure Construct_Object
79086>>>>>>>        Forward Send Construct_Object
79088>>>>>>>        Property Handle phoTimerOwner 0
79089>>>>>>>        Set piTimeout to 50
79090>>>>>>>    End_Procedure
79091>>>>>>>  
79091>>>>>>>    Procedure OnTimer 
79093>>>>>>>        Handle hoOwner
79093>>>>>>>        Get phoTimerOwner to hoOwner
79094>>>>>>>        // do this in case progam close destroys owner before timer
79094>>>>>>>        Get Object_Id of hoOwner to hoOwner
79095>>>>>>>        If hoOwner Begin
79097>>>>>>>            Send OnSuggestionTimer to hoOwner
79098>>>>>>>        End
79098>>>>>>>>
79098>>>>>>>        Else Begin
79099>>>>>>>            // something wrong, shut off timer
79099>>>>>>>            Set pbEnabled to False   
79100>>>>>>>        End                                
79100>>>>>>>>
79100>>>>>>>    End_Procedure
79101>>>>>>>    
79101>>>>>>>End_Class
79102>>>>>>>
79102>>>>>>>Class cSuggestionHookMouse is a DFWindowsMessageHook
79103>>>>>>>    
79103>>>>>>>    // If mouse not in suggestion list or form, close suggestionlist
79103>>>>>>>    Function OnWindowsHook Integer i1 Integer i2 Integer i3 Returns Integer
79105>>>>>>>        tWinMouseHookStruct MouseHook
79105>>>>>>>        tWinMouseHookStruct MouseHook
79105>>>>>>>        Integer ivoid hObj
79105>>>>>>>        Handle hoOwner hoParent
79105>>>>>>>        If (i1=0 and (i2=WM_LBUTTONDOWN or i2=WM_RBUTTONDOWN or i2=WM_MBUTTONDOWN or ;                      i2=WM_NCLBUTTONDOWN or i2=WM_NCRBUTTONDOWN or i2=WM_NCMBUTTONDOWN)) Begin
79107>>>>>>>            Move (CopyMemory(AddressOf(MouseHook), i3, SizeOfType(tWinMouseHookStruct))) to iVoid
79108>>>>>>>            GET_OBJECT_FROM_WINDOW MouseHook.hwnd to hObj
79109>>>>>>>            Get Parent to hoParent
79110>>>>>>>            Get phoOwner of hoParent to hoOwner
79111>>>>>>>            If (not(hObj) or (hObj<>hoParent and hObj<>hoOwner)) Begin
79113>>>>>>>                Send DisableWindowsHook
79114>>>>>>>                Send DeActivateSuggestionList of hoOwner
79115>>>>>>>            End
79115>>>>>>>>
79115>>>>>>>        End
79115>>>>>>>>
79115>>>>>>>    End_Function
79116>>>>>>>
79116>>>>>>>    Procedure End_Construct_Object
79118>>>>>>>        Boolean bOk
79118>>>>>>>        Forward Send End_Construct_Object
79120>>>>>>>        Get EnableWindowsHook WH_MOUSE to bOk 
79121>>>>>>>    End_Procedure
79122>>>>>>>
79122>>>>>>>End_Class
79123>>>>>>>
79123>>>>>>>Class cSuggestionHookKbd is a DFWindowsMessageHook
79124>>>>>>>    
79124>>>>>>>    // If menu key, close suggestionlist
79124>>>>>>>    Function OnWindowsHook Integer i1 Integer i2 Integer i3 Returns Integer
79126>>>>>>>        Handle hoOwner
79126>>>>>>>        If (i1=0 and i2=VK_MENU) Begin
79128>>>>>>>            Delegate Get phoOwner to hoOwner
79130>>>>>>>            Send DisableWindowsHook
79131>>>>>>>            Send DeActivateSuggestionList of hoOwner
79132>>>>>>>        End
79132>>>>>>>>
79132>>>>>>>    End_Function
79133>>>>>>>    
79133>>>>>>>    Procedure End_Construct_Object
79135>>>>>>>        Boolean bOk
79135>>>>>>>        Forward Send End_Construct_Object
79137>>>>>>>        Get EnableWindowsHook WH_KEYBOARD  to bOk  
79138>>>>>>>    End_Procedure
79139>>>>>>>
79139>>>>>>>End_Class
79140>>>>>>>
79140>>>>>>>Class cSuggestionList is a cRichEdit
79141>>>>>>>    
79141>>>>>>>    Procedure Construct_Object
79143>>>>>>>        Handle hoObj
79143>>>>>>>        Forward Send Construct_Object
79145>>>>>>>        Property Handle phoOwner
79146>>>>>>>        Set Focus_Mode to NonFocusable
79147>>>>>>>        Set Attach_Parent_State to True
79148>>>>>>>        Set pbWrap to False
79149>>>>>>>        If (ghoSuggestionList) Begin
79151>>>>>>>            Send Destroy of ghoSuggestionList
79152>>>>>>>        End
79152>>>>>>>>
79152>>>>>>>        Get CreateNamed (RefClass(cSuggestionHookMouse)) "oMouseHook" to hoObj
79153>>>>>>>        Get CreateNamed (RefClass(cSuggestionHookKbd))"oKbdHook" to hoObj
79154>>>>>>>    End_Procedure
79155>>>>>>>    
79155>>>>>>>    Procedure Destroy_Object
79157>>>>>>>        Forward Send Destroy_Object
79159>>>>>>>        Move 0 to ghoSuggestionList
79160>>>>>>>    End_Procedure
79161>>>>>>>    
79161>>>>>>>    Procedure DeactivateList
79163>>>>>>>        Set pbEnabled of ghoSuggestionTimer to False
79164>>>>>>>        Send Deactivate
79165>>>>>>>        Send Destroy
79166>>>>>>>    End_Procedure
79167>>>>>>>    
79167>>>>>>>    Procedure InitList Handle hoForm
79169>>>>>>>        Integer iSize iLoc iLoc2
79169>>>>>>>        Get GuiSize of hoForm to iSize
79170>>>>>>>        Set GuiSize to (Hi(iSize)) (1000)
79171>>>>>>>        Get Absolute_GUIOrigin of hoForm to iLoc
79172>>>>>>>        Delegate Get Absolute_GUIOrigin to iLoc2
79174>>>>>>>        Set GuiLocation to (Hi(iLoc)-Hi(iLoc2)+Hi(iSize)+2) (Low(iLoc)+2-Low(iLoc2))
79175>>>>>>>        Set Visible_State to False
79176>>>>>>>    End_Procedure
79177>>>>>>>    
79177>>>>>>>    // scroll up one line
79177>>>>>>>    Procedure ScrollUp
79179>>>>>>>        Integer iLine
79179>>>>>>>        Get SelectedRow to iLine
79180>>>>>>>        If (iLine) Begin
79182>>>>>>>            Send SelectRow (iLine-1)
79183>>>>>>>        End
79183>>>>>>>>
79183>>>>>>>    End_Procedure
79184>>>>>>>    
79184>>>>>>>    // scroll down one line
79184>>>>>>>    Procedure ScrollDown
79186>>>>>>>        Integer iLine iLines
79186>>>>>>>        Get Line_Count to iLines
79187>>>>>>>        Get SelectedRow to iLine
79188>>>>>>>        // there can be an extra line at the end
79188>>>>>>>        If (iLine<iLines-1) Begin
79190>>>>>>>            Send SelectRow (iLine+1)
79191>>>>>>>        End
79191>>>>>>>>
79191>>>>>>>    End_Procedure
79192>>>>>>>    
79192>>>>>>>    // sets the current line to iLine and highlights it
79192>>>>>>>    Procedure SelectRow Integer iLine
79194>>>>>>>        Integer iPos iLen
79194>>>>>>>        Get FirstCharInLinePos iLine to iPos
79195>>>>>>>        Get LineLength iLine to iLen
79196>>>>>>>        Send SetSel iPos (iPos+iLen)
79197>>>>>>>    End_Procedure
79198>>>>>>>    
79198>>>>>>>    // get the current selected Line
79198>>>>>>>    Function SelectedRow Returns Integer
79200>>>>>>>        Integer iLine
79200>>>>>>>        Get LineFromChar -1 to iLine
79201>>>>>>>        Function_Return iLine
79202>>>>>>>    End_Function
79203>>>>>>>
79203>>>>>>>    // select the current row 
79203>>>>>>>    Procedure Mouse_Up Integer hCell Integer iPos
79205>>>>>>>        Handle hoObj
79205>>>>>>>        Get phoOwner to hoObj
79206>>>>>>>        Send Activate of hoObj // move focus to owner, which will close the list
79207>>>>>>>        Send SelectSuggestion of hoObj
79208>>>>>>>    End_Procedure // Mouse_Up
79209>>>>>>>      
79209>>>>>>>End_Class
79210>>>>>>>
79210>>>>>>>// This contains mixin support for suggestion logic and contains the interface that
79210>>>>>>>// is accessed publicly. This should be mixed into the form or column DEO object
79210>>>>>>>Class cSuggestion_mixin is a Mixin
79211>>>>>>>    
79211>>>>>>>    Procedure Define_cSuggestion_mixin
79213>>>>>>>        
79213>>>>>>>        Property Integer peSuggestionMode smFind
79214>>>>>>>        Property Boolean pbFullText False
79215>>>>>>>        Property Boolean pbCaseSensitive False
79216>>>>>>>        Property Integer piMaxResults 15
79217>>>>>>>        Property Integer piStartAtChar 2
79218>>>>>>>        Property Boolean pbFullWidth True
79219>>>>>>>        Property Integer piFindIndex 0
79220>>>>>>>        Property Boolean pbFindOnSelect True
79221>>>>>>>        Property Integer piPopupTimeout 50
79222>>>>>>>        
79222>>>>>>>        Property tSuggestion[] pSearchResults
79223>>>>>>>
79223>>>>>>>        Property Handle phcSuggestionListClass (RefClass(cSuggestionList))
79224>>>>>>>        
79224>>>>>>>    End_Procedure
79225>>>>>>>    
79225>>>>>>>    // Display one Suggestion Line in Suggestion List. Good for augmentation although
79225>>>>>>>    // this must be done carefully as you must know the suggestionlist interface, which
79225>>>>>>>    // if private
79225>>>>>>>    Procedure ShowSuggestion tSuggestion SuggestionData String sSearch
79227>>>>>>>        Integer i iCols iPos
79227>>>>>>>        String sValue
79227>>>>>>>        Integer eSuggestionMode
79227>>>>>>>        Boolean bFullText
79227>>>>>>>        
79227>>>>>>>        Get peSuggestionMode to eSuggestionMode
79228>>>>>>>        Get pbFullText to bFullText
79229>>>>>>>        
79229>>>>>>>        Move SuggestionData.aValues[0] to sValue
79230>>>>>>>        If (not(bFullText)) Begin
79232>>>>>>>            Set pbBold of ghoSuggestionList to True
79233>>>>>>>            Send AppendText of ghoSuggestionList (Left(sValue,Length(sSearch))) 
79234>>>>>>>            Set pbBold of ghoSuggestionList to False
79235>>>>>>>            Send AppendText of ghoSuggestionList (Mid(sValue,255,Length(sSearch)+1)) 
79236>>>>>>>        End
79236>>>>>>>>
79236>>>>>>>        Else Begin
79237>>>>>>>            Set pbBold of ghoSuggestionList to False
79238>>>>>>>            Move (Pos(Uppercase(sSearch),Uppercase(sValue))) to iPos
79239>>>>>>>            If (iPos) Begin
79241>>>>>>>                Send AppendText of ghoSuggestionList (Left(sValue,iPos-1)) 
79242>>>>>>>                Set pbBold of ghoSuggestionList to True
79243>>>>>>>                Send AppendText of ghoSuggestionList (Mid(sValue,Length(sSearch),iPos)) 
79244>>>>>>>                Set pbBold of ghoSuggestionList to False
79245>>>>>>>            End
79245>>>>>>>>
79245>>>>>>>            Send AppendText of ghoSuggestionList (Mid(sValue,255,iPos+Length(sSearch))) 
79246>>>>>>>        End
79246>>>>>>>>
79246>>>>>>>        
79246>>>>>>>        // if addiitonal columns (usually validation) we assume the first value is the one that is
79246>>>>>>>        // matched and we display all other values (usually just one) to the
79246>>>>>>>        // right of it. 
79246>>>>>>>        Move (SizeOfArray(SuggestionData.aValues)) to iCols
79247>>>>>>>        If (iCols>1) Begin
79249>>>>>>>            Move "" to sValue
79250>>>>>>>            For i from 1 to (iCols-1)
79256>>>>>>>>
79256>>>>>>>                Move (sValue + If(i=1," - ","  ") + SuggestionData.aValues[i]) to sValue
79257>>>>>>>            Loop
79258>>>>>>>>
79258>>>>>>>            Send AppendText of ghoSuggestionList sValue
79259>>>>>>>        End
79259>>>>>>>>
79259>>>>>>>    End_Procedure
79260>>>>>>>    
79260>>>>>>>    // used to catch a set_field_value_Error
79260>>>>>>>    Procedure Error_Report Integer iError Integer iLine String sErr
79262>>>>>>>    End_Procedure
79263>>>>>>>    
79263>>>>>>>    // does a Set_Field_Value with error testing around it.
79263>>>>>>>    Function SafeSetFieldValue Integer iFile Integer iField String sValue Returns Boolean
79265>>>>>>>        Handle hoOldError
79265>>>>>>>        Boolean bErr
79265>>>>>>>        Move Error_Object_Id to hoOldError
79266>>>>>>>        Move Self to Error_Object_Id
79267>>>>>>>        Move False to Err 
79268>>>>>>>        Set_Field_Value iFile iField to sValue
79271>>>>>>>        Move Err to bErr
79272>>>>>>>        Move hoOldError to Error_Object_Id
79273>>>>>>>        Function_Return bErr        
79274>>>>>>>    End_Function
79275>>>>>>>
79275>>>>>>>
79275>>>>>>>    Procedure SuggestionsFindIncremental String sSearch tSuggestion[] ByRef aSuggestions
79277>>>>>>>        Integer iFile iField iIndex iLen iRow iMax eType iLength iDec
79277>>>>>>>        Handle hoServer
79277>>>>>>>        Boolean bContinue bCase bOldRelate bNeedsRelate bInvalid
79277>>>>>>>        String sVal sLowSearch
79277>>>>>>>        RowID riTest
79277>>>>>>>        
79277>>>>>>>        Get Server to hoServer
79278>>>>>>>        Get Data_File  to iFile
79279>>>>>>>        Get Data_Field to iField       
79280>>>>>>>        
79280>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
79282>>>>>>>            Get piFindIndex to iIndex
79283>>>>>>>            Get piMaxResults to iMax
79284>>>>>>>            Get pbCaseSensitive to bCase
79285>>>>>>>            
79285>>>>>>>            Get_Attribute DF_FIELD_TYPE of iFile iField to eType
79288>>>>>>>            Get_Attribute DF_FIELD_LENGTH of iFile iField to iLength
79291>>>>>>>            Get_Attribute DF_FIELD_PRECISION of iFile iField to iDec
79294>>>>>>>            
79294>>>>>>>            Move (iLength - iDec) to iLength
79295>>>>>>>            
79295>>>>>>>            If (iIndex <= 0) Begin
79297>>>>>>>                Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
79300>>>>>>>            End
79300>>>>>>>>
79300>>>>>>>            
79300>>>>>>>            
79300>>>>>>>            
79300>>>>>>>            If (iIndex > 0) Begin
79302>>>>>>>                Get No_Relate_State of hoServer to bOldRelate
79303>>>>>>>                Get DDOConstraintNeedsRelate of hoServer iIndex to bNeedsRelate
79304>>>>>>>                Set No_Relate_State of hoServer to (not(bNeedsRelate))
79305>>>>>>>                                
79305>>>>>>>                Move True to bContinue
79306>>>>>>>                Move (Length(sSearch)) to iLen
79307>>>>>>>                Move (Lowercase(sSearch)) to sLowSearch
79308>>>>>>>                Move 0 to iRow
79309>>>>>>>                
79309>>>>>>>                //  Find first record
79309>>>>>>>                Send Request_Read of hoServer FIRST_RECORD iFile iIndex
79310>>>>>>>                Get SafeSetFieldValue iFile iField sSearch to bInvalid
79311>>>>>>>                If bInvalid Begin
79313>>>>>>>                    Move False to bContinue
79314>>>>>>>                End
79314>>>>>>>>
79314>>>>>>>                
79314>>>>>>>                If (bContinue) Begin
79316>>>>>>>                    Send Request_Read of hoServer GE iFile iIndex
79317>>>>>>>                End
79317>>>>>>>>
79317>>>>>>>                
79317>>>>>>>                While (Found and bContinue)
79321>>>>>>>                    Get_Field_Value iFile iField to sVal
79324>>>>>>>                    
79324>>>>>>>                    If ((not(bCase) and Lowercase(Left(sVal, iLen)) = sLowSearch) or (bCase and Left(sVal, iLen) = sSearch)) Begin
79326>>>>>>>
79326>>>>>>>                        Move (SerializeRowID(GetRowID(iFile)))  to aSuggestions[iRow].sRowId
79327>>>>>>>                        Move (Trim(sVal))                       to aSuggestions[iRow].aValues[0]
79328>>>>>>>                        Increment iRow
79329>>>>>>>                        
79329>>>>>>>                        Move (iRow < iMax) to bContinue
79330>>>>>>>                       
79330>>>>>>>                        Send Request_Read of hoServer GT iFile iIndex  
79331>>>>>>>                    End
79331>>>>>>>>
79331>>>>>>>                    Else Begin
79332>>>>>>>                        If (eType = DF_BCD and Length(sSearch) < iLength) Begin
79334>>>>>>>                            //  For numeric fields we'll jump in the index to the next possible value (for example from 40 to 400)
79334>>>>>>>                            
79334>>>>>>>                            Move (GetRowID(iFile)) to riTest
79335>>>>>>>                            
79335>>>>>>>                            Move (sSearch * 10) to sSearch
79336>>>>>>>                            
79336>>>>>>>                            Get SafeSetFieldValue iFile iField sSearch to bInvalid
79337>>>>>>>                            If bInvalid Begin
79339>>>>>>>                                Move False to bContinue
79340>>>>>>>                            End
79340>>>>>>>>
79340>>>>>>>                            Else Begin
79341>>>>>>>                                Send Request_Read of hoServer GE iFile iIndex
79342>>>>>>>                                Move (not(IsSameRowID(riTest, GetRowID(iFile)))) to bContinue
79343>>>>>>>                            End 
79343>>>>>>>>
79343>>>>>>>                        End
79343>>>>>>>>
79343>>>>>>>                        Else Begin
79344>>>>>>>                            Move False to bContinue
79345>>>>>>>                        End
79345>>>>>>>>
79345>>>>>>>                    End
79345>>>>>>>>
79345>>>>>>>                    
79345>>>>>>>                Loop
79346>>>>>>>>
79346>>>>>>>                Set No_Relate_State of hoServer to bOldRelate
79347>>>>>>>            End
79347>>>>>>>>
79347>>>>>>>        End
79347>>>>>>>>
79347>>>>>>>    End_Procedure
79348>>>>>>>    
79348>>>>>>>    Procedure SuggestionsFindFullText String sSearch tSuggestion[] ByRef aSuggestions
79350>>>>>>>        Integer iFile iField iIndex iRow iMax
79350>>>>>>>        Handle hoServer
79350>>>>>>>        Boolean bContinue bCase  bOldRelate bNeedsRelate
79350>>>>>>>        String sVal sLowSearch
79350>>>>>>>        
79350>>>>>>>        Get Server to hoServer
79351>>>>>>>        Get Data_File  to iFile
79352>>>>>>>        Get Data_Field to iField       
79353>>>>>>>        
79353>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
79355>>>>>>>            Get piMaxResults to iMax
79356>>>>>>>            Get pbCaseSensitive to bCase
79357>>>>>>>            
79357>>>>>>>            Get piFindIndex to iIndex
79358>>>>>>>            If (iIndex <= 0) Begin
79360>>>>>>>                Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
79363>>>>>>>            End
79363>>>>>>>>
79363>>>>>>>            
79363>>>>>>>            Get No_Relate_State of hoServer to bOldRelate
79364>>>>>>>            Get DDOConstraintNeedsRelate of hoServer iIndex to bNeedsRelate
79365>>>>>>>            Set No_Relate_State of hoServer to (not(bNeedsRelate))
79366>>>>>>>            
79366>>>>>>>            
79366>>>>>>>            Move (Lowercase(sSearch)) to sLowSearch
79367>>>>>>>            Move True to bContinue
79368>>>>>>>            Move 0 to iRow
79369>>>>>>>                
79369>>>>>>>            //  Find first record
79369>>>>>>>            Send Request_Read of hoServer FIRST_RECORD iFile iIndex
79370>>>>>>>            
79370>>>>>>>            While (Found and (iRow < iMax))
79374>>>>>>>                Get_Field_Value iFile iField to sVal
79377>>>>>>>                
79377>>>>>>>                If ((bCase and sVal contains sSearch) or (not(bCase) and Lowercase(sVal) contains sLowSearch)) Begin
79379>>>>>>>                    Move (SerializeRowID(GetRowID(iFile)))  to aSuggestions[iRow].sRowId
79380>>>>>>>                    Move (Trim(sVal))                       to aSuggestions[iRow].aValues[0]
79381>>>>>>>                    Increment iRow
79382>>>>>>>                End
79382>>>>>>>>
79382>>>>>>>                
79382>>>>>>>                Send Request_Read of hoServer GT iFile iIndex 
79383>>>>>>>            Loop
79384>>>>>>>>
79384>>>>>>>            Set No_Relate_State of hoServer to bOldRelate
79385>>>>>>>        End
79385>>>>>>>>
79385>>>>>>>    End_Procedure
79386>>>>>>>    
79386>>>>>>>    Procedure SuggestionsSQLFullText String sSearch tSuggestion[] ByRef aSuggestions
79388>>>>>>>        Integer iFile iField iIndex iRow iMax
79388>>>>>>>        Handle hoServer
79388>>>>>>>        Boolean bContinue bOrigActive  bOldRelate bNeedsRelate
79388>>>>>>>        String sVal sOrigFilter sFilter sFile sField
79388>>>>>>>        
79388>>>>>>>        Get Server to hoServer
79389>>>>>>>        Get Data_File  to iFile
79390>>>>>>>        Get Data_Field to iField       
79391>>>>>>>        
79391>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
79393>>>>>>>            
79393>>>>>>>            // make sure we send DD messages to owner DDO
79393>>>>>>>            Get Which_Data_Set of hoServer iFile to hoServer
79394>>>>>>>            If (hoServer=0) Begin
79396>>>>>>>                Procedure_Return
79397>>>>>>>            End
79397>>>>>>>>
79397>>>>>>>            
79397>>>>>>>            Get piMaxResults to iMax
79398>>>>>>>            Get piFindIndex to iIndex
79399>>>>>>>            If (iIndex <= 0) Begin
79401>>>>>>>                Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
79404>>>>>>>            End
79404>>>>>>>>
79404>>>>>>>            
79404>>>>>>>            //  Determine current filter settings
79404>>>>>>>            Get psSQLFilter of hoServer to sOrigFilter
79405>>>>>>>            Get pbUseDDSqlFilters of hoServer to bOrigActive
79406>>>>>>>            
79406>>>>>>>            // generate the Like filter string
79406>>>>>>>            Get SQLStrLike of hoServer iField sSearch to sFilter
79407>>>>>>>            // If filtering was active append this to what's there
79407>>>>>>>            If (bOrigActive) Begin
79409>>>>>>>                Get SQLStrAppend of hoServer sOrigFilter sFilter to sFilter
79410>>>>>>>            End
79410>>>>>>>>
79410>>>>>>>            
79410>>>>>>>            //  Set filter
79410>>>>>>>            Set psSQLFilter of hoServer to sFilter
79411>>>>>>>            Set pbUseDDSqlFilters of hoServer to True
79412>>>>>>>            
79412>>>>>>>            
79412>>>>>>>            // this will optimize No_relate. If your DF constraint does not
79412>>>>>>>            // need a post-relate test, we will disabled relates for this
79412>>>>>>>            Get No_Relate_State of hoServer to bOldRelate
79413>>>>>>>            Get DDOConstraintNeedsRelate of hoServer iIndex to bNeedsRelate
79414>>>>>>>            Set No_Relate_State of hoServer to (not(bNeedsRelate))
79415>>>>>>>
79415>>>>>>>            //  Find records
79415>>>>>>>            Move True to bContinue
79416>>>>>>>            Move 0 to iRow
79417>>>>>>>            
79417>>>>>>>            Send Request_Read of hoServer FIRST_RECORD iFile iIndex
79418>>>>>>>            
79418>>>>>>>            While (bContinue)
79422>>>>>>>                Get_Field_Value iFile iField to sVal
79425>>>>>>>                
79425>>>>>>>                If (Found) Begin // and ((bCase and sVal contains sSearch) or (not(bCase) and Lowercase(sVal) contains sLowSearch))) Begin
79427>>>>>>>                    Move (SerializeRowID(GetRowID(iFile)))  to aSuggestions[iRow].sRowId
79428>>>>>>>                    Move (Trim(sVal))                       to aSuggestions[iRow].aValues[0]
79429>>>>>>>                    Increment iRow
79430>>>>>>>                    
79430>>>>>>>                    Move (iRow < iMax) to bContinue
79431>>>>>>>                   
79431>>>>>>>                    Send Request_Read of hoServer GT iFile iIndex 
79432>>>>>>>                End
79432>>>>>>>>
79432>>>>>>>                Else Begin
79433>>>>>>>                    Move False to bContinue
79434>>>>>>>                End
79434>>>>>>>>
79434>>>>>>>                
79434>>>>>>>            Loop
79435>>>>>>>>
79435>>>>>>>            
79435>>>>>>>            //  Restore filters
79435>>>>>>>            Set psSQLFilter of hoServer to sOrigFilter
79436>>>>>>>            Set pbUseDDSqlFilters of hoServer to bOrigActive
79437>>>>>>>            Set No_Relate_State of hoServer to bOldRelate
79438>>>>>>>        End
79438>>>>>>>>
79438>>>>>>>    End_Procedure
79439>>>>>>>    
79439>>>>>>>    Procedure SuggestionsValidation String sSearch tSuggestion[] ByRef aSuggestions Boolean bFullText
79441>>>>>>>        Handle hoServer hoTable
79441>>>>>>>        Integer iFile iField iRow iCount iFound iMax iLen
79441>>>>>>>        Variant[][] aData
79442>>>>>>>        Boolean bCaseSensitive bContinue
79442>>>>>>>        String sDescr sVal
79442>>>>>>>        
79442>>>>>>>        Get Server to hoServer
79443>>>>>>>        Get Data_File  to iFile
79444>>>>>>>        Get Data_Field to iField       
79445>>>>>>>        
79445>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
79447>>>>>>>            Get File_Field_Table_Object of hoServer iFile iField to hoTable
79448>>>>>>>            If (hoTable <> 0) Begin
79450>>>>>>>                Get tabledata of hoTable to aData
79451>>>>>>>        
79451>>>>>>>                Get piMaxResults to iMax
79452>>>>>>>                Get pbCaseSensitive to bCaseSensitive  
79453>>>>>>>            
79453>>>>>>>                If (not(bCaseSensitive)) Begin
79455>>>>>>>                    Move (Lowercase(sSearch)) to sSearch
79456>>>>>>>                End
79456>>>>>>>>
79456>>>>>>>                
79456>>>>>>>                
79456>>>>>>>                Move (SizeOfArray(aData)) to iCount
79457>>>>>>>                Move 0 to iRow
79458>>>>>>>                Move (Length(sSearch)) to iLen
79459>>>>>>>                Move True to bContinue
79460>>>>>>>                
79460>>>>>>>            
79460>>>>>>>                While (iFound < iMax and iRow < iCount and bContinue)
79464>>>>>>>                    If (not(bCaseSensitive)) Begin
79466>>>>>>>                        Move (Lowercase(aData[iRow][0])) to sVal
79467>>>>>>>                        Move (Lowercase(aData[iRow][1])) to sDescr
79468>>>>>>>                    End
79468>>>>>>>>
79468>>>>>>>                    Else Begin
79469>>>>>>>                        Move aData[iRow][0] to sVal
79470>>>>>>>                        Move aData[iRow][1] to sDescr
79471>>>>>>>                    End
79471>>>>>>>>
79471>>>>>>>                    
79471>>>>>>>                    If ((bFullText and (sVal contains sSearch)) or (not(bFullText) and (Left(sVal, iLen) = sSearch))) Begin
79473>>>>>>>                        Move aData[iRow][0] to aSuggestions[iFound].sRowId
79474>>>>>>>                        Move aData[iRow][0] to aSuggestions[iFound].aValues[0]
79475>>>>>>>                        Move aData[iRow][1] to aSuggestions[iFound].aValues[1]
79476>>>>>>>                        Increment iFound
79477>>>>>>>                    End
79477>>>>>>>>
79477>>>>>>>                    Else Begin
79478>>>>>>>                        Move (bFullText or iFound = 0) to bContinue
79479>>>>>>>                    End
79479>>>>>>>>
79479>>>>>>>                    
79479>>>>>>>                    Increment iRow
79480>>>>>>>                Loop
79481>>>>>>>>
79481>>>>>>>            End
79481>>>>>>>>
79481>>>>>>>        End
79481>>>>>>>>
79481>>>>>>>         
79481>>>>>>>    End_Procedure
79482>>>>>>>    
79482>>>>>>>    
79482>>>>>>>    Procedure OnFindSuggestions String sSearch tSuggestion[] ByRef aSuggestions
79484>>>>>>>        Integer iMode iFile
79484>>>>>>>        Boolean bFullText bResult bSupportsSQL
79484>>>>>>>        Handle hoServer
79484>>>>>>>        
79484>>>>>>>        Get Server to hoServer
79485>>>>>>>        Get Data_File  to iFile
79486>>>>>>>        
79486>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
79488>>>>>>>            
79488>>>>>>>            Get peSuggestionMode to iMode
79489>>>>>>>            Get pbFullText to bFullText
79490>>>>>>>            
79490>>>>>>>            If (iMode = smFind) Begin
79492>>>>>>>                If (not(bFullText)) Begin
79494>>>>>>>                    Send SuggestionsFindIncremental sSearch (&aSuggestions)
79495>>>>>>>                End
79495>>>>>>>>
79495>>>>>>>                Else Begin
79496>>>>>>>                    Get SupportsSQLFilters of hoServer to bSupportsSQL
79497>>>>>>>                    If (bSupportsSQL) Begin
79499>>>>>>>                        Send SuggestionsSQLFullText sSearch (&aSuggestions)
79500>>>>>>>                    End
79500>>>>>>>>
79500>>>>>>>                    Else Begin
79501>>>>>>>                        Send SuggestionsFindFullText sSearch (&aSuggestions)
79502>>>>>>>                    End
79502>>>>>>>>
79502>>>>>>>                End
79502>>>>>>>>
79502>>>>>>>            End
79502>>>>>>>>
79502>>>>>>>            Else If (iMode = smValidationTable) Begin
79505>>>>>>>                Send SuggestionsValidation sSearch (&aSuggestions) bFullText
79506>>>>>>>            End
79506>>>>>>>>
79506>>>>>>>        End
79506>>>>>>>>
79506>>>>>>>    End_Procedure
79507>>>>>>>    
79507>>>>>>>    Procedure OnSelectSuggestion String sSearch tSuggestion Suggestion
79509>>>>>>>        Handle hoServer
79509>>>>>>>        Integer iFile iField iMode
79509>>>>>>>        Boolean bFind
79509>>>>>>>        RowID rRowId
79509>>>>>>>        
79509>>>>>>>        Get Server to hoServer
79510>>>>>>>        Get Data_File  to iFile
79511>>>>>>>        Get Data_Field to iField       
79512>>>>>>>        
79512>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
79514>>>>>>>            Get peSuggestionMode to iMode
79515>>>>>>>            
79515>>>>>>>            If (iMode = smFind) Begin
79517>>>>>>>                Get pbFindOnSelect to bFind
79518>>>>>>>                If (bFind) Begin
79520>>>>>>>                    Move (DeserializeRowID(Suggestion.sRowId)) to rRowId    
79521>>>>>>>                    
79521>>>>>>>                    If (not(IsNullRowID(rRowId))) Begin
79523>>>>>>>                        Send FindByRowId of hoServer iFile rRowId
79524>>>>>>>                    End
79524>>>>>>>>
79524>>>>>>>                End
79524>>>>>>>>
79524>>>>>>>                Else Begin
79525>>>>>>>                    Set Value to Suggestion.aValues[0]
79526>>>>>>>                    Set Item_Changed_State to True
79527>>>>>>>                End
79527>>>>>>>>
79527>>>>>>>            End
79527>>>>>>>>
79527>>>>>>>            Else If (imode = smValidationTable) Begin
79530>>>>>>>                Set Value to Suggestion.sRowId
79531>>>>>>>                Set Item_Changed_State to True
79532>>>>>>>            End
79532>>>>>>>>
79532>>>>>>>            
79532>>>>>>>        End
79532>>>>>>>>
79532>>>>>>>    End_Procedure
79533>>>>>>>    
79533>>>>>>>    // Return true if Suggestion should be invoked. Can be augmented
79533>>>>>>>    Function ShouldSuggestion String sValue Boolean bChanged Returns Boolean
79535>>>>>>>        Integer iStartAtChar
79535>>>>>>>        Get piStartAtChar to iStartAtChar
79536>>>>>>>        Function_Return (bChanged and Length(sValue)>=iStartAtChar)
79537>>>>>>>    End_Function
79538>>>>>>>    
79538>>>>>>>    
79538>>>>>>>End_Class
79539>>>>>>>
79539>>>>>>>
79539>>>>>>>// This contains logic that deals with the Windows object. It relies on the interface in 
79539>>>>>>>// sSuggestion_mixin, which means it must be mixed in as a sibling of this object (as is done
79539>>>>>>>// in dbSuggestionForm or as a child of this object (as is done in cDbCJGridColumnSuggestion), which
79539>>>>>>>// means messages are resolved via delegation. sSuggestion_mixin does not send messages to this class.
79539>>>>>>>// Note that cSuggestion_mixin and cSuggestionControl_mixin are designed so they can be mixed in at
79539>>>>>>>// the same level or mixed in such that cSuggestionControl_mixin is in the child object and cSuggestion_mixin
79539>>>>>>>// is in the parent
79539>>>>>>> 
79539>>>>>>>Class cSuggestionControl_mixin is a Mixin
79540>>>>>>>    
79540>>>>>>>    Procedure Define_cSuggestionControl_mixin
79542>>>>>>>        
79542>>>>>>>        Property Integer piTimeOutTicks 0
79543>>>>>>>        
79543>>>>>>>        On_Key kEnter Send SelectSuggestion
79544>>>>>>>        On_Key Key_Escape Send DeActivateSuggestionList
79545>>>>>>>        On_Key Key_Up_Arrow Send Up
79546>>>>>>>        On_Key Key_Down_Arrow Send Down
79547>>>>>>>
79547>>>>>>>    End_Procedure
79548>>>>>>>
79548>>>>>>>    Procedure AdjustSuggestionListSize Integer iLines
79550>>>>>>>        Integer i  iX iMax iY
79550>>>>>>>        String sTxt
79550>>>>>>>        Boolean bFullWidth
79550>>>>>>>        For i from 0 to (iLines-1)
79556>>>>>>>>
79556>>>>>>>            Get Line of ghoSuggestionList i to sTxt
79557>>>>>>>            Get Text_Extent of ghoSuggestionList sTxt to iX
79558>>>>>>>            Move (Low(iX) max iMax) to iMax
79559>>>>>>>            Move (Hi(iX)) to iY
79560>>>>>>>        Loop
79561>>>>>>>>
79561>>>>>>>        Move (iMax + 20) to imax
79562>>>>>>>        Get pbFullWidth to bFullWidth
79563>>>>>>>        If bFullWidth Begin
79565>>>>>>>            Move (iMax max (Low(GuiSize(Self)))) to iMax
79566>>>>>>>        End
79566>>>>>>>>
79566>>>>>>>        If (iLines) Begin
79568>>>>>>>            Set GuiSize of ghoSuggestionList to (iY*(iLines)+8) iMax
79569>>>>>>>            Send SelectRow of ghoSuggestionList 0 // go to first line
79570>>>>>>>        End
79570>>>>>>>>
79570>>>>>>>        Else Begin
79571>>>>>>>            Set GuiSize of ghoSuggestionList to (Hi(GuiSize(Self))) (low(GuiSize(Self)))
79572>>>>>>>        End
79572>>>>>>>>
79572>>>>>>>    End_Procedure
79573>>>>>>>    
79573>>>>>>>    // show all suggestions
79573>>>>>>>    Procedure ShowSuggestions
79575>>>>>>>        tSuggestion[] aResults
79575>>>>>>>        tSuggestion[] aResults
79576>>>>>>>        Integer i iLines
79576>>>>>>>        String sSearch 
79576>>>>>>>        Get pSearchResults to aResults
79577>>>>>>>        Get Value to sSearch
79578>>>>>>>        Send Delete_Data of ghoSuggestionList
79579>>>>>>>        Move (SizeOfArray(aResults)) to iLines
79580>>>>>>>        For i from 0 to (iLines-1)
79586>>>>>>>>
79586>>>>>>>            Send ShowSuggestion aResults[i] sSearch
79587>>>>>>>            If ((iLines-1)<>i) Begin
79589>>>>>>>                Send AppendTextLn of ghoSuggestionList ""
79590>>>>>>>            End
79590>>>>>>>>
79590>>>>>>>        Loop
79591>>>>>>>>
79591>>>>>>>        Send AdjustSuggestionListSize iLines
79592>>>>>>>    End_Procedure
79593>>>>>>>
79593>>>>>>>    Procedure FindSuggestions 
79595>>>>>>>        String sSearch
79595>>>>>>>        tSuggestion[] aResults
79595>>>>>>>        tSuggestion[] aResults
79596>>>>>>>        String[] aParams
79597>>>>>>>        Get Value to sSearch
79598>>>>>>>        Send OnFindSuggestions sSearch (&aResults)
79599>>>>>>>        Set pSearchResults to aResults
79600>>>>>>>        // if an error was raised, the suggestion list will be gone
79600>>>>>>>        If (ghoSuggestionList) Begin
79602>>>>>>>            Send ShowSuggestions
79603>>>>>>>        End
79603>>>>>>>>
79603>>>>>>>    End_Procedure
79604>>>>>>>
79604>>>>>>>    Procedure SelectSuggestion 
79606>>>>>>>        String sSearch
79606>>>>>>>        tSuggestion[] aData
79606>>>>>>>        tSuggestion[] aData
79607>>>>>>>        Integer iSelRow
79607>>>>>>>        If ghoSuggestionList Begin
79609>>>>>>>            Get SelectedRow of ghoSuggestionList to iSelRow
79610>>>>>>>            Get Value to sSearch
79611>>>>>>>            Get pSearchResults to aData        
79612>>>>>>>            Send DeActivateSuggestionList
79613>>>>>>>            Send CancelEditIfGrid
79614>>>>>>>            If (iSelRow>=0 and SizeOfArray(aData)>iSelRow) Begin
79616>>>>>>>                Send OnSelectSuggestion sSearch aData[iSelRow] 
79617>>>>>>>            End
79617>>>>>>>>
79617>>>>>>>        End
79617>>>>>>>>
79617>>>>>>>        Else Begin
79618>>>>>>>            Send Default_Action
79619>>>>>>>        End
79619>>>>>>>>
79619>>>>>>>    End_Procedure
79620>>>>>>>    
79620>>>>>>>    Procedure CancelEditIfGrid
79622>>>>>>>        // do nothing with forms, remember
79622>>>>>>>        // to replace or augment with grid to
79622>>>>>>>        // cancel the edit control
79622>>>>>>>    End_Procedure
79623>>>>>>>
79623>>>>>>>    
79623>>>>>>>    Function ParentForSuggestion Returns Handle
79625>>>>>>>        Handle hoMain hoMainPanel
79625>>>>>>>
79625>>>>>>>        // we must have an application object and a main panel object
79625>>>>>>>        If ghoApplication Begin
79627>>>>>>>            Get phoMainPanel of ghoApplication to hoMainPanel
79628>>>>>>>        End
79628>>>>>>>>
79628>>>>>>>        If (hoMainPanel=0 or Self<=Desktop) Begin
79630>>>>>>>            Function_Return 0
79631>>>>>>>        End
79631>>>>>>>>
79631>>>>>>>
79631>>>>>>>        Move Self to hoMain
79632>>>>>>>        Repeat
79632>>>>>>>>
79632>>>>>>>            Get Parent of hoMain to hoMain
79633>>>>>>>        Until (hoMain=Desktop or Block_Mouse_State(hoMain) or hoMainPanel=hoMain)
79635>>>>>>>
79635>>>>>>>        Function_Return (If(hoMain>Desktop,hoMain,0))
79636>>>>>>>        
79636>>>>>>>    End_Function
79637>>>>>>>    
79637>>>>>>>    Procedure ActivateSuggestionList
79639>>>>>>>        Handle hoView hcSuggest
79639>>>>>>>        Get ParentForSuggestion to hoView
79640>>>>>>>        If hoView Begin
79642>>>>>>>            Get phcSuggestionListClass to hcSuggest
79643>>>>>>>            Get CreateNamed of hoView hcSuggest "oSuggestList" to ghoSuggestionList
79644>>>>>>>            Send InitList of ghoSuggestionList Self
79645>>>>>>>            Set Focus_Mode of ghoSuggestionList to Focusable
79646>>>>>>>            Set phoOwner of ghoSuggestionList to Self
79647>>>>>>>            Send Add_Focus of ghoSuggestionList hoView
79648>>>>>>>        End
79648>>>>>>>>
79648>>>>>>>    End_Procedure
79649>>>>>>>    
79649>>>>>>>    Procedure DeActivateSuggestionList
79651>>>>>>>        If ghoSuggestionList Begin
79653>>>>>>>            Send DeactivateList of ghoSuggestionList
79654>>>>>>>        End
79654>>>>>>>>
79654>>>>>>>    End_Procedure
79655>>>>>>>    
79655>>>>>>>    // augment to kill suggest list if focus is not moving to it  
79655>>>>>>>    // customized for grid
79655>>>>>>>    Procedure OnKillFocus
79657>>>>>>>        // note focus has already changed here
79657>>>>>>>        If (ghoSuggestionList) Begin
79659>>>>>>>            If (Focus(Self)<>ghoSuggestionList) Begin
79661>>>>>>>                Send DeActivateSuggestionList
79662>>>>>>>                Forward Send OnKillFocus
79664>>>>>>>            End
79664>>>>>>>>
79664>>>>>>>            Else Begin
79665>>>>>>>                // giving focus to the suggestion list here
79665>>>>>>>            End
79665>>>>>>>>
79665>>>>>>>        End
79665>>>>>>>>
79665>>>>>>>        Else Begin
79666>>>>>>>            Forward Send OnKillFocus
79668>>>>>>>        End
79668>>>>>>>>
79668>>>>>>>    End_Procedure
79669>>>>>>>    
79669>>>>>>>    Procedure Up
79671>>>>>>>        If (Focus(Desktop) = Self and ghoSuggestionList) Begin
79673>>>>>>>           Send ScrollUp of ghoSuggestionList
79674>>>>>>>        End
79674>>>>>>>>
79674>>>>>>>    End_Procedure
79675>>>>>>>
79675>>>>>>>    Procedure Down
79677>>>>>>>        If (Focus(Desktop) = Self and ghoSuggestionList) Begin
79679>>>>>>>           Send ScrollDown of ghoSuggestionList
79680>>>>>>>        End
79680>>>>>>>>
79680>>>>>>>    End_Procedure
79681>>>>>>>    
79681>>>>>>>
79681>>>>>>>    Procedure Key Integer iKey
79683>>>>>>>        Integer iEndTicks
79683>>>>>>>        
79683>>>>>>>        If (Focus(Desktop) <> Self) Begin
79685>>>>>>>          Forward Send Key iKey
79687>>>>>>>          Procedure_Return
79688>>>>>>>        End
79688>>>>>>>>
79688>>>>>>>        
79688>>>>>>>        Send DeActivateSuggestionList
79689>>>>>>>        Move (GetTickCount()) to iEndTicks
79690>>>>>>>        // record the time of key press
79690>>>>>>>        If (piTimeOutTicks(Self) = 0) Begin
79692>>>>>>>         
79692>>>>>>>            If (ghoSuggestionTimer=0) Begin
79694>>>>>>>               Send CreateSuggestionTimer
79695>>>>>>>            End
79695>>>>>>>>
79695>>>>>>>         
79695>>>>>>>            Set pbEnabled of ghoSuggestionTimer to True
79696>>>>>>>            Set phoTimerOwner of ghoSuggestionTimer to Self
79697>>>>>>>        End
79697>>>>>>>>
79697>>>>>>>        Set piTimeOutTicks to iEndTicks
79698>>>>>>>        
79698>>>>>>>        Forward Send Key iKey
79700>>>>>>>    End_Procedure
79701>>>>>>>    
79701>>>>>>>    Procedure CreateSuggestionTimer
79703>>>>>>>        Handle hoMainPanel
79703>>>>>>>        // we must have an application object and a main panel object
79703>>>>>>>        If ghoApplication Begin
79705>>>>>>>            Get phoMainPanel of ghoApplication to hoMainPanel
79706>>>>>>>        End
79706>>>>>>>>
79706>>>>>>>        If (hoMainPanel=0) Begin
79708>>>>>>>            Error DFERR_PROGRAM "Auto-suggest requires an application object and a main panel object"
79709>>>>>>>>
79709>>>>>>>            Procedure_Return
79710>>>>>>>        End
79710>>>>>>>>
79710>>>>>>>        Get CreateNamed of hoMainPanel (RefClass(cSuggestionTimer)) "oSuggestionTimer" to ghoSuggestionTimer
79711>>>>>>>    End_Procedure
79712>>>>>>>  
79712>>>>>>>    // sent by Auto Suggest Timer. Invoke suggestion list as needed
79712>>>>>>>    Procedure OnSuggestionTimer
79714>>>>>>>        Boolean bDoIt
79714>>>>>>>        Integer iEndTicks iStartTicks iTicks iTimeOut iChanged
79714>>>>>>>        String sValue
79714>>>>>>>        
79714>>>>>>>        If (Focus(Desktop) <> Self) Begin
79716>>>>>>>            // focus out of whack. Stop the timer
79716>>>>>>>            Set pbEnabled of ghoSuggestionTimer to False
79717>>>>>>>            Send DeActivateSuggestionList   
79718>>>>>>>            Procedure_Return
79719>>>>>>>        End                                
79719>>>>>>>>
79719>>>>>>>
79719>>>>>>>        Get piTimeOutTicks to iStartTicks
79720>>>>>>>        If (iStartTicks <> 0) Begin           
79722>>>>>>>            Move (GetTickCount()) to iEndTicks 
79723>>>>>>>            Move (iEndTicks - iStartTicks) to iTicks
79724>>>>>>>            // If tick count rolled over
79724>>>>>>>            If (iTicks < 0) Begin
79726>>>>>>>                Move (-iTicks) to iTicks 
79727>>>>>>>            End
79727>>>>>>>>
79727>>>>>>>        End
79727>>>>>>>>
79727>>>>>>>        Get piPopupTimeout to iTimeOut
79728>>>>>>>        If (iTicks >= iTimeOut) Begin
79730>>>>>>>            // If time delay has been met, launch autocomplete
79730>>>>>>>            Set pbEnabled  of ghoSuggestionTimer to False
79731>>>>>>>            Get Value to sValue
79732>>>>>>>            Get Item_Changed_State 0 to iChanged
79733>>>>>>>            Get ShouldSuggestion sValue iChanged to bDoIt
79734>>>>>>>            If bDoIt Begin
79736>>>>>>>                Send ActivateSuggestionList
79737>>>>>>>                Send FindSuggestions
79738>>>>>>>                Set Visible_State of ghoSuggestionList to True
79739>>>>>>>            End
79739>>>>>>>>
79739>>>>>>>            Set piTimeOutTicks to 0
79740>>>>>>>        End
79740>>>>>>>>
79740>>>>>>>    End_Procedure
79741>>>>>>>
79741>>>>>>>End_Class
79742>>>>>>>
79742>>>>>Use cDbCJGridColumn.pkg
79742>>>>>Use cDbCJGridColumnEdit.pkg
79742>>>>>
79742>>>>>// This is the edit control that gets embedded in cDbCJGridColumnSuggestion object.
79742>>>>>
79742>>>>>Class cDbCJGridColumnSuggestionEdit is a cDbCJGridColumnEdit
79743>>>>>
79743>>>>>    Import_Class_Protocol cSuggestionControl_mixin
79744>>>>>
79744>>>>>    Procedure Construct_Object
79746>>>>>        Forward Send Construct_Object
79748>>>>>        Send Define_cSuggestionControl_mixin
79749>>>>>    End_Procedure
79750>>>>>    
79750>>>>>    // Called when closing a suggestion form. With grids we must also make sure that the
79750>>>>>    // edit is canceled. 
79750>>>>>    Procedure CancelEditIfGrid
79752>>>>>        Send CancelEdit
79753>>>>>    End_Procedure
79754>>>>>    
79754>>>>>End_Class
79755>>>>>
79755>>>>>// A cDbCJGridColumnSuggestion would be dropped inside of cDbCJGrid.
79755>>>>>
79755>>>>>Class cDbCJGridColumnSuggestion is a cDbCJGridColumn
79756>>>>>    
79756>>>>>    Import_Class_Protocol cSuggestion_mixin            
79757>>>>>    
79757>>>>>    Procedure Construct_Object
79759>>>>>        Forward Send Construct_Object
79761>>>>>
79761>>>>>        Send Define_cSuggestion_mixin
79762>>>>>        Set phcEditClass to (RefClass(cDbCJGridColumnSuggestionEdit))
79763>>>>>    End_Procedure
79764>>>>>    
79764>>>>>End_Class
79765>>>Use dfSelLst.pkg
79765>>>
79765>>>Deferred_View Activate_RegistroEmpleado for ;Object RegistroEmpleado is a dbView
79790>>>    Object oNacionalidad_DD is a cNacionalidadDataDictionary
79792>>>    End_Object
79793>>>
79793>>>    Object oEmpleado_DD is a cEmpleadoDataDictionary
79795>>>        Set DDO_Server to oNacionalidad_DD
79796>>>    End_Object
79797>>>
79797>>>    Set Main_DD to oEmpleado_DD
79798>>>    Set Server to oEmpleado_DD
79799>>>
79799>>>    Set Border_Style to Border_Thick
79800>>>    Set Size to 131 166
79801>>>    Set Location to 2 2
79802>>>    Set Label to "Registro de Empleado"
79803>>>    Set piMaxSize to 131 166
79804>>>    Set piMinSize to 131 166
79805>>>
79805>>>    Object oDbGroup1 is a dbGroup
79807>>>        Set Size to 128 164
79808>>>        Set Location to 3 3
79809>>>        Set Label to "Datos Personales"
79810>>>        Set Color to clSilver
79811>>>
79811>>>        Object oEmpleado_Numero is a dbForm
79813>>>            Entry_Item Empleado.Numero
79814>>>            Set Location to 21 66
79815>>>            Set Size to 13 30
79816>>>            Set Label to "Numero:"
79817>>>            Set Prompt_Button_Mode to PB_PromptOn
79818>>>            Set Label_Color to clSilver
79819>>>            Set Label_Col_Offset to 30
79820>>>        End_Object
79821>>>
79821>>>        Object oEmpleado_PrimerNombre is a dbForm
79823>>>            Entry_Item Empleado.PrimerNombre
79824>>>            Set Location to 36 66
79825>>>            Set Size to 13 87
79826>>>            Set Label to "Primer Nombre:"
79827>>>            Set Label_Color to clSilver
79828>>>            Set Label_Col_Offset to 53
79829>>>        End_Object
79830>>>
79830>>>        Object oEmpleado_SegundoNombre is a dbForm
79832>>>            Entry_Item Empleado.SegundoNombre
79833>>>            Set Location to 51 66
79834>>>            Set Size to 13 87
79835>>>            Set Label to "Segundo Nombre:"
79836>>>            Set Label_Color to clSilver
79837>>>        End_Object
79838>>>
79838>>>        Object oEmpleado_PrimerApellido is a dbForm
79840>>>            Entry_Item Empleado.PrimerApellido
79841>>>            Set Location to 66 66
79842>>>            Set Size to 13 87
79843>>>            Set Label to "Primer Apellido:"
79844>>>            Set Label_Color to clSilver
79845>>>            Set Label_Col_Offset to 54
79846>>>        End_Object
79847>>>
79847>>>        Object oEmpleado_SegundoApellido is a dbForm
79849>>>            Entry_Item Empleado.SegundoApellido
79850>>>            Set Location to 82 66
79851>>>            Set Size to 13 87
79852>>>            Set Label to "Segundo Apellido:"
79853>>>            Set Label_Color to clSilver
79854>>>        End_Object
79855>>>
79855>>>        Object oNacionalidad_Pais is a dbForm
79857>>>            Entry_Item Nacionalidad.Pais
79858>>>            Set Location to 98 96
79859>>>            Set Size to 13 57
79860>>>        End_Object
79861>>>
79861>>>        Object oEmpleado_Nacionalidad is a dbForm
79863>>>            Entry_Item Nacionalidad.Numero
79864>>>            Set Location to 98 66
79865>>>            Set Size to 13 27
79866>>>            Set Label to "Nacionalidad:"
79867>>>            Set Prompt_Button_Mode to PB_PromptOn
79868>>>            Set Prompt_Object to (ListaNacionalidad(Current_Object))
79869>>>            Set Label_Col_Offset to 47
79870>>>          
79870>>>        End_Object
79871>>>    End_Object
79872>>>
79872>>>Cd_End_Object
79874>>>>
79874>        Use RegistroMarcajes.vw
Including file: RegistroMarcajes.vw    (C:\DataFlex Projects\Control Marcajes\AppSrc\RegistroMarcajes.vw)
79874>>>Use Windows.pkg
79874>>>Use DFClient.pkg
79874>>>Use cDbCJGrid.pkg
79874>>>Use cdbCJGridColumn.pkg
79874>>>Use cNacionalidadDataDictionary.dd
79874>>>Use cEmpleadoDataDictionary.dd
79874>>>Use cTipoMarcajeDataDictionary.dd
Including file: cTipoMarcajeDataDictionary.dd    (C:\DataFlex Projects\Control Marcajes\DDSrc\cTipoMarcajeDataDictionary.dd)
79874>>>>>Use DataDict.pkg
79874>>>>>
79874>>>>>Open TipoMarcaje
Including file: TipoMarcaje.fd    (C:\DataFlex Projects\Control Marcajes\DDSrc\TipoMarcaje.fd)
79876>>>>>Open Marcaje
79878>>>>>Open Autoincrementable
79880>>>>>
79880>>>>>Class cTipoMarcajeDataDictionary is a DataDictionary
79881>>>>>    
79881>>>>>    Procedure Construct_Object
79883>>>>>        Forward Send Construct_Object
79885>>>>>        Set Main_File to TipoMarcaje.File_Number
79886>>>>>
79886>>>>>        Set Add_System_File to Autoincrementable.File_Number DD_Lock_On_All
79887>>>>>
79887>>>>>        Set Add_Client_File to Marcaje.File_Number
79888>>>>>
79888>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_NOPUT to True
79889>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
79890>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
79891>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
79892>>>>>
79892>>>>>        Set Field_Option Field TipoMarcaje.Numero DD_AUTOFIND to True
79893>>>>>        Set Key_Field_State Field TipoMarcaje.Numero to True
79894>>>>>        Set Field_Auto_Increment Field TipoMarcaje.Numero to File_Field Autoincrementable.NumTipoMarcaje
79895>>>>>
79895>>>>>        Set Field_Option Field TipoMarcaje.TipoMarcaje DD_CAPSLOCK to True
79896>>>>>        Set Field_Option Field TipoMarcaje.TipoMarcaje DD_AUTOFIND to True
79897>>>>>        Set Field_Option Field TipoMarcaje.TipoMarcaje DD_REQUIRED to True
79898>>>>>
79898>>>>>    End_Procedure
79899>>>>>
79899>>>>>End_Class
79900>>>Use cMarcajeDataDictionary.dd
Including file: cMarcajeDataDictionary.dd    (C:\DataFlex Projects\Control Marcajes\DDSrc\cMarcajeDataDictionary.dd)
79900>>>>>Use DataDict.pkg
79900>>>>>
79900>>>>>Open Marcaje
79902>>>>>Open Empleado
79904>>>>>Open TipoMarcaje
79906>>>>>Open Autoincrementable
79908>>>>>
79908>>>>>Register_Object ListaTipoMarcaje
79908>>>>>Register_Object ListaEmpleado
79908>>>>>
79908>>>>>Class cMarcajeDataDictionary is a DataDictionary
79909>>>>>    
79909>>>>>    Procedure Construct_Object
79911>>>>>        Forward Send Construct_Object
79913>>>>>        Set Main_File to Marcaje.File_Number
79914>>>>>
79914>>>>>        Set Add_System_File to Autoincrementable.File_Number DD_Lock_On_All
79915>>>>>
79915>>>>>        Set Add_Server_File to Empleado.File_Number
79916>>>>>        Set Add_Server_File to TipoMarcaje.File_Number
79917>>>>>
79917>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_NOPUT to True
79918>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
79919>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
79920>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
79921>>>>>
79921>>>>>        Set Field_Option Field Marcaje.Numero DD_AUTOFIND to True
79922>>>>>        Set Field_Auto_Increment Field Marcaje.Numero to File_Field Autoincrementable.NumMarcaje
79923>>>>>        Set Key_Field_State Field Marcaje.Numero to True
79924>>>>>        Set Field_Option Field Marcaje.Numero DD_DISPLAYONLY to True
79925>>>>>
79925>>>>>        Set Field_Prompt_Object Field Marcaje.Empleado to ListaEmpleado
79926>>>>>        Set Field_Option Field Marcaje.Empleado DD_AUTOFIND to True
79927>>>>>        Set Field_Option Field Marcaje.Empleado DD_CAPSLOCK to True
79928>>>>>        Set Field_Option Field Marcaje.Empleado DD_REQUIRED to True
79929>>>>>
79929>>>>>        Set Field_Option Field Marcaje.FechaMarcaje DD_REQUIRED to True
79930>>>>>
79930>>>>>        Set Field_Option Field Marcaje.HoraMarcaje DD_REQUIRED to True
79931>>>>>
79931>>>>>        Set Field_Prompt_Object Field Marcaje.TipoMarcaje to ListaTipoMarcaje
79932>>>>>        Set Field_Option Field Marcaje.TipoMarcaje DD_AUTOFIND to True
79933>>>>>        Set Field_Option Field Marcaje.TipoMarcaje DD_REQUIRED to True
79934>>>>>
79934>>>>>    End_Procedure
79935>>>>>
79935>>>>>End_Class
79936>>>>>
79936>>>>>Use ListaEmpleado.sl
79936>>>>>Use ListaTipoMarcaje.sl
Including file: ListaTipoMarcaje.sl    (C:\DataFlex Projects\Control Marcajes\AppSrc\ListaTipoMarcaje.sl)
79936>>>>>>>//**************************************************************
79936>>>>>>>// TableLookup.tpl for Windows application for Spanish 
79936>>>>>>>// translated by Moose Software (www.moose-software.com) 
79936>>>>>>>// 13/07/2010 Revised for VDF 16.0 by Moose Software
79936>>>>>>>// 05/02/2012 Revised for VDF 17.0 by Moose Software
79936>>>>>>>// 13/06/2013 Revised for VDF 17.1 by Moose Software
79936>>>>>>>// 02/05/2014 Revised for VDF 18.0 by Moose Software
79936>>>>>>>//*************************************************************
79936>>>>>>>
79936>>>>>>>Use Windows.pkg
79936>>>>>>>Use DFClient.pkg
79936>>>>>>>use DFSellst.pkg
79936>>>>>>>Use cTipoMarcajeDataDictionary.dd
79936>>>>>>>
79936>>>>>>>Object ListaTipoMarcaje is a dbModalPanel
79938>>>>>>>    Object oTipoMarcaje_DD is a cTipoMarcajeDataDictionary
79940>>>>>>>    End_Object
79941>>>>>>>
79941>>>>>>>    Set Main_DD to oTipoMarcaje_DD
79942>>>>>>>    Set Server to oTipoMarcaje_DD
79943>>>>>>>
79943>>>>>>>    Set Size to 133 292
79944>>>>>>>    Set Location     to 4 5
79945>>>>>>>    Set Border_Style to Border_Thick
79946>>>>>>>    Set Label to "Tipo Marcaje"
79947>>>>>>>
79947>>>>>>>    Object oSelList is a dbList
79949>>>>>>>        Set peAnchors to anAll
79950>>>>>>>        Set Size      to 105 280
79951>>>>>>>        Set Location  to 6 6
79952>>>>>>>
79952>>>>>>>        Begin_Row
79955>>>>>>>            Entry_Item TipoMarcaje.Numero
79956>>>>>>>            Entry_Item TipoMarcaje.TipoMarcaje
79957>>>>>>>        End_Row
79962>>>>>>>
79962>>>>>>>        Set Main_File to TipoMarcaje.File_Number
79963>>>>>>>
79963>>>>>>>        Set Form_Width 0 to 48
79964>>>>>>>        Set Header_Label 0 to "Numero"
79965>>>>>>>        Set Form_Width 1 to 60
79966>>>>>>>        Set Header_Label 1 to "TipoMarcaje"
79967>>>>>>>    End_Object
79968>>>>>>>
79968>>>>>>>    Object oOK_bn is a Button
79970>>>>>>>        Set Label     to "&Aceptar"
79971>>>>>>>        Set Location  to 115 128
79972>>>>>>>        Set peAnchors to anBottomRight
79973>>>>>>>
79973>>>>>>>        Procedure OnClick
79976>>>>>>>            Send Ok of oSelList
79977>>>>>>>        End_Procedure
79978>>>>>>>
79978>>>>>>>    End_Object
79979>>>>>>>
79979>>>>>>>    Object oCancel_bn is a Button
79981>>>>>>>        Set Label     to "&Cancelar"
79982>>>>>>>        Set Location  to 115 182
79983>>>>>>>        Set peAnchors to anBottomRight
79984>>>>>>>
79984>>>>>>>        Procedure OnClick
79987>>>>>>>            Send Cancel of oSelList
79988>>>>>>>        End_Procedure
79989>>>>>>>
79989>>>>>>>    End_Object
79990>>>>>>>
79990>>>>>>>    Object oSearch_bn is a Button
79992>>>>>>>        Set Label     to "&Buscar..."
79993>>>>>>>        Set Location  to 115 236
79994>>>>>>>        Set peAnchors to anBottomRight
79995>>>>>>>
79995>>>>>>>        Procedure OnClick
79998>>>>>>>            Send Search of oSelList
79999>>>>>>>        End_Procedure
80000>>>>>>>
80000>>>>>>>    End_Object
80001>>>>>>>
80001>>>>>>>    On_Key Key_Alt+Key_A Send KeyAction of oOk_bn
80002>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_bn
80003>>>>>>>    On_Key Key_Alt+Key_B Send KeyAction of oSearch_bn
80004>>>>>>>
80004>>>>>>>End_Object
80005>>>>>>>
80005>>>>>>>//*********************************************** end of TableLookup.tpl for Spanish ****************
80005>>>>>>>
80005>>>Use cDbCJGridColumnSuggestion.pkg
80005>>>Use cCJGridColumn.pkg
80005>>>
80005>>>
80005>>>Activate_View Activate_RegistroMarcajes for RegistroMarcajes
80015>>>>
80015>>>Object RegistroMarcajes is a dbView
80017>>>    Object oTipoMarcaje_DD is a cTipoMarcajeDataDictionary
80019>>>    End_Object
80020>>>
80020>>>    Object oNacionalidad_DD is a cNacionalidadDataDictionary
80022>>>    End_Object
80023>>>
80023>>>    Object oEmpleado_DD is a cEmpleadoDataDictionary
80025>>>        Set DDO_Server to oNacionalidad_DD
80026>>>    End_Object
80027>>>
80027>>>    Object oMarcaje_DD is a cMarcajeDataDictionary
80029>>>        Set DDO_Server to oTipoMarcaje_DD
80030>>>        Set DDO_Server to oEmpleado_DD
80031>>>    End_Object
80032>>>
80032>>>    Set Main_DD to oMarcaje_DD
80033>>>    Set Server to oMarcaje_DD
80034>>>
80034>>>    Set Border_Style to Border_Thick
80035>>>    Set Size to 219 410
80036>>>    Set Location to 2 2
80037>>>    Set Label to "Registro de Marcajes"
80038>>>    Set Bitmap_Style to Bitmap_Center
80039>>>    Set Auto_Top_Panel_State to False
80040>>>    Set Auto_Top_Item_State to False
80041>>>    Set piMaxSize to 219 410
80042>>>    Set piMinSize to 219 410
80043>>>    
80043>>>    
80043>>>
80043>>>    Object oDbGroup1 is a dbGroup
80045>>>        Set Size to 218 462
80046>>>        Set Location to 2 3
80047>>>        Set Label to "Registro de Marcajes"
80048>>>
80048>>>        Object oDbCJGrid1 is a cDbCJGrid
80050>>>            Set Size to 198 402
80051>>>            Set Location to 11 5
80052>>>            Set pbAllowColumnRemove to False
80053>>>            Set pbAllowColumnResize to False
80054>>>            Set pbAllowColumnReorder to False
80055>>>
80055>>>            Object oMarcaje_Numero is a cDbCJGridColumn
80057>>>                Entry_Item Marcaje.Numero
80058>>>                Set piWidth to 50
80059>>>                Set psCaption to "Numero"
80060>>>                Set pbCapslock to True
80061>>>                Set peTextAlignment to xtpAlignmentCenter
80062>>>            End_Object
80063>>>            
80063>>>            
80063>>>
80063>>>            Object oMarcaje_Empleado is a cDbCJGridColumn
80065>>>                Entry_Item Empleado.Numero 
80066>>>                Set piWidth to 65
80067>>>                Set psCaption to "Empleado"
80068>>>                Set peTextAlignment to xtpAlignmentCenter
80069>>>                Set pbResizable to False
80070>>>            End_Object
80071>>>            
80071>>>            Object oEmpleado_Nombre is a cDbCJGridColumn
80073>>>                //Set Value to Empleado.PrimerNombre
80073>>>                Set piWidth to 150
80074>>>                Set psCaption to "Nombres y Apellidos"
80075>>>                Set pbFocusable to False
80076>>>                
80076>>>                Procedure OnSetCalculatedValue String ByRef sValue
80079>>>                    
80079>>>                    Move '' to sValue
80080>>>                    Append sValue (Trim(Empleado.PrimerNombre)) ' ' (Trim(Empleado.SegundoNombre)) ' ' (Trim(Empleado.PrimerApellido)) ' ' (Trim( Empleado.SegundoApellido))
80087>>>                End_Procedure
80088>>>
80088>>>            End_Object            
80089>>>
80089>>>            Object oMarcaje_FechaMarcaje is a cDbCJGridColumn
80091>>>                Entry_Item Marcaje.FechaMarcaje
80092>>>                Set piWidth to 60
80093>>>                Set psCaption to "Fecha"
80094>>>            End_Object
80095>>>
80095>>>            Object oMarcaje_HoraMarcaje is a cDbCJGridColumn
80097>>>                Entry_Item Marcaje.HoraMarcaje
80098>>>                Set piWidth to 60
80099>>>                Set psCaption to "Hora"
80100>>>            End_Object
80101>>>
80101>>>            Object oMarcaje_TipoMarcaje is a cDbCJGridColumn
80103>>>                Entry_Item TipoMarcaje.Numero
80104>>>                Set piWidth to 50
80105>>>                Set psCaption to "# Marcaje"
80106>>>                Set Prompt_Button_Mode to PB_PromptOn
80107>>>                Set peTextAlignment to xtpAlignmentCenter
80108>>>                Set Prompt_Object of oMarcaje_TipoMarcaje to (ListaTipoMarcaje(Current_Object))
80109>>>                
80109>>>            End_Object
80110>>>
80110>>>            Object oTipoMarcaje_TipoMarcaje is a cDbCJGridColumn
80112>>>                Entry_Item TipoMarcaje.TipoMarcaje
80113>>>                Set piWidth to 60
80114>>>                Set psCaption to "Marcaje"
80115>>>                
80115>>>            End_Object
80116>>>        End_Object
80117>>>    End_Object
80118>>>
80118>>>End_Object
80119>        Use Marcajes.rv
Including file: Marcajes.rv    (C:\DataFlex Projects\Control Marcajes\AppSrc\Marcajes.rv)
80119>>>Use Windows.pkg
80119>>>Use DFRptVw.pkg
80119>>>Use DFRpt.pkg
80119>>>Use File_Dlg.Pkg
80119>>>Use SQLDATE.pkg
Including file: SQLDATE.PKG    (C:\DataFlex Projects\Control Marcajes\AppSrc\SQLDATE.PKG)
80119>>>>>Function fSQL_date Global Date d_Fecha Returns String
80121>>>>>    Local String  s_Fecha
80121>>>>>    Local Integer i_Formato
80121>>>>>
80121>>>>>    Get_date_format to i_formato
80122>>>>>
80122>>>>>    Move "'" to s_Fecha
80123>>>>>    //Move "" to s_Fecha
80123>>>>>
80123>>>>>    If i_Formato eq 0 Begin  // Fecha formato USA mes/dia/ao
80125>>>>>        Append s_Fecha (Mid(d_Fecha,4,7))
80126>>>>>        Append s_Fecha (Mid(d_Fecha,2,1))
80127>>>>>        Append s_Fecha (Mid(d_Fecha,2,4))
80128>>>>>    End
80128>>>>>>
80128>>>>>    If i_formato eq 1 Begin  // Fecha formato europeo dia/mes/ao
80130>>>>>        Append s_Fecha (Mid(d_Fecha,4,7))
80131>>>>>        Append s_Fecha (Mid(d_Fecha,2,4))
80132>>>>>        Append s_Fecha (Mid(d_Fecha,2,1))
80133>>>>>    End
80133>>>>>>
80133>>>>>    If i_formato eq 2 Begin  // Fecha formato militar ao/mes/dia
80135>>>>>        Append s_Fecha (Mid(d_Fecha,4,1))
80136>>>>>        Append s_Fecha (Mid(d_Fecha,2,6))
80137>>>>>        Append s_Fecha (Mid(d_Fecha,2,9))
80138>>>>>    End
80138>>>>>>
80138>>>>>
80138>>>>>    Append s_Fecha "'"
80139>>>>>    Function_Return s_Fecha
80140>>>>>End_Function
80141>>>Use cNacionalidadDataDictionary.dd
80141>>>Use cEmpleadoDataDictionary.dd
80141>>>Use cTipoMarcajeDataDictionary.dd
80141>>>Use cMarcajeDataDictionary.dd
80141>>>Use DFEntry.pkg
80141>>>Use dfclient.pkg
80141>>>Use MonthCalendarPrompt.dg
80141>>>
80141>>>Activate_View Activate_Marcajes for Marcajes
80151>>>>
80151>>>Object Marcajes is a ReportView
80153>>>    Object oTipoMarcaje_DD is a cTipoMarcajeDataDictionary
80155>>>    End_Object
80156>>>
80156>>>    Object oNacionalidad_DD is a cNacionalidadDataDictionary
80158>>>    End_Object
80159>>>
80159>>>    Object oEmpleado_DD is a cEmpleadoDataDictionary
80161>>>        Set DDO_Server to oNacionalidad_DD
80162>>>    End_Object
80163>>>
80163>>>    Object oMarcaje_DD is a cMarcajeDataDictionary
80165>>>        Set DDO_Server to oTipoMarcaje_DD
80166>>>        Set DDO_Server to oEmpleado_DD
80167>>>    End_Object
80168>>>
80168>>>    Set Main_DD to oMarcaje_DD
80169>>>    Set Server to oMarcaje_DD
80170>>>
80170>>>    Set Location to 7 11
80171>>>    Set Size to 190 258
80172>>>    Set Label to "Marcajes"
80173>>>
80173>>>    Object oSaveAsDialog is a SaveAsDialog
80175>>>    End_Object
80176>>>
80176>>>    Procedure StartReport
80179>>>        Integer iOutputDevice 
80179>>>        Handle hoWorkspace
80179>>>        String sFileName sCurrentDirectory sDataPath
80179>>>    
80179>>>        Get Output_Device_Mode to iOutputDevice
80180>>>    
80180>>>        Case Begin
80180>>>            Case (iOutputDevice = PRINT_TO_WINDOW)
80182>>>                Get_Current_Directory to sCurrentDirectory
80183>>>                Get phoWorkspace Of ghoApplication to hoWorkspace
80184>>>                Get psDataPath Of hoWorkspace to sDataPath
80185>>>                Get PathAtIndex Of hoWorkspace sDataPath 1 to sDataPath
80186>>>                Set_Directory sDataPath
80187>>>                Make_Temp_File "TXT" sFileName
80188>>>                Set_Directory sCurrentDirectory
80189>>>                If (Right(sDataPath, 1) <> Sysconf(SYSCONF_DIR_SEPARATOR)) Begin
80191>>>                    Move (sDataPath - Sysconf(SYSCONF_DIR_SEPARATOR)) To sDataPath
80192>>>                End
80192>>>>
80192>>>                Move (sDataPath - sFileName) to sFileName
80193>>>                Set Output_Device_Name to sFileName
80194>>>                Case Break
80195>>>            
80195>>>        Case End
80195>>>    
80195>>>        Send Run_Report
80196>>>    
80196>>>        If (iOutputDevice = PRINT_TO_WINDOW) Begin
80198>>>            Runprogram Background "NotePad" sFileName
80199>>>            EraseFile sFileName
80200>>>>
80200>>>        End
80200>>>>
80200>>>    End_Procedure
80201>>>    
80201>>>    Object oBasicReport is a BasicReport
80203>>>        // Set Server To DDOName
80203>>>        
80203>>>        // Create a new file with the images for the report. Include this filename in the
80203>>>        // component with a USE statement. Replace the HeaderSection, BodySection, FooterSection
80203>>>        // with the imagenames you've created.
80203>>>        // NOTE: 
80203>>>        // - Image names must be unique throughout the program
80203>>>        // - Images start at the first column of the sourcecode in the format /ImageName
80203>>>        // - End of an image is the start of a new one or a /*
80203>>>
80203>>>        Function Starting_Main_Report Returns Integer
80206>>>            Integer iRetval
80206>>>            
80206>>>            Forward Get Starting_Main_Report to iRetval
80208>>>            
80208>>>            Function_Return iRetval
80209>>>        End_Function
80210>>>
80210>>>       
80210>>>
80210>>>    End_Object
80211>>>
80211>>>    Object GrupoRangoFechas is a Group
80213>>>        Set Size to 57 217
80214>>>        Set Location to 97 20
80215>>>        Set Label to "Rango de Fechas"
80216>>>
80216>>>        Object oGroup1 is a Group
80218>>>            Set Size to 29 95
80219>>>            Set Location to 19 6
80220>>>            Set Label to "Fecha Inicial   *"
80221>>>
80221>>>            Object TxtFechaInicial is a Form
80223>>>                Set Size to 13 81
80224>>>                Set Location to 10 7
80225>>>                Set Form_Datatype to Mask_Date_Window
80226>>>                Set Prompt_Object to oMonthCalendarPrompt
80227>>>                Set Prompt_Button_Mode to PB_PromptOn
80228>>>            
80228>>>                // OnChange is called on every changed character
80228>>>            //    Procedure OnChange
80228>>>            //        String sValue
80228>>>            //    
80228>>>            //        Get Value to sValue
80228>>>            //    End_Procedure
80228>>>            
80228>>>            End_Object
80229>>>        End_Object
80230>>>
80230>>>        Object oGroup1 is a Group
80232>>>            Set Size to 29 95
80233>>>            Set Location to 19 110
80234>>>            Set Label to "Fecha Final  *"
80235>>>
80235>>>            Object TxtFechaFinal is a Form
80237>>>                Set Size to 13 81
80238>>>                Set Location to 10 7
80239>>>                Set Form_Datatype to Mask_Date_Window
80240>>>                Set Prompt_Object to oMonthCalendarPrompt
80241>>>                Set Prompt_Button_Mode to PB_PromptOn
80242>>>            
80242>>>                // OnChange is called on every changed character
80242>>>            //    Procedure OnChange
80242>>>            //        String sValue
80242>>>            //    
80242>>>            //        Get Value to sValue
80242>>>            //    End_Procedure
80242>>>            
80242>>>            End_Object
80243>>>        End_Object
80244>>>    End_Object
80245>>>
80245>>>    Object oDbGroup1 is a dbGroup
80247>>>        Set Size to 80 216
80248>>>        Set Location to 13 20
80249>>>        Set Label to "Seleccionar filtros para el reporte"
80250>>>
80250>>>        Object TxtPais is a Form
80252>>>            Set Size to 13 40
80253>>>            Set Location to 22 55
80254>>>            Set Label to "Pais :"
80255>>>            Set Label_Col_Offset to 20
80256>>>            Set Prompt_Button_Mode to PB_PromptOn
80257>>>            Set Prompt_Object to (ListaNacionalidad(TxtPais))
80258>>>            Set Aux_Value to 0
80259>>>            //Set Form_Datatype to Mask_Numeric_Window
80259>>>            //Set Value to Default_Numeric_Mask
80259>>>           
80259>>>
80259>>>            Procedure OnChange
80262>>>                Forward Send OnChange
80264>>>                Set Label of EtiquetaPais to Nacionalidad.Pais
80265>>>                
80265>>>                
80265>>>                
80265>>>            End_Procedure
80266>>>        
80266>>>            // OnChange is called on every changed character
80266>>>        //    Procedure OnChange
80266>>>        //        String sValue
80266>>>        //    
80266>>>        //        Get Value to sValue
80266>>>        //    End_Procedure
80266>>>        
80266>>>        End_Object
80267>>>
80267>>>        Object TxtEmpleado is a Form
80269>>>            Set Size to 13 40
80270>>>            Set Location to 44 55
80271>>>            Set Label to "Empleado :"
80272>>>            Set Label_Col_Offset to 38
80273>>>            Set Prompt_Button_Mode to PB_PromptOn
80274>>>            Set Prompt_Object to (ListaEmpleado(TxtEmpleado))            
80275>>>            Set Aux_Value to 0
80276>>>         
80276>>>
80276>>>            Procedure OnChange
80279>>>                Forward Send OnChange 
80281>>>                Set Label of EtiquetaEmpleado to (Trim(Empleado.PrimerNombre) + ' ' + Trim(Empleado.SegundoNombre) + ' ' + Trim(Empleado.PrimerApellido) + ' ' + Trim(Empleado.SegundoApellido))
80282>>>               
80282>>>            End_Procedure
80283>>>        
80283>>>            // OnChange is called on every changed character
80283>>>        //    Procedure OnChange
80283>>>        //        String sValue
80283>>>        //    
80283>>>        //        Get Value to sValue
80283>>>        //    End_Procedure
80283>>>        
80283>>>        End_Object
80284>>>
80284>>>        Object EtiquetaEmpleado is a TextBox
80286>>>            Set Size to 10 32
80287>>>            Set Location to 46 99
80288>>>            //Set Label to (Trim(Empleado.PrimerNombre) + ' ' + Trim(Empleado.PrimerNombre))
80288>>>        End_Object
80289>>>
80289>>>        Object EtiquetaPais is a TextBox
80291>>>            Set Size to 10 32
80292>>>            Set Location to 25 100
80293>>>            //Set Label to (Trim(Empleado.PrimerNombre) + ' ' + Trim(Empleado.PrimerNombre))
80293>>>        End_Object
80294>>>    End_Object
80295>>>
80295>>>    Object BtnGenerar is a Button  // ********Boton Generar
80297>>>        Set Size to 14 68
80298>>>        Set Location to 162 34
80299>>>        Set Label to "Generar"
80300>>>    
80300>>>        // fires when the button is clicked
80300>>>        Procedure OnClick
80303>>>            Forward Send OnClick False 
80305>>>       
80305>>>         Send GenerarReporteMarcaje
80306>>>            
80306>>>            
80306>>>        End_Procedure
80307>>>    
80307>>>    End_Object
80308>>>
80308>>>    Object BtnNuevo is a Button
80310>>>        Set Size to 14 68
80311>>>        Set Location to 162 137
80312>>>        Set Label to "Nuevo"
80313>>>    
80313>>>        // fires when the button is clicked
80313>>>        Procedure OnClick
80316>>>            Set Value of TxtEmpleado to ''
80317>>>            Set Value of TxtPais  to ''
80318>>>            Set Value of TxtFechaFinal to ''
80319>>>            Set Value of TxtFechaInicial to ''
80320>>>        End_Procedure
80321>>>    
80321>>>    End_Object
80322>>>    
80322>>>    Procedure GenerarReporteMarcaje
80325>>>        Integer DatoPais
80325>>>        Integer DatoEmpleado
80325>>>        Global_Variable Date FechaInicial
80325>>>        Global_Variable Date FechaFinal
80325>>>        Date ConteoFecha
80325>>>        String Titulo
80325>>>        String Parametro        
80325>>>        String Mensaje
80325>>>        Global_Variable Boolean EstadoPais, EstadoEmpleado
80325>>>        
80325>>>        
80325>>>        //Inicializacion de Varibales
80325>>>        Move 0 to DatoPais
80326>>>        Move 0 to DatoEmpleado
80327>>>        Move '' to FechaInicial
80328>>>        Move '' to FechaFinal
80329>>>        Move '' to Titulo
80330>>>        Move '' to Parametro        
80331>>>        Move False to EstadoEmpleado
80332>>>        Move False to EstadoPais
80333>>>        
80333>>>        // Asignacion de valores a variales
80333>>>        Get Value of TxtPais to DatoPais
80334>>>        Get Value of TxtEmpleado to DatoEmpleado
80335>>>        Get Value of TxtFechaInicial to FechaInicial
80336>>>        Get Value of TxtFechaFinal to FechaFinal
80337>>>        
80337>>>        // **PAIS**
80337>>>        //If (DatoPais = 0) Begin
80337>>>        //     Move 'No se inserto ningun dato' to Mensaje                   
80337>>>        //End
80337>>>        //Else Begin 
80337>>>            If (Trim(DatoPais)) ne 0 Begin
80339>>>                Clear Nacionalidad  //tabla
80340>>>                Move (Trim(DatoPais)) to Nacionalidad.Numero  //atributo codiog de la tabla Marcajestable
80341>>>                Find eq Nacionalidad by Index.1   // busca segun el indice
80342>>>>
80342>>>                If [not Found] Begin
80344>>>                    Send Info_Box 'El Pais Seleecionado no Existe'                    
80345>>>                    Procedure_Return // retorna el procedimienot para hacer uso del sisema
80346>>>                End
80346>>>>
80346>>>                Else Begin
80347>>>                    Move True to EstadoPais
80348>>>                End
80348>>>>
80348>>>            End
80348>>>>
80348>>>        //End
80348>>>        
80348>>>        // **EMPLEADO**
80348>>>        If (DatoEmpleado = 0) Begin
80350>>>            Move 'No se inserto ningun dato' to Mensaje  
80351>>>                                
80351>>>        End
80351>>>>
80351>>>        Else Begin
80352>>>           If (Trim(DatoEmpleado)) ne 0 Begin
80354>>>                Clear Empleado  //tabla
80355>>>                Move (Trim(DatoEmpleado)) to Empleado.Numero  //atributo codiog de la tabla Marcajestable
80356>>>                Find eq Empleado by Index.1   // busca segun el indice
80357>>>>
80357>>>                If [not Found] Begin
80359>>>                    Send Info_Box 'El Empleado Seleccionado no Existe'                    
80360>>>                    Procedure_Return // retorna el procedimienot para hacer uso del sisema
80361>>>                End
80361>>>>
80361>>>                Else Begin
80362>>>                    Move True to EstadoEmpleado
80363>>>                End
80363>>>>
80363>>>                
80363>>>          End
80363>>>>
80363>>>            
80363>>>        End
80363>>>>
80363>>>        
80363>>>        //  **FECHAS**
80363>>>        Indicate AceptarFecha True        
80364>>>        Move ("01/01/1900") to ConteoFecha
80365>>>        Set Report_Name of (ReporteFiltroFechas(Current_Object)) to "ReporteMacajeSM.rpt"
80366>>>        
80366>>>         If (FechaInicial <> '' or FechaFinal <> '')
80368>>>          Begin
80368>>>>
80368>>>            If ( (FechaInicial < ConteoFecha) or (FechaFinal < ConteoFecha))
80370>>>             Begin 
80370>>>>
80370>>>                Send Info_Box 'Ingrese Fechas Vlidas'
80371>>>                Indicate AceptarFecha False
80372>>>                Procedure_Return
80373>>>            End
80373>>>>
80373>>>            Else If (FechaInicial > FechaFinal ) Begin
80376>>>                 Send Info_Box 'La fecha Inicial no debe ser mayor a la fecha final' 'Error de Fechas'
80377>>>                Indicate AceptarFecha False            
80378>>>            End
80378>>>>
80378>>>            Else If (FechaInicial <= FechaFinal ) Begin
80381>>>            
80381>>>            [ AceptarFecha ] Send Run_Report to (ReporteFiltroFechas(Current_Object))
80382>>>             End
80382>>>>
80382>>>         End
80382>>>>
80382>>>         Else Begin
80383>>>            Send Info_Box 'Las Fechas son Requeridas'
80384>>>            Procedure_Return
80385>>>         End
80385>>>>
80385>>>         
80385>>>        // Send Run_Report to (ReporteFiltroFechas(Current_Object))
80385>>>             
80385>>>             //Send Run_Report to (ReporteFiltroFechas(Current_Object))
80385>>>        
80385>>>    End_Procedure
80386>>>    
80386>>>     // **Creacion de Objeto**
80386>>>      Object ReporteFiltroFechas is a WinQLReport
80388>>>        
80388>>>        Set Output_Destination to WQL_PRINT_TO_WINDOW
80389>>>        
80389>>>            Procedure OnInitializeReport
80392>>>                String FullQuery sFechaDel sFechaAl
80392>>>                Move (fSQL_date(FechaInicial)) to sFechaDel
80393>>>                Move (fSQL_date(FechaFinal)) to sFechaAl
80394>>>                Move '' to FullQuery
80395>>>                Forward Send OnInitializeReport  // lanzamos el iniciador del reporte
80397>>>                If (EstadoPais) Begin                
80399>>>                    Append FullQuery '{Nacionalidad.Numero} = '
80400>>>                    Append FullQuery Nacionalidad.Numero
80401>>>                    Append FullQuery 'and '
80402>>>                End
80402>>>>
80402>>>                
80402>>>                // ** Validacion y creacion de Query**
80402>>>                If (EstadoEmpleado) Begin 
80404>>>                    Append FullQuery '{Empleado.Numero} = '
80405>>>                    Append FullQuery Empleado.Numero ' and '
80407>>>                     
80407>>>                End
80407>>>>
80407>>>                
80407>>>                Append FullQuery '{Marcaje.FechaMarcaje} >= ' sFechaDel ' and '
80410>>>                Append FullQuery '{Marcaje.FechaMarcaje} <= ' sFechaAl 
80412>>>                
80412>>>                Set SelectionFormula to FullQuery
80413>>>                
80413>>>                
80413>>>             End_Procedure
80414>>>        
80414>>>      End_Object
80415>>>      
80415>>>      
80415>>> //  {Nacionalidad.Numero} = 1 and
80415>>> //  {Marcaje.FechaMarcaje} in "2022-05-05" to "2022-05-09" and
80415>>>//   {Empleado.Numero} = 2
80415>>>      
80415>>>    
80415>>>    
80415>>>End_Object
80416>        Use ReporteEmpleado.rv
Including file: ReporteEmpleado.rv    (C:\DataFlex Projects\Control Marcajes\AppSrc\ReporteEmpleado.rv)
80416>>>Use Windows.pkg
80416>>>Use DFRptVw.pkg
80416>>>Use DFRpt.pkg
80416>>>Use File_Dlg.Pkg
80416>>>Use MonthCalendarPrompt.dg
80416>>>Use cDbCJGrid.pkg
80416>>>Use cNacionalidadDataDictionary.dd
80416>>>Use cEmpleadoDataDictionary.dd
80416>>>Use cTipoMarcajeDataDictionary.dd
80416>>>Use cMarcajesDataDictionary.dd
Including file: cMarcajesDataDictionary.dd    (C:\DataFlex Projects\Control Marcajes\DDSrc\cMarcajesDataDictionary.dd)
80416>>>>>Use DataDict.pkg
80416>>>>>
80416>>>>>Open Marcajes
Including file: Marcajes.fd    (C:\DataFlex Projects\Control Marcajes\DDSrc\Marcajes.fd)
80418>>>>>Open Empleado
80420>>>>>Open TipoMarcaje
80422>>>>>Open Autoincrementable
80424>>>>>
80424>>>>>Class cMarcajesDataDictionary is a DataDictionary
80425>>>>>    
80425>>>>>    Procedure Construct_Object
80427>>>>>        Forward Send Construct_Object
80429>>>>>        Set Main_File to Marcajes.File_Number
80430>>>>>
80430>>>>>        Set Add_System_File to Autoincrementable.File_Number DD_Lock_On_All
80431>>>>>
80431>>>>>        Set Add_Server_File to Empleado.File_Number
80432>>>>>        Set Add_Server_File to TipoMarcaje.File_Number
80433>>>>>
80433>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_NOPUT to True
80434>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
80435>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
80436>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
80437>>>>>
80437>>>>>        Set Key_Field_State Field Marcajes.Numero to True
80438>>>>>        Set Field_Option Field Marcajes.Numero DD_AUTOFIND to True
80439>>>>>        Set Field_Auto_Increment Field Marcajes.Numero to File_Field Autoincrementable.NumMarcaje
80440>>>>>        Set Field_Option Field Marcajes.Numero DD_REQUIRED to True
80441>>>>>
80441>>>>>        Set Field_Option Field Marcajes.Empleado DD_AUTOFIND to True
80442>>>>>        Set Field_Option Field Marcajes.Empleado DD_REQUIRED to True
80443>>>>>        Set Field_Option Field Marcajes.Empleado DD_CAPSLOCK to True
80444>>>>>
80444>>>>>        Set Field_Option Field Marcajes.FechaMarcaje DD_AUTOFIND to True
80445>>>>>        Set Field_Option Field Marcajes.FechaMarcaje DD_REQUIRED to True
80446>>>>>        Set Field_Option Field Marcajes.FechaMarcaje DD_CAPSLOCK to True
80447>>>>>
80447>>>>>        Set Field_Option Field Marcajes.HoraMarcaje DD_AUTOFIND to True
80448>>>>>        Set Field_Option Field Marcajes.HoraMarcaje DD_REQUIRED to True
80449>>>>>
80449>>>>>        Set Field_Option Field Marcajes.TipoMarcaje DD_AUTOFIND to True
80450>>>>>        Set Field_Option Field Marcajes.TipoMarcaje DD_REQUIRED to True
80451>>>>>
80451>>>>>    End_Procedure
80452>>>>>
80452>>>>>End_Class
80453>>>Use cdbCJGridColumn.pkg
80453>>>Use dfSelLst.pkg
80453>>>Open Marcajes
80455>>>Open TipoMarcaje
80457>>>
80457>>>Activate_View Activate_ReporteEmpleado for ReporteEmpleado
80467>>>>
80467>>>Object ReporteEmpleado is a ReportView
80469>>>    Object oTipoMarcaje_DD is a cTipoMarcajeDataDictionary
80471>>>    End_Object
80472>>>
80472>>>    Object oNacionalidad_DD is a cNacionalidadDataDictionary
80474>>>    End_Object
80475>>>
80475>>>    Object oEmpleado_DD is a cEmpleadoDataDictionary
80477>>>        Set DDO_Server to oNacionalidad_DD
80478>>>    End_Object
80479>>>
80479>>>    Object oMarcajes_DD is a cMarcajesDataDictionary
80481>>>        Set DDO_Server to oTipoMarcaje_DD
80482>>>        Set DDO_Server to oEmpleado_DD
80483>>>    End_Object
80484>>>
80484>>>    Set Main_DD to oMarcajes_DD
80485>>>    Set Server to oMarcajes_DD
80486>>>
80486>>>    Set Location to 9 7
80487>>>    Set Size to 216 458
80488>>>    Set Label to "Reporte de Empleado"
80489>>>
80489>>>    Object oSaveAsDialog is a SaveAsDialog
80491>>>    End_Object
80492>>>
80492>>>    Procedure StartReport
80495>>>        Integer iOutputDevice 
80495>>>        Handle hoWorkspace
80495>>>        String sFileName sCurrentDirectory sDataPath
80495>>>    
80495>>>        Get Output_Device_Mode to iOutputDevice
80496>>>    
80496>>>        Case Begin
80496>>>            Case (iOutputDevice = PRINT_TO_WINDOW)
80498>>>                Get_Current_Directory to sCurrentDirectory
80499>>>                Get phoWorkspace Of ghoApplication to hoWorkspace
80500>>>                Get psDataPath Of hoWorkspace to sDataPath
80501>>>                Get PathAtIndex Of hoWorkspace sDataPath 1 to sDataPath
80502>>>                Set_Directory sDataPath
80503>>>                Make_Temp_File "TXT" sFileName
80504>>>                Set_Directory sCurrentDirectory
80505>>>                If (Right(sDataPath, 1) <> Sysconf(SYSCONF_DIR_SEPARATOR)) Begin
80507>>>                    Move (sDataPath - Sysconf(SYSCONF_DIR_SEPARATOR)) To sDataPath
80508>>>                End
80508>>>>
80508>>>                Move (sDataPath - sFileName) to sFileName
80509>>>                Set Output_Device_Name to sFileName
80510>>>                Case Break
80511>>>            Case (iOutputDevice = PRINT_TO_PRINTER)
80514>>>                Set Output_Device_Name to "WinLST:"
80515>>>                Case Break
80516>>>            
80516>>>        Case End
80516>>>    
80516>>>        Send Run_Report
80517>>>    
80517>>>        If (iOutputDevice = PRINT_TO_WINDOW) Begin
80519>>>            Runprogram Background "NotePad" sFileName
80520>>>            EraseFile sFileName
80521>>>>
80521>>>        End
80521>>>>
80521>>>    End_Procedure
80522>>>    
80522>>>    Object oBasicReport is a BasicReport
80524>>>        // Set Server To DDOName
80524>>>        
80524>>>        // Create a new file with the images for the report. Include this filename in the
80524>>>        // component with a USE statement. Replace the HeaderSection, BodySection, FooterSection
80524>>>        // with the imagenames you've created.
80524>>>        // NOTE: 
80524>>>        // - Image names must be unique throughout the program
80524>>>        // - Images start at the first column of the sourcecode in the format /ImageName
80524>>>        // - End of an image is the start of a new one or a /*
80524>>>
80524>>>        Function Starting_Main_Report Returns Integer
80527>>>            Integer iRetval
80527>>>            
80527>>>            Forward Get Starting_Main_Report to iRetval
80529>>>            
80529>>>            Function_Return iRetval
80530>>>        End_Function
80531>>>
80531>>>       
80531>>>
80531>>>
80531>>>    End_Object
80532>>>
80532>>>    Object oGroup1 is a Group
80534>>>        Set Size to 32 190
80535>>>        Set Location to 3 4
80536>>>        Set Label to "Seleccionar Empleado"
80537>>>
80537>>>        Object TxtCodigoEmpleado is a Form
80539>>>            Set Size to 13 34
80540>>>            Set Location to 11 8
80541>>>            Set Prompt_Button_Mode to PB_PromptOn
80542>>>            Set Prompt_Object to (ListaEmpleado(Current_Object))
80543>>>
80543>>>            Procedure OnChange
80546>>>                Forward Send OnChange
80548>>>                Set Value of EtiquetaNombreEmpleado to (Trim(Empleado.PrimerNombre) + ' ' + Trim(Empleado.SegundoNombre) + ' ' + Trim(Empleado.PrimerApellido) + ' ' + Trim(Empleado.SegundoApellido)) 
80549>>>                
80549>>>            End_Procedure
80550>>>        
80550>>>            // OnChange is called on every changed character
80550>>>        //    Procedure OnChange
80550>>>        //        String sValue
80550>>>        //    
80550>>>        //        Get Value to sValue
80550>>>        //    End_Procedure
80550>>>        
80550>>>        End_Object
80551>>>
80551>>>        Object EtiquetaNombreEmpleado is a TextBox
80553>>>            Set Size to 10 150
80554>>>            Set Location to 13 47
80555>>>        End_Object
80556>>>    End_Object
80557>>>
80557>>>    Object oGroup2 is a Group
80559>>>        Set Size to 36 190
80560>>>        Set Location to 36 5
80561>>>        Set Label to "Rango de Fechas"
80562>>>
80562>>>        Object TxtFechaDel is a Form
80564>>>            Set Size to 13 44
80565>>>            Set Location to 13 17
80566>>>            Set Label to "Del :"
80567>>>            Set Label_Col_Offset to 15
80568>>>            Set Form_Datatype to Mask_Date_Window
80569>>>            Set Prompt_Object to oMonthCalendarPrompt
80570>>>            Set Prompt_Button_Mode to PB_PromptOn
80571>>>        
80571>>>            // OnChange is called on every changed character
80571>>>        //    Procedure OnChange
80571>>>        //        String sValue
80571>>>        //    
80571>>>        //        Get Value to sValue
80571>>>        //    End_Procedure
80571>>>        
80571>>>        End_Object
80572>>>
80572>>>        Object TxtFechaAl is a Form
80574>>>            Set Size to 13 44
80575>>>            Set Location to 13 83
80576>>>            Set Label to "al :"
80577>>>            Set Label_Col_Offset to 15
80578>>>            Set Form_Datatype to Mask_Date_Window
80579>>>            Set Prompt_Object to oMonthCalendarPrompt
80580>>>            Set Prompt_Button_Mode to PB_PromptOn
80581>>>        
80581>>>            // OnChange is called on every changed character
80581>>>        //    Procedure OnChange
80581>>>        //        String sValue
80581>>>        //    
80581>>>        //        Get Value to sValue
80581>>>        //    End_Procedure
80581>>>        
80581>>>        End_Object
80582>>>
80582>>>        Object BtnCalcualar is a Button
80584>>>            Set Location to 12 137
80585>>>            Set Label to "Calcular"
80586>>>        
80586>>>            // fires when the button is clicked
80586>>>            Procedure OnClick
80589>>>              
80589>>>                 Send DoFillGrid of GridRegistros
80590>>>                 
80590>>>            End_Procedure
80591>>>        
80591>>>        End_Object
80592>>>    End_Object
80593>>>
80593>>>    Object oGroup3 is a Group
80595>>>        Set Size to 132 191
80596>>>        Set Location to 74 5
80597>>>        Set Label to "Resultados"
80598>>>
80598>>>        Object TxtTotalMarcajes is a Form
80600>>>            Set Size to 13 25
80601>>>            Set Location to 10 63
80602>>>            Set Label to "Total de Marcajes:"
80603>>>            Set Label_Col_Offset to 58
80604>>>            Set Enabled_State to False
80605>>>            
80605>>>        
80605>>>            // OnChange is called on every changed character
80605>>>        //    Procedure OnChange
80605>>>        //        String sValue
80605>>>        //    
80605>>>        //        Get Value to sValue
80605>>>        //    End_Procedure
80605>>>        
80605>>>        End_Object
80606>>>
80606>>>        Object GridRegistros is a Grid
80608>>>            Set Location to 26 3
80609>>>        
80609>>>            Set Size to 100 184
80610>>>        
80610>>>            Set Line_Width to 4 0
80611>>>        
80611>>>            Set Form_Width 0 to 18
80612>>>            Set Header_Label 0 to "#"
80613>>>        
80613>>>            Set Form_Width 1 to 40
80614>>>            Set Header_Label 1 to "Fecha"
80615>>>        
80615>>>            Set Form_Width 2 to 40
80616>>>            Set Header_Label 2 to "Hora"
80617>>>            Set Header_Label 3 to "Tipo Marcaje"
80618>>>            Set Form_Width 3 to 50
80619>>>        
80619>>>            // Sample method of how to fill a grid
80619>>>            Procedure DoFillGrid
80622>>>                
80622>>>                Integer iEmpleado iContar
80622>>>                Date dDel dAl
80622>>>                String sMensaje
80622>>>                
80622>>>                Get Value of TxtCodigoEmpleado to  iEmpleado
80623>>>                Get Value of TxtFechaDel to dDel
80624>>>                Get Value of TxtFechaAl to dAl
80625>>>                
80625>>>                Move 0 to iContar
80626>>>                
80626>>>                Clear Marcajes
80627>>>                Move iEmpleado to Marcajes.Empleado
80628>>>                Move dDel to Marcajes.FechaMarcaje
80629>>>                Find gt Marcajes by Index.2
80630>>>>
80630>>>                Find eq TipoMarcaje by Index.1
80631>>>>
80631>>>                // ************************************************************
80631>>>                While (Found and iEmpleado eq Marcajes.Empleado and Marcajes.FechaMarcaje ge dDel and Marcajes.FechaMarcaje le dAl)
80635>>>                Move (iContar + 1) to iContar
80636>>>                    
80636>>>               // If (Marcajes.TipoMarcaje EQ 2) Move (iContar + 1) to iContar
80636>>>                  Send Add_Item 0 (iContar)
80637>>>                  Send Add_Item 1 (Marcajes.FechaMarcaje)
80638>>>                  Send Add_Item 2 (Marcajes.HoraMarcaje)
80639>>>                  Send Add_Item 3 (marcajes.TipoMarcaje)
80640>>>                  
80640>>>                  
80640>>>                
80640>>>                Find gt Marcajes by Index.2
80641>>>>
80641>>>                Loop
80642>>>>
80642>>>                
80642>>>                Move "Se encontraron " to sMensaje
80643>>>                Append sMensaje iContar
80644>>>                Append sMensaje " registros en la tabla Marcaje"
80645>>>                //Send Info_Box sMensaje "Informacion"
80645>>>                Set Value of TxtTotalMarcajes to iContar
80646>>>                
80646>>>            End_Procedure
80647>>>            
80647>>>        End_Object
80648>>>       
80648>>>
80648>>>    Object oDbList1 is a dbList
80650>>>        Set Size to 100 200
80651>>>        Set Location to 92 222
80652>>>
80652>>>        Begin_Row
80655>>>            Entry_Item Empleado.Numero
80656>>>            Entry_Item Marcajes.FechaMarcaje
80657>>>            Entry_Item Marcajes.HoraMarcaje
80658>>>        End_Row
80663>>>
80663>>>        Set Main_File to Marcajes.File_Number
80664>>>
80664>>>        Set Form_Width 0 to 24
80665>>>        Set Header_Label 0 to "Empleado"
80666>>>        Set Form_Width 1 to 60
80667>>>        Set Header_Label 1 to "FechaMarcaje"
80668>>>        Set Form_Width 2 to 72
80669>>>        Set Header_Label 2 to "HoraMarcaje"
80670>>>    End_Object
80671>>>    
80671>>>    
80671>>>    
80671>>>  Procedure Calculardatos 
80674>>>    Integer NumEmpleado
80674>>>    Date FechaInciaConteo
80674>>>    Date FechaFinalizaConteo
80674>>>    Integer Contador
80674>>>    Move 0 to Contador
80675>>>    Get Value of TxtCodigoEmpleado to NumEmpleado
80676>>>    Get Value of TxtFechaDel to FechaInciaConteo
80677>>>    Get Value of TxtFechaAl to FechaFinalizaConteo
80678>>>    
80678>>>    
80678>>>        Begin
80678>>>>
80678>>>            While (FechaInciaConteo <= FechaFinal)
80682>>>                If (NumEmpleado = Marcaje.Empleado) Begin
80684>>>                    Move (Contador + 1) to Contador
80685>>>                End
80685>>>>
80685>>>            Loop
80686>>>>
80686>>>        End
80686>>>>
80686>>>        
80686>>>        Set Value of TxtTotalMarcajes to Contador
80687>>>  End_Procedure
80688>>>
80688>>>    End_Object
80689>>> End_Object
80690>
80690>        Procedure Activate_About
80693>            Send DoAbout "" "" "" "" ""
80694>        End_Procedure
80695>
80695>    End_Object
80696>
80696>End_Object
80697>
80697>Start_UI
80698>
80698>//************************** end of WindowsProject.tpl for Spanish **************
80698>
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 45716
Total Resources: 0
Total Commands : 80697
Total Windows  : 1
Total Pages    : 1
Static Data    : 494971
Message area   : 559413
Total Blocks   : 28923
